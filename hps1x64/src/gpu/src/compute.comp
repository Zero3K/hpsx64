R"(
#version 450 core


//#define ENABLE_PRIMITIVE_LOOP
//#define USE_MORE_JUMPS
#define USE_VECTOR_LOADSTORE
#define ENABLE_PIXELIN_BUFFER


layout (local_size_x = 16, local_size_y = 16) in;

layout (std430, binding = 0) restrict buffer sCmd {
	// the input commands to draw
	int data [ 128 * ( 1 << 16 ) ];
};

layout (std430, binding = 1) restrict buffer Cmd {
	// the input commands to draw
	uint inputdata [ 16 * ( 1 << 16 ) ];
};

layout (std430, binding = 3) buffer FrameBuf {

// the shader representation of vram
uint VRAM [ 1024 * 512 ];

};

layout (std430, binding = 3) buffer FrameBuf4 {

// the shader representation of vram
uvec4 VRAM4 [ ( 1024 * 512 ) >> 2 ];

};


layout (std430, binding = 4) restrict buffer ShadowFrameBuf {

// the shader representation of vram
uint sVRAM [ 1024 * 512 ];

};

layout (std430, binding = 2) restrict buffer ScreenBuf {
// the display window
uint pixelbuffer32 [ 1024 * 512 ];
};


layout (std430, binding = 5) restrict buffer InputPixels {
// the display window
uint PixelInput32 [ 1 << 20 ];
};


layout (binding = 5,rgba8) restrict writeonly uniform image2D destTex;


const int c_iDitherValues16 [] = { -4 << 16, 0 << 16, -3 << 16, 1 << 16,
								2 << 16, -2 << 16, 3 << 16, -1 << 16,
								-3 << 16, 1 << 16, -4 << 16, 0 << 16,
								3 << 16, -1 << 16, 2 << 16, -2 << 16 };

const int c_MaxPolygonWidth = 1023;
const int c_MaxPolygonHeight = 511;

const int c_lFrameBuffer_Width = 1024;
const int c_lFrameBuffer_Height = 512;
const int c_lFrameBuffer_Width_Mask = 1023;
const int c_lFrameBuffer_Height_Mask = 511;

shared int xinc;
shared int yinc;
shared int xxinc;

shared int group_x, group_y;
shared int group_xcount, group_ycount;
shared int group_xinc, group_yinc;
shared int group_xshift, group_yshift;
shared int group_xmask, group_ymask;

shared int group_vxinc;
shared int group_vxmask;



shared int group_yoffset;


#define intdivf(op1, op2, fp1, fp2, fpout) (int(( ( float( (op1) ) / float( 1 << (fp1) ) ) / ( float( (op2) ) / float( 1 << (fp2) ) ) ) * float(1 << (fpout))))
#define intdivd(op1, op2, fp1, fp2, fpout) (int(( ( double( (op1) ) / double( 1 << (fp1) ) ) / ( double( (op2) ) / double( 1 << (fp2) ) ) ) * double(1 << (fpout))))

//shared uint bgr16;
//shared uint bgr32;

//shared int w, h, xmax, ymax, ymax2;
//shared int x, y;



//shared uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
//shared int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
//shared int DrawArea_OffsetX, DrawArea_OffsetY;
//shared uint Command_ABE;

//shared uint PixelMask, SetPixelMask;




shared int sX, dX, sY, dY;
shared int SrcStartX, SrcStartY, DstStartX, DstStartY, Height, Width, SrcXRun, DstXRun, Width1, Width2;

shared int BS, Count;

//shared uint Comm;
shared int SharedYMax, xximagepixelstart;

shared uint GPU_CTRL_Read;
shared int DisplayRange_X1;
shared int DisplayRange_X2;
shared int DisplayRange_Y1;
shared int DisplayRange_Y2;
shared int ScreenArea_TopLeftX;
shared int ScreenArea_TopLeftY;
shared int bEnableScanline;
shared int Y_Pixel;

// need to know visible range of screen for NTSC and for PAL (each should be different)
// NTSC visible y range is usually from 16-256 (0x10-0x100) (height=240)
// PAL visible y range is usually from 35-291 (0x23-0x123) (height=256)
// NTSC visible x range is.. I don't know. start with from about gpu cycle#544 to about gpu cycle#3232 (must use gpu cycles since res changes)
shared int VisibleArea_StartX, VisibleArea_EndX, VisibleArea_StartY, VisibleArea_EndY, VisibleArea_Width, VisibleArea_Height;
// this allows you to calculate horizontal pixels
shared int GPU_CyclesPerPixel;
// need to know where to draw the actual image at
shared int Draw_StartX, Draw_StartY, Draw_EndX, Draw_EndY, Draw_Width, Draw_Height;

shared int Source_Height;
shared int TopBorder_Height, BottomBorder_Height, LeftBorder_Width, RightBorder_Width;
shared int current_width, current_height, current_size, current_xmax, current_ymax;

shared uint GPU_CTRL_Read_ISINTER;
shared uint GPU_CTRL_Read_HEIGHT;
shared uint GPU_CTRL_Read_WIDTH;
shared uint GPU_CTRL_Read_DEN;
shared uint GPU_CTRL_Read_ISRGB24;
shared uint GPU_CTRL_Read_VIDEO;



void precompute_data ()
{
	//const int iDataCount = ( 1 << 16 );
	//const int iDataElementSize = 128;
	//const int iDataShift = 7;

	int xxid = int( gl_LocalInvocationIndex );

	uint uIdx;
	uint uIndex;

	uint Comm;

	uint bgr32;
	uint bgr16;
	//int x0, x1, x2;
	//int y0, y1, y2;
	int w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	//int u0;
	//int v0;
	
	// bits 0-5 in upper halfword
	int clut_x;
	int clut_y;

	int TWY;
	int TWX;
	int TWH;
	int TWW;
		
	int tpage_tx;
	int tpage_ty;
	int tpage_tp;
	int Shift1;
	int Shift2;
	int And1;
	int And2;
	int TWYTWH;
	int TWXTWW;
	int Not_TWH;
	int Not_TWW;
	int TextureOffset;
	int ClutOffset;
	int clut_xoffset;

	uint Command_TGE;

	int Temp;
	uint GPU_CTRL_Read_DTD;

	int tpage_abr;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	int Coord0, Coord1, Coord2;

	int gx [ 3 ], gy [ 3 ];
	uint gbgr [ 3 ];

	int x_left, x_right;
	int LeftMostX, RightMostX;

	int dR_left, dG_left, dB_left;
	int dR_across, dG_across, dB_across;
	int R_left, G_left, B_left;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	int u0, v0, u1, v1, u2, v2;
	int dU_left, dV_left;
	int dU_across, dV_across;
	int U_left, V_left;
	int gu [ 3 ], gv [ 3 ];



	int bDraw;


	// loop through data
	uIndex = xxid << 4;
	uIdx = xxid << 7;

	do
	{

		Comm = inputdata [ uIndex + 7 ] >> 24;

		// pre compute common data //
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];

		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		bgr32 = inputdata [ uIndex + 7 ] & 0x00ffffff;
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );

		bDraw = 1;
		
		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			//return;
			bDraw = 0;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			//return;
			bDraw = 0;
		}


		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;

		Command_TGE = ( inputdata [ uIndex + 7 ] >> 24 ) & 1;

		// bits 0-5 in upper halfword
		clut_x = int ( inputdata [ uIndex + 9 ] >> ( 16 + 0 ) ) & 0x3f;
		clut_y = int ( inputdata [ uIndex + 9 ] >> ( 16 + 6 ) ) & 0x1ff;

		//////////////////////////////////////////////////////
		// Get offset into color lookup table
		ClutOffset = clut_y << 10;
		clut_xoffset = clut_x << 4;

		TWY = int ( inputdata [ uIndex + 4 ] >> 15 ) & 0x1f;
		TWX = int ( inputdata [ uIndex + 4 ] >> 10 ) & 0x1f;
		TWH = int ( inputdata [ uIndex + 4 ] >> 5 ) & 0x1f;
		TWW = int ( inputdata [ uIndex + 4 ] ) & 0x1f;

		TWYTWH = ( ( TWY & TWH ) << 3 );
		TWXTWW = ( ( TWX & TWW ) << 3 );
		
		Not_TWH = ~( TWH << 3 );
		Not_TWW = ~( TWW << 3 );

		Shift1 = 0;
		Shift2 = 0;
		And1 = 0;
		And2 = 0;



		if ( ( Comm >= 0x60 ) && ( Comm <= 0x7f ) )
		{

		// strictly for 2d objects //

		// bits 0-3
		tpage_tx = int( GPU_CTRL_Read ) & 0xf;
		
		// bit 4
		tpage_ty = int( GPU_CTRL_Read >> 4 ) & 1;
		
		// bits 7-8
		tpage_tp = int( GPU_CTRL_Read >> 7 ) & 3;
		

		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		
		if ( tpage_tp == 0 )
		{
			And2 = 0xf;
			
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			And2 = 0xff;
			
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}



		x0 = int( inputdata [ uIndex + 8 ] );
		y0 = x0 >> 16;
		
		// x and y are actually 11 bits
		x0 = ( x0 << ( 5 + 16 ) ) >> ( 5 + 16 );
		y0 = ( y0 << ( 5 + 16 ) ) >> ( 5 + 16 );

		// pixel/rectangle/sprite only //

		
		
		w = int( inputdata [ uIndex + 10 ] );
		h = w >> 16;

		//w &= 0xffff;
		//h &= 0xffff;
		w &= 0x3ff;
		h &= 0x1ff;
		
		// get top left corner of sprite and bottom right corner of sprite
		x0 = x0 + DrawArea_OffsetX;
		y0 = y0 + DrawArea_OffsetY;
		x1 = x0 + w - 1;
		y1 = y0 + h - 1;


		StartX = x0;
		EndX = x1;
		StartY = y0;
		EndY = y1;

		
		// check if sprite is within draw area
		if ( x1 < DrawArea_TopLeftX || x0 > DrawArea_BottomRightX || y1 < DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;


		u0 = int ( inputdata [ uIndex + 9 ] );
		v0 = u0 >> 8;

		// get rid of any junk data
		u0 &= 0xff;
		v0 &= 0xff;

		if ( StartY < DrawArea_TopLeftY )
		{
			v0 += ( DrawArea_TopLeftY - StartY );
			StartY = DrawArea_TopLeftY;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY;
		}
		
		if ( StartX < DrawArea_TopLeftX )
		{
			u0 += ( DrawArea_TopLeftX - StartX );
			StartX = DrawArea_TopLeftX;
		}
		
		if ( EndX > DrawArea_BottomRightX )
		{
			EndX = DrawArea_BottomRightX;
		}


		if ( ( bgr32 & 0x00ffffff ) == 0x00808080 ) Command_TGE = 1;

		
		// if textured and tge==1, then bgr32 = 0x00808080
		if ( ( ( Comm & 0x4 ) != 0 ) && ( Command_TGE == 1 ) )
		{
			bgr32 = 0x00808080;
		}

		// bDraw
		// GPU_CTRL_Read_ABR,Command_ABE,Command_TGE,PixelMask,SetPixelMask
		// bgr32,bgr16
		// StartX,EndX,StartY,EndY
		// Shift1,Shift2,And1,And2
		// u0,v0
		// TWYTWH,TWXTWW,Not_TWH,Not_TWW
		// TextureOffset,ClutOffset,clut_xoffset
		data [ uIdx + 0 ] = bDraw;
		data [ uIdx + 1 ] = int( PixelMask );
		data [ uIdx + 2 ] = int( SetPixelMask );
		data [ uIdx + 3 ] = int( GPU_CTRL_Read_ABR );
		data [ uIdx + 4 ] = int( Command_ABE );
		data [ uIdx + 5 ] = int( Command_TGE );
		data [ uIdx + 6 ] = int( bgr32 );
		data [ uIdx + 7 ] = int( bgr16 );
		data [ uIdx + 8 ] = StartX;
		data [ uIdx + 9 ] = EndX;
		data [ uIdx + 10 ] = StartY;
		data [ uIdx + 11 ] = EndY;
		data [ uIdx + 12 ] = Shift1;
		data [ uIdx + 13 ] = Shift2;
		data [ uIdx + 14 ] = And1;
		data [ uIdx + 15 ] = And2;
		data [ uIdx + 16 ] = u0;
		data [ uIdx + 17 ] = v0;
		data [ uIdx + 18 ] = TWYTWH;
		data [ uIdx + 19 ] = TWXTWW;
		data [ uIdx + 20 ] = Not_TWH;
		data [ uIdx + 21 ] = Not_TWW;
		data [ uIdx + 22 ] = TextureOffset;
		data [ uIdx + 23 ] = ClutOffset;
		data [ uIdx + 24 ] = clut_xoffset;
		data [ uIdx + 25 ] = x0;
		data [ uIdx + 26 ] = y0;

		}


		if ( ( Comm >= 0x20 ) && ( Comm <= 0x3f ) )
		{

		// strictly for 3d objects //
	// -----------------------------------------------

		gbgr [ 0 ] = inputdata [ uIndex + 7 ] & 0x00ffffff;
		gbgr [ 1 ] = inputdata [ uIndex + 10 ] & 0x00ffffff;
		gbgr [ 2 ] = inputdata [ uIndex + 13 ] & 0x00ffffff;
		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 5 ) >> 21 );
		gx [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 21 ) >> 21 );
		gy [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 5 ) >> 21 );

		gu [ 0 ] = int( inputdata [ uIndex + 9 ] ) & 0xff;
		gu [ 1 ] = int( inputdata [ uIndex + 12 ] ) & 0xff;
		gu [ 2 ] = int( inputdata [ uIndex + 15 ] ) & 0xff;
		gv [ 0 ] = int( inputdata [ uIndex + 9 ] >> 8 ) & 0xff;
		gv [ 1 ] = int( inputdata [ uIndex + 12 ] >> 8 ) & 0xff;
		gv [ 2 ] = int( inputdata [ uIndex + 15 ] >> 8 ) & 0xff;

		
		//GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		

		// if textured and tge==1, then bgr32 = 0x00808080
		if ( ( ( Comm & 0x4 ) != 0 ) && ( Command_TGE == 1 ) )
		{
			gbgr[0] = 0x00808080;
			gbgr[1] = 0x00808080;
			gbgr[2] = 0x00808080;

			// also means no dithering on the texture
			GPU_CTRL_Read_DTD = 0;
		}


		Coord0 = 0;
		Coord1 = 1;
		Coord2 = 2;
		
		
		///////////////////////////////////
		// put top coordinates in x0,y0
		if ( gy [ Coord1 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord1;
			Coord1 = Temp;
		}
		
		if ( gy [ Coord2 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord2;
			Coord2 = Temp;
		}
		
		///////////////////////////////////////
		// put middle coordinates in x1,y1
		if ( gy [ Coord2 ] < gy [ Coord1 ] )
		{
			Temp = Coord1;
			Coord1 = Coord2;
			Coord2 = Temp;
		}
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		x2 = gx [ Coord2 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		y2 = gy [ Coord2 ];

		// get u,v coords
		u0 = gu [ Coord0 ];
		u1 = gu [ Coord1 ];
		u2 = gu [ Coord2 ];
		v0 = gv [ Coord0 ];
		v1 = gv [ Coord1 ];
		v2 = gv [ Coord2 ];

		// get rgb-values
		r0 = int( gbgr [ Coord0 ] ) & 0xff;
		r1 = int( gbgr [ Coord1 ] ) & 0xff;
		r2 = int( gbgr [ Coord2 ] ) & 0xff;
		g0 = int( gbgr [ Coord0 ] >> 8 ) & 0xff;
		g1 = int( gbgr [ Coord1 ] >> 8 ) & 0xff;
		g2 = int( gbgr [ Coord2 ] >> 8 ) & 0xff;
		b0 = int( gbgr [ Coord0 ] >> 16 ) & 0xff;
		b1 = int( gbgr [ Coord1 ] >> 16 ) & 0xff;
		b2 = int( gbgr [ Coord2 ] >> 16 ) & 0xff;
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 = DrawArea_OffsetX + x0;
		y0 = DrawArea_OffsetY + y0;
		x1 = DrawArea_OffsetX + x1;
		y1 = DrawArea_OffsetY + y1;
		x2 = DrawArea_OffsetX + x2;
		y2 = DrawArea_OffsetY + y2;
		
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );


		tpage_tx = int( inputdata [ uIndex + 12 ] >> ( 16 + 0 ) ) & 0xf;
		tpage_ty = int( inputdata [ uIndex + 12 ] >> ( 16 + 4 ) ) & 1;
		tpage_abr = int( inputdata [ uIndex + 12 ] >> ( 16 + 5 ) ) & 3;
		tpage_tp = int( inputdata [ uIndex + 12 ] >> ( 16 + 7 ) ) & 3;




		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		
		if ( tpage_tp == 0 )
		{
			And2 = 0xf;
			
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			And2 = 0xff;
			
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}
		

		
		/////////////////////////////////////////////////
		// draw top part of triangle
		
		// denominator is negative when x1 is on the left, positive when x1 is on the right
		t0 = y1 - y2;
		t1 = y0 - y2;
		denominator = ( ( x0 - x2 ) * t0 ) - ( ( x1 - x2 ) * t1 );
		if ( denominator != 0 )
		{
			/*
			dR_across = ( ( ( ( ( r0 - r2 ) * t0 ) - ( ( r1 - r2 ) * t1 ) ) ) << 8 ) / denominator;
			dG_across = ( ( ( ( ( g0 - g2 ) * t0 ) - ( ( g1 - g2 ) * t1 ) ) ) << 8 ) / denominator;
			dB_across = ( ( ( ( ( b0 - b2 ) * t0 ) - ( ( b1 - b2 ) * t1 ) ) ) << 8 ) / denominator;
			
			dU_across = ( ( ( ( ( u0 - u2 ) * t0 ) - ( ( u1 - u2 ) * t1 ) ) ) << 8 ) / denominator;
			dV_across = ( ( ( ( ( v0 - v2 ) * t0 ) - ( ( v1 - v2 ) * t1 ) ) ) << 8 ) / denominator;
			
			dR_across <<= 8;
			dG_across <<= 8;
			dB_across <<= 8;
			
			dU_across <<= 8;
			dV_across <<= 8;
			*/

			dR_across = intdivd( ( ( ( ( ( r0 - r2 ) * t0 ) - ( ( r1 - r2 ) * t1 ) ) ) ), denominator, 0, 0, 16 );
			dG_across = intdivd( ( ( ( ( ( g0 - g2 ) * t0 ) - ( ( g1 - g2 ) * t1 ) ) ) ), denominator, 0, 0, 16 );
			dB_across = intdivd( ( ( ( ( ( b0 - b2 ) * t0 ) - ( ( b1 - b2 ) * t1 ) ) ) ), denominator, 0, 0, 16 );
			
			dU_across = intdivd( ( ( ( ( ( u0 - u2 ) * t0 ) - ( ( u1 - u2 ) * t1 ) ) ) ), denominator, 0, 0, 16 );
			dV_across = intdivd( ( ( ( ( ( v0 - v2 ) * t0 ) - ( ( v1 - v2 ) * t1 ) ) ) ), denominator, 0, 0, 16 );

			//dUx_across = dU_across * xinc;
			//dVx_across = dV_across * xinc;

			//dRx_across = dR_across * xinc;
			//dGx_across = dG_across * xinc;
			//dBx_across = dB_across * xinc;
		}
		
		
		
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
			if ( ( y1 - y0 ) != 0 )
			{
				/////////////////////////////////////////////
				// init x on the left and right
				x_left = ( x0 << 16 );
				x_right = x_left;
				
				R_left = ( r0 << 16 );
				G_left = ( g0 << 16 );
				B_left = ( b0 << 16 );

				U_left = ( u0 << 16 );
				V_left = ( v0 << 16 );
				
				if ( denominator < 0 )
				{
					dx_left = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					
					dR_left = (( r1 - r0 ) << 16 ) / ( y1 - y0 );
					dG_left = (( g1 - g0 ) << 16 ) / ( y1 - y0 );
					dB_left = (( b1 - b0 ) << 16 ) / ( y1 - y0 );
					
					dU_left = ( (( u1 - u0 ) << 16 ) ) / ( y1 - y0 );
					dV_left = ( (( v1 - v0 ) << 16 ) ) / ( y1 - y0 );
				}
				else
				{
					dx_right = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					
					dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
					dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
					dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
					
					dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
					dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
				}
			}
			else
			{
				if ( denominator < 0 )
				{
					// change x_left and x_right where y1 is on left
					x_left = ( x1 << 16 );
					x_right = ( x0 << 16 );
					
					R_left = ( r1 << 16 );
					G_left = ( g1 << 16 );
					B_left = ( b1 << 16 );

					U_left = ( u1 << 16 );
					V_left = ( v1 << 16 );
					
					if ( ( y2 - y1 ) != 0 )
					{
						dx_left = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						
						dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
						dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
						dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
						
						dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
						dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
					}
				}
				else
				{
					x_right = ( x1 << 16 );
					x_left = ( x0 << 16 );
				
					R_left = ( r0 << 16 );
					G_left = ( g0 << 16 );
					B_left = ( b0 << 16 );
					
					U_left = ( u0 << 16 );
					V_left = ( v0 << 16 );
					
					if ( ( y2 - y1 ) != 0 )
					{
						dx_right = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						
						dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
						dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
						dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
						
						dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
						dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
					}
				}
			}
		//}
		

		
		
		// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
		R_left |= ( 1 << 15 );
		G_left |= ( 1 << 15 );
		B_left |= ( 1 << 15 );

		U_left |= ( 1 << 15 );
		V_left |= ( 1 << 15 );

		//x_left += 0xffff;
		//x_right -= 1;
		
		StartY = y0;
		EndY = y1;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
			
			R_left += dR_left * Temp;
			G_left += dG_left * Temp;
			B_left += dB_left * Temp;
			
			U_left += dU_left * Temp;
			V_left += dV_left * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}


		// check if sprite is within draw area
		if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || y2 <= DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		//if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( x2 - x1 ) > c_MaxPolygonWidth ) || ( y1 - y0 > c_MaxPolygonHeight ) || ( y2 - y1 > c_MaxPolygonHeight ) )
		if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( y2- y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			//return;
			bDraw = 0;
		}


		data [ uIdx + 0 ] = bDraw;
		data [ uIdx + 1 ] = int( PixelMask );
		data [ uIdx + 2 ] = int( SetPixelMask );
		data [ uIdx + 3 ] = int( GPU_CTRL_Read_ABR );
		data [ uIdx + 4 ] = int( Command_ABE );
		data [ uIdx + 5 ] = int( Command_TGE );
		data [ uIdx + 6 ] = int( bgr32 );
		data [ uIdx + 7 ] = int( bgr16 );
		data [ uIdx + 8 ] = int( GPU_CTRL_Read_DTD );
		data [ uIdx + 9 ] = int( DrawArea_TopLeftX );
		data [ uIdx + 10 ] = int( DrawArea_BottomRightX );
		data [ uIdx + 11 ] = EndY;
		data [ uIdx + 12 ] = Shift1;
		data [ uIdx + 13 ] = Shift2;
		data [ uIdx + 14 ] = And1;
		data [ uIdx + 15 ] = And2;
		data [ uIdx + 16 ] = TWYTWH;
		data [ uIdx + 17 ] = TWXTWW;
		data [ uIdx + 18 ] = Not_TWH;
		data [ uIdx + 19 ] = Not_TWW;
		data [ uIdx + 20 ] = TextureOffset;
		data [ uIdx + 21 ] = ClutOffset;
		data [ uIdx + 22 ] = clut_xoffset;
		data [ uIdx + 23 ] = tpage_abr;
		data [ uIdx + 24 ] = dR_across;
		data [ uIdx + 25 ] = dG_across;
		data [ uIdx + 26 ] = dB_across;
		data [ uIdx + 27 ] = dU_across;
		data [ uIdx + 28 ] = dV_across;
		//data [ uIdx + 29 ] = v0;
		data [ uIdx + 30 ] = StartY;
		data [ uIdx + 31 ] = EndY;
		data [ uIdx + 32 ] = x_left;
		data [ uIdx + 33 ] = x_right;
		data [ uIdx + 34 ] = dx_left;
		data [ uIdx + 35 ] = dx_right;
		data [ uIdx + 36 ] = R_left;
		data [ uIdx + 37 ] = G_left;
		data [ uIdx + 38 ] = B_left;
		data [ uIdx + 39 ] = dR_left;
		data [ uIdx + 40 ] = dG_left;
		data [ uIdx + 41 ] = dB_left;
		data [ uIdx + 42 ] = U_left;
		data [ uIdx + 43 ] = V_left;
		data [ uIdx + 44 ] = dU_left;
		data [ uIdx + 45 ] = dV_left;



	// -------------------------------------------


		//////////////////////////////////////////////////////
		// check if y1 is on the left or on the right
		if ( denominator < 0 )
		{
			x_left = ( x1 << 16 );

			x_right = ( x0 << 16 ) + ( dx_right * ( y1 - y0 ) );
			
			R_left = ( r1 << 16 );
			G_left = ( g1 << 16 );
			B_left = ( b1 << 16 );
			
			// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
			R_left |= ( 1 << 15 );
			G_left |= ( 1 << 15 );
			B_left |= ( 1 << 15 );

			U_left = ( u1 << 16 );
			V_left = ( v1 << 16 );
			
			if ( ( y2 - y1 ) != 0 )
			{
				dx_left = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				
				dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
				dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
				dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
				
				dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
				dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
			}
		}
		else
		{
			x_right = ( x1 << 16 );

			x_left = ( x0 << 16 ) + ( dx_left * ( y1 - y0 ) );
			
			R_left = ( ( r0 << 16 ) | 0x8000 ) + ( dR_left * ( y1 - y0 ) );
			G_left = ( ( g0 << 16 ) | 0x8000 ) + ( dG_left * ( y1 - y0 ) );
			B_left = ( ( b0 << 16 ) | 0x8000 ) + ( dB_left * ( y1 - y0 ) );
			
			U_left = ( u0 << 16 ) + ( dU_left * ( y1 - y0 ) );
			V_left = ( v0 << 16 ) + ( dV_left * ( y1 - y0 ) );
			
			if ( ( y2 - y1 ) != 0 )
			{
				dx_right = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
			}
		}


		//R_left += ( 1 << 15 );
		//G_left += ( 1 << 15 );
		//B_left += ( 1 << 15 );

		U_left += ( 1 << 15 );
		V_left += ( 1 << 15 );
		

		
		StartY = y1;
		EndY = y2;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
			
			R_left += dR_left * Temp;
			G_left += dG_left * Temp;
			B_left += dB_left * Temp;
			
			U_left += dU_left * Temp;
			V_left += dV_left * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}


	// ---------------------------------------------

		
		data [ uIdx + 46 ] = StartY;
		data [ uIdx + 47 ] = EndY;
		data [ uIdx + 48 ] = x_left;
		data [ uIdx + 49 ] = x_right;
		data [ uIdx + 50 ] = dx_left;
		data [ uIdx + 51 ] = dx_right;
		data [ uIdx + 52 ] = R_left;
		data [ uIdx + 53 ] = G_left;
		data [ uIdx + 54 ] = B_left;
		data [ uIdx + 55 ] = dR_left;
		data [ uIdx + 56 ] = dG_left;
		data [ uIdx + 57 ] = dB_left;
		data [ uIdx + 58 ] = U_left;
		data [ uIdx + 59 ] = V_left;
		data [ uIdx + 60 ] = dU_left;
		data [ uIdx + 61 ] = dV_left;
		

		}	// end if ( ( Comm >= 0x20 ) && ( Comm <= 0x3f ) )


// -------------------------------------------------------
		
		uIndex += ( xxinc << 4 );
		uIdx += ( xxinc << 7 );

	} while ( ( Comm != 0xff ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );

	barrier ();
}

void draw_texture ( int xsize, int ysize )
{
	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );

	ivec2 pos;
	uvec4 rgba;
	int pixel;
	vec4 frgba;

	// don't know if all the threads have completed all the other tasks yet
	barrier ();

	for ( pos.y = ( yid << group_yshift ) + group_y; pos.y < ysize; pos.y += group_yinc )
	{
		for ( pos.x = ( xid << group_xshift ) + group_x; pos.x < xsize; pos.x += group_xinc )
		{
			pixel = int( pixelbuffer32 [ pos.x + ( pos.y * xsize ) ] );

			//frgba.b = float( ( pixel >> 16 ) & 0xff ) / 255.0;
			//frgba.g = float( ( pixel >> 8 ) & 0xff ) / 255.0;
			//frgba.r = float( ( pixel >> 0 ) & 0xff ) / 255.0;
			//frgba.a = 1.0;

			frgba.b = float( ( pixel >> 16 ) & 0xff );
			frgba.g = float( ( pixel >> 8 ) & 0xff );
			frgba.r = float( ( pixel >> 0 ) & 0xff );

			frgba = frgba / 255.0;
			frgba.a = 1.0;

			imageStore( destTex, pos, frgba );
		}
	}
}

void draw_screen( uint uIndex )
{

	int xxid = int( gl_LocalInvocationIndex );
	


//inputdata format:
//0: GPU_CTRL_Read
//1: DisplayRange_Horizontal
//2: DisplayRange_Vertical
//3: ScreenArea_TopLeftX
//4: ScreenArea_TopLeftY
//5: bEnableScanline
//6: Y_Pixel
//7: --------
//8: Command

	
	const int c_iVisibleArea_StartX_Cycle = 584;
	const int c_iVisibleArea_EndX_Cycle = 3192;
	const int c_iVisibleArea_StartY_Pixel_NTSC = 15;
	const int c_iVisibleArea_EndY_Pixel_NTSC = 257;
	const int c_iVisibleArea_StartY_Pixel_PAL = 34;
	const int c_iVisibleArea_EndY_Pixel_PAL = 292;

	const int c_iVisibleArea_StartY [] = { c_iVisibleArea_StartY_Pixel_NTSC, c_iVisibleArea_StartY_Pixel_PAL };
	const int c_iVisibleArea_EndY [] = { c_iVisibleArea_EndY_Pixel_NTSC, c_iVisibleArea_EndY_Pixel_PAL };

	const int c_iGPUCyclesPerPixel [] = { 10, 7, 8, 0, 5, 0, 4, 0 };
	


	
	// so the max viewable width for PAL is 3232/4-544/4 = 808-136 = 672
	// so the max viewable height for PAL is 292-34 = 258
	
	// actually, will initially start with a 1 pixel border based on screen width/height and then will shift if something is off screen

	
	// there the frame buffer pixel, and then there's the screen buffer pixel
	uint Pixel16, Pixel32_0, Pixel32_1;
	uint pix0, pix1, pix2;
	
	
	
	//private Pixel_24bit_Format Pixel24;
	
	
	int FramePixel_X, FramePixel_Y;
	
	
	
	//global u16* private ptr_vram16;
	int iptr_vram16;
	//global u32* private ptr_pixelbuffer32;
	int iptr_pixelbuffer32;
	
	int current_x, current_y;
	int current_x2;

		
	
	
	
	if ( xxid == 0 )
	{
		uIndex <<= 4;

		
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DisplayRange_X1 = int( inputdata [ uIndex + 1 ] ) & 0xfff;
		DisplayRange_X2 = int( inputdata [ uIndex + 1 ] >> 12 ) & 0xfff;
		DisplayRange_Y1 = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DisplayRange_Y2 = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x7ff;
		ScreenArea_TopLeftX = int( inputdata [ uIndex + 3 ] ) & 0x3ff;
		ScreenArea_TopLeftY = int( inputdata [ uIndex + 3 ] >> 10 ) & 0x1ff;
		bEnableScanline = int( inputdata [ uIndex + 4 ] );
		Y_Pixel = int( inputdata [ uIndex + 5 ] );

		
		// bits 16-18
		GPU_CTRL_Read_WIDTH = ( GPU_CTRL_Read >> 16 ) & 7;
		
		// bit 19
		GPU_CTRL_Read_HEIGHT = ( GPU_CTRL_Read >> 19 ) & 1;
		
		// bit 20
		GPU_CTRL_Read_VIDEO = ( GPU_CTRL_Read >> 20 ) & 1;
		
		// bit 21
		GPU_CTRL_Read_ISRGB24 = ( GPU_CTRL_Read >> 21 ) & 1;
		
		// bit 22
		GPU_CTRL_Read_ISINTER = ( GPU_CTRL_Read >> 22 ) & 1;
		
		// bit 23
		GPU_CTRL_Read_DEN = ( GPU_CTRL_Read >> 23 ) & 1;
		
		
		// GPU cycles per pixel depends on width
		GPU_CyclesPerPixel = c_iGPUCyclesPerPixel [ GPU_CTRL_Read_WIDTH ];

		// get the pixel to start and stop drawing at
		Draw_StartX = DisplayRange_X1 / GPU_CyclesPerPixel;
		Draw_EndX = DisplayRange_X2 / GPU_CyclesPerPixel;
		Draw_StartY = DisplayRange_Y1;
		Draw_EndY = DisplayRange_Y2;

		Draw_Width = Draw_EndX - Draw_StartX;
		Draw_Height = Draw_EndY - Draw_StartY;
		// get the pixel to start and stop at for visible area
		VisibleArea_StartX = c_iVisibleArea_StartX_Cycle / GPU_CyclesPerPixel;
		VisibleArea_EndX = c_iVisibleArea_EndX_Cycle / GPU_CyclesPerPixel;

		// visible area start and end y depends on pal/ntsc
		VisibleArea_StartY = c_iVisibleArea_StartY [ GPU_CTRL_Read_VIDEO ];
		VisibleArea_EndY = c_iVisibleArea_EndY [ GPU_CTRL_Read_VIDEO ];

		VisibleArea_Width = VisibleArea_EndX - VisibleArea_StartX;
		VisibleArea_Height = VisibleArea_EndY - VisibleArea_StartY;


		Source_Height = Draw_Height;
		

		
		if ( ( GPU_CTRL_Read_ISINTER != 0 ) && ( GPU_CTRL_Read_HEIGHT != 0 ) )
		{
			// 480i mode //
			
			// if not simulating scanlines, then the draw height should double too
			if ( bEnableScanline == 0 )
			{
				VisibleArea_EndY += Draw_Height;
				VisibleArea_Height += Draw_Height;
				
				Draw_EndY += Draw_Height;
				
				Draw_Height <<= 1;
			}
			
			Source_Height <<= 1;
		}
		

		
		
		if ( GPU_CTRL_Read_DEN == 0 )
		{
			BottomBorder_Height = VisibleArea_EndY - Draw_EndY;
			LeftBorder_Width = Draw_StartX - VisibleArea_StartX;
			TopBorder_Height = Draw_StartY - VisibleArea_StartY;
			RightBorder_Width = VisibleArea_EndX - Draw_EndX;
			
			if ( BottomBorder_Height < 0 ) BottomBorder_Height = 0;
			if ( LeftBorder_Width < 0 ) LeftBorder_Width = 0;
			
			
			
			current_ymax = Draw_Height + BottomBorder_Height;
			current_xmax = Draw_Width + LeftBorder_Width;
			
			// make suree that ymax and xmax are not greater than the size of visible area
			if ( current_xmax > VisibleArea_Width )
			{
				// entire image is not on the screen, so take from left border and recalc xmax //

				LeftBorder_Width -= ( current_xmax - VisibleArea_Width );
				if ( LeftBorder_Width < 0 ) LeftBorder_Width = 0;
				current_xmax = Draw_Width + LeftBorder_Width;
				
				// make sure again we do not draw past the edge of screen
				if ( current_xmax > VisibleArea_Width ) current_xmax = VisibleArea_Width;
			}
			
			if ( current_ymax > VisibleArea_Height )
			{
				BottomBorder_Height -= ( current_ymax - VisibleArea_Height );
				if ( BottomBorder_Height < 0 ) BottomBorder_Height = 0;
				current_ymax = Draw_Height + BottomBorder_Height;
				
				// make sure again we do not draw past the edge of screen
				if ( current_ymax > VisibleArea_Height ) current_ymax = VisibleArea_Height;
			}
			
		}	// end if ( !GPU_CTRL_Read_DEN )
		
		
		
	}	// end if ( !local_id )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	barrier ();
	

	// *** new stuff *** //

	//FramePixel = 0;
	//ptr_pixelbuffer32 = PixelBuffer;
	iptr_pixelbuffer32 = 0;
	

	if ( GPU_CTRL_Read_DEN == 0 )
	{
		
		// current_y should start at zero for even field and one for odd
		current_y = 0;
		//current_y = group_yoffset + yid;
		
		
		// put in bottom border //
		
		
		// check if scanlines simulation is enabled
		if ( bEnableScanline != 0 )
		{
			// spread out workers on every other line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * ( group_yoffset + yid ) );
			
			// if this is an odd field, then start writing on the next line
			if ( ( Y_Pixel & 1 ) != 0 )
			{
				// odd field //
				
				iptr_pixelbuffer32 += VisibleArea_Width;
			}
		}
		

		while ( current_y < BottomBorder_Height )
		{
			//current_x = 0;
			current_x = xxid;
			
			while ( current_x < VisibleArea_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			}
			
			current_y++;
			//current_y += yinc;
			
			// added for opencl, update pixel buffer multiple lines
			//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			iptr_pixelbuffer32 += VisibleArea_Width;
			
			// check if scanline simulation is enabled
			if ( bEnableScanline != 0 )
			{
				// update again since doing every other line
				iptr_pixelbuffer32 += VisibleArea_Width;
				//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			}
		}
		
		
		// put in screen
		
		
		FramePixel_Y = ScreenArea_TopLeftY + Source_Height - 1;
		FramePixel_X = ScreenArea_TopLeftX;



		
		// for opencl, spread the workers across the lines
		//FramePixel_Y -= group_yoffset + yid;
		//FramePixel_Y -= ( current_y - BottomBorder_Height );
		
		// check if simulating scanlines
		if ( bEnableScanline != 0 )
		{
			// check if 480i
			if ( ( GPU_CTRL_Read_ISINTER != 0 ) && ( GPU_CTRL_Read_HEIGHT != 0 ) )
			{
				// 480i //
				
				// for opencl, spread interlace mode to every other line
				//FramePixel_Y -= ( current_y - BottomBorder_Height );
				
				// check if in odd field or even field
				if ( ( Y_Pixel & 1 ) != 0 )
				{
					// odd field //
					
					// if the height is even, then it is ok
					// if the height is odd, need to compensate
					if ( ( Source_Height & 1 ) == 0 )
					{
						FramePixel_Y--;
					}
				}
				else
				{
					// even field //
					
					// if the height is odd, then it is ok
					// if the height is even, need to compensate
					if ( ( Source_Height & 1 ) != 0 )
					{
						FramePixel_Y--;
					}
				}
				
			} // end if ( GPU_CTRL_Read.ISINTER && GPU_CTRL_Read.HEIGHT )
		}
		




	
		while ( current_y < current_ymax )
		{
			
			// put in the left border
			//current_x = 0;
			current_x = xxid;

			while ( current_x < LeftBorder_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			}
			

			// *** important note *** this wraps around the VRAM
			//ptr_vram16 = & (VRAM [ FramePixel_X + ( ( FramePixel_Y & c_lFrameBuffer_Height_Mask ) << 10 ) ]);
			iptr_vram16 = FramePixel_X + ( ( FramePixel_Y & c_lFrameBuffer_Height_Mask ) << 10 );
			

			// put in screeen pixels
			if ( GPU_CTRL_Read_ISRGB24 == 0 )
			{
				
				while ( current_x < current_xmax )
				{

					//Pixel16 = *ptr_vram16++;
					//Pixel16 = ptr_vram16 [ current_x - LeftBorder_Width ];
					Pixel16 = VRAM [ iptr_vram16 + current_x - LeftBorder_Width ];
					
					// the previous pixel conversion is wrong
					Pixel32_0 = ( ( Pixel16 & 0x1f ) << 3 ) | ( ( Pixel16 & 0x3e0 ) << 6 ) | ( ( Pixel16 & 0x7c00 ) << 9 );
					
					// *ptr_pixelbuffer32++ = Pixel32_0;
					//ptr_pixelbuffer32 [ current_x ] = Pixel32_0;
					pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = Pixel32_0;
					
					
					//current_x++;
					current_x += xxinc;
				}
				
			}
			else
			{
				current_x = LeftBorder_Width + ( xxid << 1 );
				current_x2 = ( xxid << 1 ) + xxid;
				while ( current_x < current_xmax )
				{
					
					//Pixel24.Pixel0 = *ptr_vram16++;
					//Pixel24.Pixel1 = *ptr_vram16++;
					//Pixel24.Pixel2 = *ptr_vram16++;
					//Pixel24.Pixel0 = ptr_vram16 [ ( ( ( current_x - LeftBorder_Width ) >> 1 ) * 3 ) + 0 ];
					//Pixel24.Pixel1 = ptr_vram16 [ ( ( ( current_x - LeftBorder_Width ) >> 1 ) * 3 ) + 1 ];
					//Pixel24.Pixel2 = ptr_vram16 [ ( ( ( current_x - LeftBorder_Width ) >> 1 ) * 3 ) + 2 ];
					pix0 = VRAM [ iptr_vram16 + current_x2 + 0 ];
					pix1 = VRAM [ iptr_vram16 + current_x2 + 1 ];
					pix2 = VRAM [ iptr_vram16 + current_x2 + 2 ];
					
					// draw first pixel
					//Pixel32_0 = ( ((u32)Pixel24.Red0) ) | ( ((u32)Pixel24.Green0) << 8 ) | ( ((u32)Pixel24.Blue0) << 16 );
					Pixel32_0 = ( pix0 & 0xffff ) | ( ( pix1 & 0xff ) << 16 );
					
					// draw second pixel
					//Pixel32_1 = ( ((u32)Pixel24.Red1) ) | ( ((u32)Pixel24.Green1) << 8 ) | ( ((u32)Pixel24.Blue1) << 16 );
					Pixel32_1 = ( ( pix2 & 0xffff ) << 8 ) | ( ( pix1 >> 8 ) & 0xff );
					
					// *ptr_pixelbuffer32++ = Pixel32_0;
					// *ptr_pixelbuffer32++ = Pixel32_1;
					//ptr_pixelbuffer32 [ current_x ] = Pixel32_0;
					//ptr_pixelbuffer32 [ current_x + 1 ] = Pixel32_1;
					pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = Pixel32_0;
					pixelbuffer32 [ iptr_pixelbuffer32 + current_x + 1 ] = Pixel32_1;
					
					//current_x += 2;
					current_x += ( xxinc << 1 );
					current_x2 += ( xxinc << 1 ) + xxinc;
					
				}
				current_x = LeftBorder_Width + ( Draw_Width << 1 ) + xxid;
				
				
			}
			
			
			// put in right border
			while ( current_x < VisibleArea_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			}
			
			
			current_y++;
			//current_y += yinc;
			
			// for opencl, update pixel buffer to next line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			iptr_pixelbuffer32 += VisibleArea_Width;
			
			if ( bEnableScanline != 0 )
			{
				// check if this is 480i
				if ( ( GPU_CTRL_Read_ISINTER != 0 ) && ( GPU_CTRL_Read_HEIGHT != 0 ) )
				{
					// 480i mode //
					
					// jump two lines in source image
					FramePixel_Y -= 2;
					//FramePixel_Y -= ( yinc << 1 );
				}
				else
				{
					// go to next line in frame buffer
					FramePixel_Y--;
					//FramePixel_Y -= yinc;
				}
				
				// also go to next line in destination buffer
				iptr_pixelbuffer32 += VisibleArea_Width;
				//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			}
			else
			{
				// go to next line in frame buffer
				FramePixel_Y--;
				//FramePixel_Y -= yinc;
			}
			
			
			
		} // end while ( current_y < current_ymax )
		

		// put in top border //
		
		
		while ( current_y < VisibleArea_Height )
		{
			//current_x = 0;
			current_x = xxid;
			
			while ( current_x < VisibleArea_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			} // end while ( current_x < VisibleArea_Width )
				
			current_y++;
			//current_y += yinc;
				
			// for opencl, update pixel buffer to next line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			iptr_pixelbuffer32 += VisibleArea_Width;
			
			// check if scanline simulation is enabled
			if ( bEnableScanline != 0 )
			{
				// also go to next line in destination buffer
				iptr_pixelbuffer32 += VisibleArea_Width;
				//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			}
			
		} // end while ( current_y < current_ymax )
		
	}
	else
	{
		// display disabled //
		
		
		current_y = 0;
		//current_y = group_yoffset + yid;
		
		// set initial row for pixel buffer pointer
		//ptr_pixelbuffer32 += ( VisibleArea_Width * current_y );
		
		if ( bEnableScanline != 0 )
		{
			// space out to every other line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * current_y );
			
			if ( ( Y_Pixel & 1 ) != 0 )
			{
				// odd field //
				
				iptr_pixelbuffer32 += VisibleArea_Width;
			}
		}
		
		while ( current_y < VisibleArea_Height )
		{
			//current_x = 0;
			current_x = xxid;
			
			while ( current_x < VisibleArea_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			}
			
			current_y++;
			//current_y += yinc;
			
			// for opencl, update pixel buffer to next line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			iptr_pixelbuffer32 += VisibleArea_Width;
			
			if ( bEnableScanline != 0 )
			{
				iptr_pixelbuffer32 += VisibleArea_Width;
				//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			}
			
		}
		

	}

	// check if simulating scanlines
	if ( bEnableScanline != 0 )
	{
		// the visible height is actually times 2 in the buffer for odd and even fields
		VisibleArea_Height <<= 1;
		
		// but, its actually times 2 and then minus one
		VisibleArea_Height--;
	}


	draw_texture ( VisibleArea_Width, VisibleArea_Height );

	// write back VisibleArea data
	//inputdata [ 8 ].Value = VisibleArea_Width;
	//inputdata [ 9 ].Value = VisibleArea_Height;

	//}	// end if ( !local_id )


	// this needs to be complete before proceeding
	barrier ();
}



void vDraw_FrameBufferRectangle_02 (uint iIdx)
{
	// goes at the top for opencl function

	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );
	


	
	int xoff, yoff;
	

	uint bgr16;
	uint bgr32;

	int w, h, xmax, ymax, ymax2;
	int x, y;

	int xinc2;

	uvec4 uvbgr16;

	//uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	//int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	//int DrawArea_OffsetX, DrawArea_OffsetY;
	//uint Command_ABE;

	//uint PixelMask, SetPixelMask;


	// set local variables
	//if ( (xid + yid) == 0 )
	//{
		iIdx <<= 4;

		// set bgr
		//bgr32 = inputdata [ 7 ].Value;
		bgr32 = inputdata [ iIdx + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		bgr16 |= ( bgr16 << 16 );
		
		
		//x = inputdata [ 8 ].x;
		//y = inputdata [ 8 ].y;
		x = int( inputdata [ iIdx + 8 ] );
		y = x >> 16;
		

		
		// x and y are actually 11 bits
		// doesn't matter for frame buffer
		//x = ( x << 21 ) >> 21;
		//y = ( y << 21 ) >> 21;
		
		//w = inputdata [ 9 ].w;
		//h = inputdata [ 9 ].h;
		w = int( inputdata [ iIdx + 9 ] );
		h = w >> 16;
		
		// Xpos=(Xpos AND 3F0h)
		x &= 0x3f0;
		
		// ypos & 0x1ff
		y &= 0x1ff;
		
		// Xsiz=((Xsiz AND 3FFh)+0Fh) AND (NOT 0Fh)
		w = ( ( w & 0x3ff ) + 0xf ) & ~0xf;
		
		// Ysiz=((Ysiz AND 1FFh))
		h &= 0x1ff;
	
		// adding xmax, ymax
		xmax = x + w;
		ymax = y + h;
		

		// make a color vector to store
		uvbgr16 = uvec4( bgr16 );

	//}
	

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	barrier ();

	
	// *** NOTE: coordinates wrap *** //
	
	
	
	// need to first make sure there is something to draw
	if ( h > 0 && w > 0 )
	{
		// don't use group_xinc because this only runs on one gpu core
		// can't run this on multiple gpu cores because runs on entire buffer
		for ( yoff = y + yid; yoff < ymax; yoff += yinc )
		{
			//for ( xoff = x + xid; xoff < xmax; xoff += xinc )
			for ( xoff = x + ( xid << 2 ); xoff < xmax; xoff += ( xinc << 2 ) )
			{
				//VRAM [ ( xoff & c_lFrameBuffer_Width_Mask ) + ( ( yoff & c_lFrameBuffer_Height_Mask ) << 10 ) ] = bgr16;
				VRAM4 [ ( ( xoff & c_lFrameBuffer_Width_Mask ) + ( ( yoff & c_lFrameBuffer_Height_Mask ) << 10 ) ) >> 2 ] = uvbgr16;
			}
		}
				
	}
	

	// need to complete command before proceeding
	barrier ();
	
	
}



void Draw_FrameBufferRectangle_02 (uint iIdx)
{
	// goes at the top for opencl function

	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );
	


	
	int xoff, yoff;
	

uint bgr16;
uint bgr32;

int w, h, xmax, ymax, ymax2;
int x, y;

int group_yoffset;

uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;

uint PixelMask, SetPixelMask;


	// set local variables
	//if ( (xid + yid) == 0 )
	//{
		iIdx <<= 4;

		// set bgr
		//bgr32 = inputdata [ 7 ].Value;
		bgr32 = inputdata [ iIdx + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );

		
		
		//x = inputdata [ 8 ].x;
		//y = inputdata [ 8 ].y;
		x = int( inputdata [ iIdx + 8 ] );
		y = x >> 16;
		

		
		// x and y are actually 11 bits
		// doesn't matter for frame buffer
		//x = ( x << 21 ) >> 21;
		//y = ( y << 21 ) >> 21;
		
		//w = inputdata [ 9 ].w;
		//h = inputdata [ 9 ].h;
		w = int( inputdata [ iIdx + 9 ] );
		h = w >> 16;
		
		// Xpos=(Xpos AND 3F0h)
		x &= 0x3f0;
		
		// ypos & 0x1ff
		y &= 0x1ff;
		
		// Xsiz=((Xsiz AND 3FFh)+0Fh) AND (NOT 0Fh)
		w = ( ( w & 0x3ff ) + 0xf ) & ~0xf;
		
		// Ysiz=((Ysiz AND 1FFh))
		h &= 0x1ff;
	
		// adding xmax, ymax
		xmax = x + w;
		ymax = y + h;
		
		//printf( "\ninputdata= %x %x %x %x", inputdata [ 0 ].Value, inputdata [ 1 ].Value, inputdata [ 2 ].Value, inputdata [ 3 ].Value );
		//printf( "\nvram= %x %x %x %x", VRAM [ 0 ], VRAM [ 1 ], VRAM [ 2 ], VRAM [ 3 ] );
		
		//ymax2 = 0;
		//if ( ymax > c_lFrameBuffer_Height )
		//{
		//	ymax2 = ymax - c_lFrameBuffer_Height;
		//	ymax = c_lFrameBuffer_Height;
		//}
		
		// offset to get to this compute unit's scanline
		group_yoffset = 0;
		
		
		//printf ( "local_id= %i num_global_groups= %i group_id= %i group_yoffset= %i yoff= %i", local_id, num_global_groups, group_id, group_yoffset, y + group_yoffset + ( yid * yinc ) );
		//printf ( "\nStartFrameRect x=%i y=%i w=%i h=%i bgr32= %x bgr16=%x", x, y, w, h, bgr32, bgr16 );
	//}
	

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	barrier ();

	
	// *** NOTE: coordinates wrap *** //
	
	
	
	// need to first make sure there is something to draw
	if ( h > 0 && w > 0 )
	{
		
		for ( yoff = y + group_yoffset + yid; yoff < ymax; yoff += yinc )
		{
			for ( xoff = x + xid; xoff < xmax; xoff += xinc )
			{
				VRAM [ ( xoff & c_lFrameBuffer_Width_Mask ) + ( ( yoff & c_lFrameBuffer_Height_Mask ) << 10 ) ] = bgr16;
			}
		}
		
		
		//for ( yoff = group_yoffset + yid; yoff < ymax2; yoff += yinc )
		//{
		//	for ( xoff = x + xid; xoff < xmax; xoff += xinc )
		//	{
		//		VRAM [ ( xoff & c_lFrameBuffer_Width_Mask ) + ( yoff << 10 ) ] = bgr16;
		//	}
		//}
		
	}
	
	
	// this needs to be complete before proceeding
	barrier ();
	
}


uint ColorMultiply1624 ( uint Color16, uint Color24 )
{
	const int c_iBitsPerPixel16 = 5;
	const int c_iRedShift16 = c_iBitsPerPixel16 * 2;
	const int c_iRedMask16 = ( 0x1f << c_iRedShift16 );
	const int c_iGreenShift16 = c_iBitsPerPixel16 * 1;
	const int c_iGreenMask16 = ( 0x1f << c_iGreenShift16 );
	const int c_iBlueShift16 = 0;
	const int c_iBlueMask16 = ( 0x1f << c_iBlueShift16 );

	const int c_iBitsPerPixel24 = 8;
	const int c_iRedShift24 = c_iBitsPerPixel24 * 2;
	const int c_iRedMask24 = ( 0xff << ( c_iBitsPerPixel24 * 2 ) );
	const int c_iGreenShift24 = c_iBitsPerPixel24 * 1;
	const int c_iGreenMask24 = ( 0xff << ( c_iBitsPerPixel24 * 1 ) );
	const int c_iBlueShift24 = 0;
	const int c_iBlueMask24 = ( 0xff << ( c_iBitsPerPixel24 * 0 ) );
	
	int Red, Green, Blue;
	
	// the multiply should put it in 16.23 fixed point, but need it back in 8.8
	//Red = int( ( Color16 & c_iRedMask16 ) * ( Color24 & c_iRedMask24 ) );
	Red = int( ( ( Color16 & c_iRedMask16 ) >> 5 ) * ( ( Color24 & c_iRedMask24 ) >> 8 ) );
	//Red |= ( ( Red << ( 32 - ( 16 + 23 ) ) ) >> 31 );
	Red |= ( ( Red << ( 32 - ( 16 + 10 ) ) ) >> 31 );
	
	// to get to original position, shift back ( 23 - 8 ) = 15, then shift right 7, for total of 7 + 15 = 22 shift right
	// top bit (38) needs to end up in bit 15, so that would actually shift right by 23
	//Red >>= 23;
	// bit 25 needs to be in bit 15
	Red >>= 10;
	
	// the multiply should put it in 16.10 fixed point, but need it back in 8.30
	Green = int( ( ( Color16 & c_iGreenMask16 ) ) * ( ( Color24 & c_iGreenMask24 ) ) );
	Green |= ( ( Green << ( 32 - ( 16 + 10 ) ) ) >> 31 );
	
	// top bit (25) needs to end up in bit (10)
	Green >>= 15;
	
	// the multiply should put it in 13.0 fixed point
	Blue = int( ( ( Color16 & c_iBlueMask16 ) ) * ( ( Color24 & c_iBlueMask24 ) ) );
	Blue |= ( ( Blue << ( 32 - ( 13 + 0 ) ) ) >> 31 );
	
	// top bit (12) needs to end up in bit 5
	Blue >>= 7;
	
	return uint( ( Red & c_iRedMask16 ) | ( Green & c_iGreenMask16 ) | ( Blue & c_iBlueMask16 ) );
	
}



uvec4 vColorMultiply1624 ( uvec4 Color16, uvec4 Color24 )
{
	const uint c_iBitsPerPixel16 = 5;
	const uint c_iRedShift16 = c_iBitsPerPixel16 * 2;
	const uvec4 c_iRedMask16 = uvec4( 0x1f << c_iRedShift16 );
	const uint c_iGreenShift16 = c_iBitsPerPixel16 * 1;
	const uvec4 c_iGreenMask16 = uvec4( 0x1f << c_iGreenShift16 );
	const uint c_iBlueShift16 = 0;
	const uvec4 c_iBlueMask16 = uvec4( 0x1f << c_iBlueShift16 );

	const uint c_iBitsPerPixel24 = 8;
	const uvec4 c_iRedShift24 = uvec4( c_iBitsPerPixel24 * 2 );
	const uvec4 c_iRedMask24 = uvec4( 0xff << ( c_iBitsPerPixel24 * 2 ) );
	const uint c_iGreenShift24 = c_iBitsPerPixel24 * 1;
	const uvec4 c_iGreenMask24 = uvec4( 0xff << ( c_iBitsPerPixel24 * 1 ) );
	const uint c_iBlueShift24 = 0;
	const uvec4 c_iBlueMask24 = uvec4( 0xff << ( c_iBitsPerPixel24 * 0 ) );
	
	ivec4 Red, Green, Blue;
	
	// the multiply should put it in 16.23 fixed point, but need it back in 8.8
	//Red = int( ( Color16 & c_iRedMask16 ) * ( Color24 & c_iRedMask24 ) );
	Red = ivec4( ( ( Color16 & c_iRedMask16 ) >> 5 ) * ( ( Color24 & c_iRedMask24 ) >> 8 ) );
	//Red |= ( ( Red << ( 32 - ( 16 + 23 ) ) ) >> 31 );
	Red |= ( ( Red << ( 32 - ( 16 + 10 ) ) ) >> 31 );
	
	// to get to original position, shift back ( 23 - 8 ) = 15, then shift right 7, for total of 7 + 15 = 22 shift right
	// top bit (38) needs to end up in bit 15, so that would actually shift right by 23
	//Red >>= 23;
	// bit 25 needs to be in bit 15
	Red >>= 10;
	
	// the multiply should put it in 16.10 fixed point, but need it back in 8.30
	Green = ivec4( ( ( Color16 & c_iGreenMask16 ) ) * ( ( Color24 & c_iGreenMask24 ) ) );
	Green |= ( ( Green << ( 32 - ( 16 + 10 ) ) ) >> 31 );
	
	// top bit (25) needs to end up in bit (10)
	Green >>= 15;
	
	// the multiply should put it in 13.0 fixed point
	Blue = ivec4( ( ( Color16 & c_iBlueMask16 ) ) * ( ( Color24 & c_iBlueMask24 ) ) );
	Blue |= ( ( Blue << ( 32 - ( 13 + 0 ) ) ) >> 31 );
	
	// top bit (12) needs to end up in bit 5
	Blue >>= 7;
	
	return uvec4( ( Red & c_iRedMask16 ) | ( Green & c_iGreenMask16 ) | ( Blue & c_iBlueMask16 ) );
	
}



uvec4 vSemiTransparency16 ( uvec4 B, uvec4 F, uint abrCode )
{
	
	const uint ShiftSame = 0;
	const uint ShiftHalf = 1;
	const uint ShiftQuarter = 2;
	
	const uint c_iBitsPerPixel = 5;
	const uvec4 c_iShiftHalf_Mask = uvec4( ~( ( 1 << ( c_iBitsPerPixel - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 2 ) - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 3 ) - 1 ) ) ) );
	const uvec4 c_iShiftQuarter_Mask = uvec4( ~( ( 3 << ( c_iBitsPerPixel - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 2 ) - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 3 ) - 2 ) ) ) );
	const uvec4 c_iClampMask = uvec4( ( 1 << ( c_iBitsPerPixel ) ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) + ( 1 << ( c_iBitsPerPixel * 3 ) ) );
	const uvec4 c_iLoBitMask = uvec4( ( 1 ) + ( 1 << c_iBitsPerPixel ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) );
	const uvec4 c_iPixelMask = uvec4( 0x7fff );
	
	//uint Red, Green, Blue;
	
	uvec4 Color, Actual, Mask;
	
	switch ( abrCode )
	{
		// 0.5xB+0.5 xF
		case 0:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftHalf ) + ( GetRed16( F ) >> ShiftHalf ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftHalf ) + ( GetGreen16( F ) >> ShiftHalf ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftHalf ) + ( GetBlue16( F ) >> ShiftHalf ) ) );
			
			Mask = B & F & c_iLoBitMask;
			Color = ( ( B >> 1 ) & c_iShiftHalf_Mask ) + ( ( F >> 1 ) & c_iShiftHalf_Mask ) + Mask;
			return Color;
			
			break;
		
		// 1.0xB+1.0 xF
		case 1:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
			
		// 1.0xB-1.0 xF
		case 2:
			//Color = SetRed16 ( Clamp5 ( (s32) ( GetRed16 ( B ) >> ShiftSame ) - (s32) ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( (s32) ( GetGreen16 ( B ) >> ShiftSame ) - (s32) ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( (s32) ( GetBlue16 ( B ) >> ShiftSame ) - (s32) ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B - F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual + Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color &= ~Mask;
			return Color;
			
			break;
			
		// 1.0xB+0.25xF
		case 3:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftQuarter ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftQuarter ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftQuarter ) ) );
			
			B &= c_iPixelMask;
			F = ( F >> 2 ) & c_iShiftQuarter_Mask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
	}
	
	return Color;
	
}



uint SemiTransparency16 ( uint B, uint F, uint abrCode )
{
	
	const uint ShiftSame = 0;
	const uint ShiftHalf = 1;
	const uint ShiftQuarter = 2;
	
	const uint c_iBitsPerPixel = 5;
	const uint c_iShiftHalf_Mask = ~( ( 1 << ( c_iBitsPerPixel - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 2 ) - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 3 ) - 1 ) ) );
	const uint c_iShiftQuarter_Mask = ~( ( 3 << ( c_iBitsPerPixel - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 2 ) - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 3 ) - 2 ) ) );
	const uint c_iClampMask = ( ( 1 << ( c_iBitsPerPixel ) ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) + ( 1 << ( c_iBitsPerPixel * 3 ) ) );
	const uint c_iLoBitMask = ( ( 1 ) + ( 1 << c_iBitsPerPixel ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) );
	const uint c_iPixelMask = 0x7fff;
	
	uint Red, Green, Blue;
	
	uint Color, Actual, Mask;
	
	switch ( abrCode )
	{
		// 0.5xB+0.5 xF
		case 0:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftHalf ) + ( GetRed16( F ) >> ShiftHalf ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftHalf ) + ( GetGreen16( F ) >> ShiftHalf ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftHalf ) + ( GetBlue16( F ) >> ShiftHalf ) ) );
			
			Mask = B & F & c_iLoBitMask;
			Color = ( ( B >> 1 ) & c_iShiftHalf_Mask ) + ( ( F >> 1 ) & c_iShiftHalf_Mask ) + Mask;
			return Color;
			
			break;
		
		// 1.0xB+1.0 xF
		case 1:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
			
		// 1.0xB-1.0 xF
		case 2:
			//Color = SetRed16 ( Clamp5 ( (s32) ( GetRed16 ( B ) >> ShiftSame ) - (s32) ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( (s32) ( GetGreen16 ( B ) >> ShiftSame ) - (s32) ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( (s32) ( GetBlue16 ( B ) >> ShiftSame ) - (s32) ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B - F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual + Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color &= ~Mask;
			return Color;
			
			break;
			
		// 1.0xB+0.25xF
		case 3:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftQuarter ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftQuarter ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftQuarter ) ) );
			
			B &= c_iPixelMask;
			F = ( F >> 2 ) & c_iShiftQuarter_Mask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
	}
	
	return Color;
	
}



void vDraw_Line ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	//s64 r10, r20, r21;
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;

	uint bgr32, bgr16;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;
	
	int w;
	ivec4 vLine;
	ivec4 vix;
	ivec4 vxid;
	ivec4 vyid;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	
	const ivec4 vZero = ivec4( 0 );

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	int iEndpointX, iEndpointY;

	// setup vars
	//if ( !local_id )
	//{
		
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		bgr32 = inputdata [ uIndex + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		

		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
		
		// get the endpoint, since it shouldn't be drawn
		iEndpointX = gx [ 1 ];
		iEndpointY = gy [ 1 ];

		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( ( RightMostX < DrawArea_TopLeftX ) || ( LeftMostX > DrawArea_BottomRightX ) || ( BottomMostY < DrawArea_TopLeftY ) || ( TopMostY > DrawArea_BottomRightY ) ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}

		uvbgr16 = uvec4( bgr16 );
		ivRedF = ivec4( uvbgr16 >> 0 ) & 0x1f;
		ivGreenF = ivec4( uvbgr16 >> 5 ) & 0x1f;
		ivBlueF = ivec4( uvbgr16 >> 10 ) & 0x1f;

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}

				
		
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;


	//barrier ();


	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
			////////////////////////////////////
			// get slopes
			
		iy = ( y0 << 16 ) + 0x8000;
		

		if ( line_length != 0 )
		{
			
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			dy <<= 8;

		}	// end if ( line_length )

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				
				iy += dy * Temp;
				StartX = DrawArea_TopLeftX;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				EndX = DrawArea_BottomRightX;
			}
		//}
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going up, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}	// end if ( dy <= 0 )
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}
		}	// end if ( dy >= 0 )
		
		
		// can optimize this some other time
		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;

		// align the compute units with pixels

		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
		xid = ( ( cxid << group_xshift ) + group_x );
		vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
		vxid = ( vxid ) - ( StartX & group_vxmask );

		vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


		w = EndX - StartX;

		// draw the line horizontally
		//for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		for ( vix = vxid; any( lessThanEqual( uvec4( vix ), uvec4( w ) ) ); vix += group_vxinc )
		{
			//Line = iy + (( ix - StartX ) * dy);
			//Line >>= 16;
			vLine = iy + (vix * dy);
			vLine >>= 16;
			
			//yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;
			vyid = ( ( ( cyid << group_yshift ) + group_y ) - vLine ) & group_ymask;

			//bvEnable = bvec4(ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )));
			bvEnable = bvec4( ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )) & ivec4(lessThanEqual( uvec4( vix ), uvec4( w ) )) & ivec4(notEqual(vix+StartX,ivec4(iEndpointX))) );

			//if ( yid == 0 )
			if ( any( bvEnable ) )
			{
				// need to know what line we are on
				vLine = mix( vZero, vLine, bvEnable );
				Line = vLine.x | vLine.y | vLine.z | vLine.w;

			//if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			//{
				// read pixel from frame buffer if we need to check mask bit
				//iPtr = ix + ( Line << 10 );
				//DestPixel = VRAM [ iPtr ];
				//ivPtr = (vix + StartX) + ( vLine << 10 );
				ivPtr = (vix + StartX) + ( Line << 10 );
				
#ifdef USE_VECTOR_LOADSTORE
				uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
				uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
				uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
				uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
				uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif
				
				//bgr_temp = bgr16;
	
				// semi-transparency
				//if ( Command_ABE != 0 )
				//{
				//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				//}
				
				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 31 );
				ivGreenB = clamp( ivGreenB, 0, 31 );
				ivBlueB = clamp( ivBlueB, 0, 31 );

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

				// check if we should set mask bit when drawing
				uvbgr_temp |= SetPixelMask;


				// draw pixel if we can draw to mask pixels or mask bit not set
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );

#ifdef USE_VECTOR_LOADSTORE
				VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
				VRAM [ ivPtr [ 0 ] ] = uvDestPixel [ 0 ];
				VRAM [ ivPtr [ 1 ] ] = uvDestPixel [ 1 ];
				VRAM [ ivPtr [ 2 ] ] = uvDestPixel [ 2 ];
				VRAM [ ivPtr [ 3 ] ] = uvDestPixel [ 3 ];
#endif

			//}	// end if ( Line >= DrawArea_TopLeftY && Line <= DrawArea_BottomRightY )

			}	// end if ( yid == 0 )
			
			//iy += dy;
			//iy += dy * xxinc;

		}	// end for ( ix = StartX; ix != EndX; ix += incdec )
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		if ( line_length != 0 )
		{
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			dx <<= 8;
		}
		
		//StartY = y0;
		//EndY = y1;
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				
				ix += dx * Temp;
				StartY = DrawArea_TopLeftY;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				//EndY = DrawArea_BottomRightY + 1;
				EndY = DrawArea_BottomRightY;
			}
		//}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

	
		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;



		w = EndY - StartY;

		// draw the line vertically
		//for ( viy = vyid; any( lessThan( uvec4( viy ), uvec4( w ) ) ); viy += group_yinc )
		for ( iy = yid; iy <= w; iy += group_yinc )
		{
			//Line = ix + (( iy - StartY ) * dx);
			//Line >>= 16;
			Line = ix + (iy * dx);
			Line >>= 16;
			
			// can optimize this some other time
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - Line ) & group_xmask;

			// align the compute units with pixels

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( Line & group_vxmask );

			//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


			//bvEnable = equal( vxid, vZero );
			//bvEnable = bvec4( ivec4(equal( vxid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftX) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightX) )) & ivec4(lessThanEqual( uvec4( iy ), uvec4( w ) )) & ivec4(notEqual(ivec4(iy+StartY),ivec4(iEndpointY))) );
			bvEnable = bvec4( ivec4(equal( vxid, vZero )) & ivec4( Line >= DrawArea_TopLeftX ) & ivec4( Line <= DrawArea_BottomRightX ) & ivec4( uint( iy ) <= uint( w ) ) & ivec4( (iy+StartY) != iEndpointY ) );


			//if ( xid == 0 )
			if ( any( bvEnable ) )
			{

			//if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			//{
				// read pixel from frame buffer if we need to check mask bit
				iPtr = Line + ( ( iy + StartY ) << 10 );
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}


				// check if we should set mask bit when drawing
				bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			//}	// end if ( Line >= DrawArea_TopLeftX && Line <= DrawArea_BottomRightX )

			}	// end if ( xid == 0 )
			
			//ix += dx;

		}	// end for ( iy = StartY; iy != EndY; iy += incdec )

	}	// end if else if ( x_distance > y_distance )


	//barrier ();


	return;
}



void Draw_Line ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7: GetBGR24 ( Buffer [ 0 ] );
//8: GetXY0 ( Buffer [ 1 ] );
//9: GetXY1 ( Buffer [ 2 ] );
//10: GetXY2 ( Buffer [ 3 ] );



	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	//s64 r10, r20, r21;
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;

	uint bgr32, bgr16;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;
	
	//u32 NumPixels;
	
//debug << "\nDrawTriangle_Mono_th";

	// setup vars
	//if ( !local_id )
	//{
		
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		bgr32 = inputdata [ uIndex + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		

		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
		
		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( ( RightMostX < DrawArea_TopLeftX ) || ( LeftMostX > DrawArea_BottomRightX ) || ( BottomMostY < DrawArea_TopLeftY ) || ( TopMostY > DrawArea_BottomRightY ) ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}
		
				
		
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;

	//barrier ();
	
	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
			////////////////////////////////////
			// get slopes
			
		iy = ( y0 << 16 ) + 0x8000;
		

		if ( line_length != 0 )
		{
			
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			dy <<= 8;

		}	// end if ( line_length )

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				
				iy += dy * Temp;
				StartX = DrawArea_TopLeftX;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				EndX = DrawArea_BottomRightX + 1;
			}
		//}
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going up, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}	// end if ( dy <= 0 )
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}
		}	// end if ( dy >= 0 )
		
		
		// can optimize this some other time
		xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
		
		// draw the line horizontally
		//for ( ix = StartX; ix != EndX; ix += incdec )
		for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		{
			Line = iy + (( ix - StartX ) * dy);
			Line >>= 16;
			
			yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;

			if ( yid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			{
				//ptr = & ( _GPU->VRAM [ ix + ( Line << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = ix + ( Line << 10 );
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			}	// end if ( Line >= DrawArea_TopLeftY && Line <= DrawArea_BottomRightY )

			}	// end if ( yid == 0 )
			
			//iy += dy;
			//iy += dy * xxinc;

		}	// end for ( ix = StartX; ix != EndX; ix += incdec )
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		if ( line_length != 0 )
		{
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			dx <<= 8;
		}
		
		//StartY = y0;
		//EndY = y1;
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				
				ix += dx * Temp;
				StartY = DrawArea_TopLeftY;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY + 1;
			}
		//}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

	
		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

		// draw the line vertically
		//for ( iy = StartY; iy != EndY; iy += incdec )
		for ( iy = StartY + yid; iy < EndY; iy += group_yinc )
		{
			Line = ix + (( iy - StartY ) * dx);
			Line >>= 16;
			
			// can optimize this some other time
			xid = ( ( ( cxid << group_xshift ) + group_x ) - Line ) & group_xmask;

			if ( xid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			{
				//ptr = & ( _GPU->VRAM [ Line + ( iy << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = Line + ( iy << 10 );
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			}	// end if ( Line >= DrawArea_TopLeftX && Line <= DrawArea_BottomRightX )

			}	// end if ( xid == 0 )
			
			//ix += dx;

		}	// end for ( iy = StartY; iy != EndY; iy += incdec )

	}	// end if else if ( x_distance > y_distance )
	

	return;
}



void vDraw_Line_Gradient ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;



	int w;
	ivec4 ivIndex;
	ivec4 ivDitherValue;
	ivec4 vLine;
	ivec4 ivR, ivG, ivB;
	ivec4 vix;
	ivec4 vxid;
	ivec4 vyid;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;


	const ivec4 vZero = ivec4( 0 );

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;
	

	int iR, iG, iB;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;
	int Red, Blue, Green;
	int dr, dg, db;
	int DitherValue;
	
	int oR, oG, oB;
	
	int iEndpointX, iEndpointY;

	// setup vars
	//if ( !local_id )
	//{
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		//bgr32 = inputdata [ uIndex + 7 ];
		//bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		

		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );

		// get the endpoint, since it shouldn't be drawn
		iEndpointX = gx [ 1 ];
		iEndpointY = gy [ 1 ];
		
		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( RightMostX < DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || BottomMostY < DrawArea_TopLeftY || TopMostY > DrawArea_BottomRightY ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}
		


		

		
		gbgr [ 0 ] = int( inputdata [ uIndex + 7 ] ) & 0x00ffffff;
		gbgr [ 1 ] = int( inputdata [ uIndex + 9 ] ) & 0x00ffffff;
		
		

		// get rgb-values
		r0 = gbgr [ Coord0 ] & 0xff;
		r1 = gbgr [ Coord1 ] & 0xff;

		g0 = ( gbgr [ Coord0 ] >> 8 ) & 0xff;
		g1 = ( gbgr [ Coord1 ] >> 8 ) & 0xff;

		b0 = ( gbgr [ Coord0 ] >> 16 ) & 0xff;
		b1 = ( gbgr [ Coord1 ] >> 16 ) & 0xff;


	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}

	
	iR = ( r0 << 16 ) + 0x8000;
	iG = ( g0 << 16 ) + 0x8000;
	iB = ( b0 << 16 ) + 0x8000;
	
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;


	//barrier ();


	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
		//ix = x0;
		iy = ( y0 << 16 ) + 0x8000;
		//x_right = x_left;
		
		
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			//dx = ( ( x1 - x0 ) << 16 ) / line_length;
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dy <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				StartX = DrawArea_TopLeftX;
				
				iy += dy * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				EndX = DrawArea_BottomRightX;
			}
		
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}

		}
		
		oR = iR;
		oG = iG;
		oB = iB;
				
		// can optimize this some other time
		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;

		// align the compute units with pixels

		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
		xid = ( ( cxid << group_xshift ) + group_x );
		vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
		vxid = ( vxid ) - ( StartX & group_vxmask );

		vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


		w = EndX - StartX;

		// draw the line horizontally
		//for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		for ( vix = vxid; any( lessThanEqual( uvec4( vix ), uvec4( w ) ) ); vix += group_vxinc )
		{

			//Line = iy + (( ix - StartX ) * dy);
			//Line >>= 16;
			vLine = iy + (vix * dy);
			vLine >>= 16;
			

			// can optimize this some other time
			//yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;
			vyid = ( ( ( cyid << group_yshift ) + group_y ) - vLine ) & group_ymask;

			bvEnable = bvec4( ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )) & ivec4(lessThanEqual( uvec4( vix ), uvec4( w ) )) & ivec4(notEqual(vix+StartX,ivec4(iEndpointX))) );


			//if ( yid == 0 )
			if ( any( bvEnable ) )
			{
				// need to know what line we are on
				vLine = mix( vZero, vLine, bvEnable );
				Line = vLine.x | vLine.y | vLine.z | vLine.w;

			//if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			//{
			ivR = oR + ( vix * dr );
			ivG = oG + ( vix * dg );
			ivB = oB + ( vix * db );

				
				//ivIndex = ( ( vix + StartX ) & 3 ) + ( ( vLine & 3 ) << 2 );
				ivIndex = ( ( vix + StartX ) & 3 ) + ( ( Line & 3 ) << 2 );
				ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );
				ivDitherValue[0] = c_iDitherValues16 [ ivIndex[0] ];
				ivDitherValue[1] = c_iDitherValues16 [ ivIndex[1] ];
				ivDitherValue[2] = c_iDitherValues16 [ ivIndex[2] ];
				ivDitherValue[3] = c_iDitherValues16 [ ivIndex[3] ];

				// perform dither
				ivRedF = ivR + ivDitherValue;
				ivGreenF = ivG + ivDitherValue;
				ivBlueF = ivB + ivDitherValue;
				
				// perform shift
				ivRedF >>= ( 16 + 3 );
				ivGreenF >>= ( 16 + 3 );
				ivBlueF >>= ( 16 + 3 );
				
				ivRedF = clamp ( ivRedF, 0, 31 );
				ivGreenF = clamp ( ivGreenF, 0, 31 );
				ivBlueF = clamp ( ivBlueF, 0, 31 );
				
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				//iPtr = ix + ( Line << 10 );
				//DestPixel = VRAM [ iPtr ];
				//ivPtr = (vix + StartX) + ( vLine << 10 );
				ivPtr = (vix + StartX) + ( Line << 10 );
				
#ifdef USE_VECTOR_LOADSTORE
				uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
				uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
				uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
				uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
				uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif
				
				//bgr_temp = bgr;
	
				// semi-transparency
				//if ( Command_ABE != 0 )
				//{
				//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				//}

				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 31 );
				ivGreenB = clamp( ivGreenB, 0, 31 );
				ivBlueB = clamp( ivBlueB, 0, 31 );

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
				// check if we should set mask bit when drawing
				uvbgr_temp |= SetPixelMask;


				// draw pixel if we can draw to mask pixels or mask bit not set
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				// testing
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, bvEnable );
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, bvEnable1 );
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, bvEnable2 );
				//uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable3 );

#ifdef USE_VECTOR_LOADSTORE
				VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
				//VRAM [ iPtr ] = DestPixel;
				VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
				VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
				VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
				VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif

			//}

			}	// end if ( yid == 0 )
			
			//iy += dy;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}
		
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		//if ( y1 - y0 )
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			//dy = ( ( y1 - y0 ) << 16 ) / line_length;,
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dx <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}
		
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
				
				ix += dx * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				//EndY = DrawArea_BottomRightY + 1;
				EndY = DrawArea_BottomRightY;
			}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

		oR = iR;
		oG = iG;
		oB = iB;

		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
	

		w = EndY - StartY;

		// draw the line vertically
		//for ( viy = vyid; any( lessThan( uvec4( viy ), uvec4( w ) ) ); viy += group_yinc )
		for ( iy = yid; iy <= w; iy += group_yinc )
		{
			//Line = ix + (( iy - StartY ) * dx);
			//Line >>= 16;
			Line = ix + (iy * dx);
			Line >>= 16;
			

			// align the compute units with pixels

			//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( Line & group_vxmask );

			//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

			//bvEnable = equal( vxid, vZero );
			//bvEnable = bvec4( ivec4(equal( vxid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftX) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightX) )) & ivec4(lessThanEqual( uvec4( iy ), uvec4( w ) )) & ivec4(notEqual(ivec4(iy+StartY),ivec4(iEndpointY))) );
			bvEnable = bvec4( ivec4(equal( vxid, vZero )) & ivec4( Line >= DrawArea_TopLeftX ) & ivec4( Line <= DrawArea_BottomRightX ) & ivec4( uint( iy ) <= uint( w ) ) & ivec4( (iy+StartY) != iEndpointY ) );


			//if ( xid == 0 )
			if ( any( bvEnable ) )
			{

			//if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			//{

			iR = oR + ( iy * dr);
			iG = oG + ( iy * dg);
			iB = oB + ( iy * db);

				if ( GPU_CTRL_Read_DTD != 0 )
				{
					//DitherValue = DitherLine [ x_across & 0x3 ];
					DitherValue = c_iDitherValues16 [ ( Line & 3 ) + ( ( iy & 3 ) << 2 ) ];
					
					// perform dither
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
				bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
				
				
				
				// read pixel from frame buffer if we need to check mask bit
				iPtr = Line + ( ( iy + StartY ) << 10 );
				DestPixel = VRAM [ iPtr ];
				//ivPtr = (vxid + Line) + ( vLine << 10 );
				
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}


				// check if we should set mask bit when drawing
				bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			//}

			}	// end if ( xid == 0 )
			
			//ix += dx;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}


	}
	
	
	//barrier ();


	return;
}



void Draw_Line_Gradient ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;




	
	
	

	int iR, iG, iB;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;
	int Red, Blue, Green;
	int dr, dg, db;
	int DitherValue;
	
	int oR, oG, oB;
	
//debug << "\nDrawTriangle_Mono_th";

	// setup vars
	//if ( !local_id )
	//{
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		//bgr32 = inputdata [ uIndex + 7 ];
		//bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		

		//gx [ 0 ] = int( ( inputdata [ 8 ].x << 5 ) >> 5 );
		//gy [ 0 ] = int( ( inputdata [ 8 ].y << 5 ) >> 5 );
		//gx [ 1 ] = int( ( inputdata [ 10 ].x << 5 ) >> 5 );
		//gy [ 1 ] = int( ( inputdata [ 10 ].y << 5 ) >> 5 );
		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
		
		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( RightMostX < DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || BottomMostY < DrawArea_TopLeftY || TopMostY > DrawArea_BottomRightY ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}
		


		

		
		gbgr [ 0 ] = int( inputdata [ uIndex + 7 ] ) & 0x00ffffff;
		gbgr [ 1 ] = int( inputdata [ uIndex + 9 ] ) & 0x00ffffff;
		
		

		// get rgb-values
		r0 = gbgr [ Coord0 ] & 0xff;
		r1 = gbgr [ Coord1 ] & 0xff;

		g0 = ( gbgr [ Coord0 ] >> 8 ) & 0xff;
		g1 = ( gbgr [ Coord1 ] >> 8 ) & 0xff;

		b0 = ( gbgr [ Coord0 ] >> 16 ) & 0xff;
		b1 = ( gbgr [ Coord1 ] >> 16 ) & 0xff;

		
	
	iR = ( r0 << 16 ) + 0x8000;
	iG = ( g0 << 16 ) + 0x8000;
	iB = ( b0 << 16 ) + 0x8000;
	
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;


	//barrier ();
	
	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
		//ix = x0;
		iy = ( y0 << 16 ) + 0x8000;
		//x_right = x_left;
		
		
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			//dx = ( ( x1 - x0 ) << 16 ) / line_length;
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dy <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				StartX = DrawArea_TopLeftX;
				
				iy += dy * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				EndX = DrawArea_BottomRightX + 1;
			}
		
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}

		}
		
		oR = iR;
		oG = iG;
		oB = iB;
				
		// can optimize this some other time
		xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;

		// draw the line horizontally
		//for ( ix = StartX; ix != EndX; ix += incdec )
		for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		{

			//Line = iy >> 16;
			Line = iy + (( ix - StartX ) * dy);
			Line >>= 16;
			
			iR = oR + (( ix - StartX ) * dr);
			iG = oG + (( ix - StartX ) * dg);
			iB = oB + (( ix - StartX ) * db);

			// can optimize this some other time
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - ix ) & group_xmask;
			yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;

			if ( yid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			{
				if ( GPU_CTRL_Read_DTD != 0 )
				{
					//bgr = ( _Round( iR ) >> 32 ) | ( ( _Round( iG ) >> 32 ) << 8 ) | ( ( _Round( iB ) >> 32 ) << 16 );
					//bgr = ( _Round( iR ) >> 35 ) | ( ( _Round( iG ) >> 35 ) << 5 ) | ( ( _Round( iB ) >> 35 ) << 10 );
					//DitherValue = DitherLine [ x_across & 0x3 ];
					DitherValue = c_iDitherValues16 [ ( ix & 3 ) + ( ( Line & 3 ) << 2 ) ];
					
					// perform dither
					//Red = iR + DitherValue;
					//Green = iG + DitherValue;
					//Blue = iB + DitherValue;
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					//Red = Clamp5 ( ( iR + DitherValue ) >> 27 );
					//Green = Clamp5 ( ( iG + DitherValue ) >> 27 );
					//Blue = Clamp5 ( ( iB + DitherValue ) >> 27 );
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
					
				bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
				
				
				//ptr = & ( _GPU->VRAM [ ix + ( Line << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = ix + ( Line << 10 );
				DestPixel = VRAM [ iPtr ];
				
				//bgr_temp = bgr;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
			}

			}	// end if ( yid == 0 )
			
			//iy += dy;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		//if ( y1 - y0 )
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			//dy = ( ( y1 - y0 ) << 16 ) / line_length;,
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dx <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}
		
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
				
				ix += dx * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY + 1;
			}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

		oR = iR;
		oG = iG;
		oB = iB;

		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
	
		// draw the line vertically
		//for ( iy = StartY; iy != EndY; iy += incdec )
		for ( iy = StartY + yid; iy < EndY; iy += group_yinc )
		{
			//Line = ix >> 16;
			Line = ix + (( iy - StartY ) * dx);
			Line >>= 16;

			iR = oR + (( iy - StartY ) * dr);
			iG = oG + (( iy - StartY ) * dg);
			iB = oB + (( iy - StartY ) * db);
			
			// can optimize this some other time
			xid = ( ( ( cxid << group_xshift ) + group_x ) - Line ) & group_xmask;
			//yid = ( ( ( cyid << group_yshift ) + group_y ) - iy ) & group_ymask;

			if ( xid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			{
				if ( GPU_CTRL_Read_DTD != 0 )
				{
					//bgr = ( _Round( iR ) >> 32 ) | ( ( _Round( iG ) >> 32 ) << 8 ) | ( ( _Round( iB ) >> 32 ) << 16 );
					//bgr = ( _Round( iR ) >> 35 ) | ( ( _Round( iG ) >> 35 ) << 5 ) | ( ( _Round( iB ) >> 35 ) << 10 );
					//DitherValue = DitherLine [ x_across & 0x3 ];
					DitherValue = c_iDitherValues16 [ ( Line & 3 ) + ( ( iy & 3 ) << 2 ) ];
					
					// perform dither
					//Red = iR + DitherValue;
					//Green = iG + DitherValue;
					//Blue = iB + DitherValue;
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					//Red = Clamp5 ( ( iR + DitherValue ) >> 27 );
					//Green = Clamp5 ( ( iG + DitherValue ) >> 27 );
					//Blue = Clamp5 ( ( iB + DitherValue ) >> 27 );
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
					
				bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
				
				
				//ptr = & ( _GPU->VRAM [ Line + ( iy << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = Line + ( iy << 10 );
				DestPixel = VRAM [ iPtr ];
				
				//bgr_temp = bgr;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
			}

			}	// end if ( xid == 0 )
			
			//ix += dx;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}


	}
	
	
	return;
}







#ifdef ENABLE_PRIMITIVE_LOOP
uint Draw_Pixel_68 ( uint uIndex )
#else
void Draw_Pixel_68 ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;

	

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7:GetBGR24 ( Buffer [ 0 ] );
//8:GetXY ( Buffer [ 1 ] );


	
	
	uint DestPixel;

	int iPtr;

uint bgr16;
uint bgr32;

int w, h, xmax, ymax, ymax2;
int x, y;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;

uint PixelMask, SetPixelMask;

	ivec4 vxid;
	const ivec4 vZero = ivec4(0);

	uint Comm;
	int bDraw;

	uint uIdx;

	uIndex <<= 4;

	//do
	//{

	// set local variables
	//if ( (xid + yid) == 0 )
	//{

		/*
		// set bgr64
		bgr32 = inputdata [ uIndex + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		x = int( inputdata [ uIndex + 8 ] );
		y = x >> 16;
		
		
		// x and y are actually 11 bits
		x = ( x << ( 5 + 16 ) ) >> ( 5 + 16 );
		y = ( y << ( 5 + 16 ) ) >> ( 5 + 16 );
		
		
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		
		
		// get top left corner of sprite and bottom right corner of sprite
		x += DrawArea_OffsetX;
		y += DrawArea_OffsetY;

		
		// ME is bit 12
		//if ( GPU_CTRL_Read.ME ) PixelMask = 0x8000;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		//if ( GPU_CTRL_Read.MD ) SetPixelMask = 0x8000;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;


		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;

		bDraw = 1;
		
	//}

	//barrier();

	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	
	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	if ( x < DrawArea_TopLeftX || y < DrawArea_TopLeftY || x > DrawArea_BottomRightX || y > DrawArea_BottomRightY )
	{
		//return;
		bDraw = 0;
	}
	*/
	
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );
		//StartX = data [ uIdx + 8 ];
		//EndX = data [ uIdx + 9 ];
		//StartY = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		x = data [ uIdx + 25 ];
		y = data [ uIdx + 26 ];
	
	// align the compute units with pixels
	//xid = ( ( ( cxid << group_xshift ) + group_x ) - x ) & group_xmask;
	yid = ( ( ( cyid << group_yshift ) + group_y ) - y ) & group_ymask;

	//yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( x & group_vxmask );

	//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

	//if ( xid + yid == 0 )
	if ( any( equal( vxid, vZero ) ) )
	{
		/////////////////////////////////////////
		// Draw the pixel

		// make sure we are putting pixel within draw area
		//if ( x >= DrawArea_TopLeftX && y >= DrawArea_TopLeftY && x <= DrawArea_BottomRightX && y <= DrawArea_BottomRightY )
		//{
			//ptr16 = & ( VRAM [ x + ( y << 10 ) ] );
			iPtr = x + ( y << 10 );
			
			// read pixel from frame buffer if we need to check mask bit
			DestPixel = VRAM [ iPtr ];
			
			// semi-transparency
			if ( Command_ABE != 0 )
			{
				bgr16 = SemiTransparency16 ( DestPixel, bgr16, GPU_CTRL_Read_ABR );
			}
			
			// check if we should set mask bit when drawing
			bgr16 |= SetPixelMask;

			// draw pixel if we can draw to mask pixels or mask bit not set
			DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr16 : DestPixel;
			VRAM [ iPtr ] = DestPixel;
		//}
	}	// end if ( xid + yid == 0 )

	}	// end if ( bDraw == 1 )
	
		//uIndex += 16;
		//Comm = inputdata [ uIndex + 7 ] >> 24;
	//} while ( ( Comm >= 0x68 && Comm <= 0x6b ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );

#ifdef ENABLE_PRIMITIVE_LOOP
	return uIndex;
#else
	return;
#endif
}



#ifdef ENABLE_PRIMITIVE_LOOP
uint vDraw_Rectangle_60 ( uint uIndex )
#else
void vDraw_Rectangle_60 ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	

	int iPtr;
	
	
	
	uint DestPixel;
	uint bgr_temp;
	int x_across;
	int Line;

	uint bgr16;
	int x, y, w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	int x0;
	int y0;
	int x1;
	int y1;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	uint Comm;
	int bDraw;

	uint uIdx;

		uIndex <<= 4;

	
#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		uvbgr16 = uvec4( uint( data [ uIdx + 7 ] ) );
		StartX = data [ uIdx + 8 ];
		EndX = data [ uIdx + 9 ];
		StartY = data [ uIdx + 10 ];
		EndY = data [ uIdx + 11 ];
		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//u0 = data [ uIdx + 16 ];
		//v0 = data [ uIdx + 17 ];
		//TWYTWH = data [ uIdx + 18 ];
		//TWXTWW = data [ uIdx + 19 ];
		//Not_TWH = data [ uIdx + 20 ];
		//Not_TWW = data [ uIdx + 21 ];
		//TextureOffset = data [ uIdx + 22 ];
		//ClutOffset = data [ uIdx + 23 ];
		//clut_xoffset = data [ uIdx + 24 ];


		ivRedF = ivec4( uvbgr16 >> 0 ) & 0x1f;
		ivGreenF = ivec4( uvbgr16 >> 5 ) & 0x1f;
		ivBlueF = ivec4( uvbgr16 >> 10 ) & 0x1f;

		uvbgr_temp = uvec4( bgr16 );
		uvbgr_temp |= SetPixelMask;

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


	// align the compute units with pixels

	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( StartX & group_vxmask );

	vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


	w = EndX - StartX + 1;



	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		//iPtr = ( StartX & ~3 ) + (xid << 2) + ( Line << 10 );
		ivPtr = ( StartX + vxid ) + ( Line << 10 );

#ifdef USE_NATIVE_PIXELS
		// 2 pixels per 32-bit word
		ivPtr >>= 1;
#endif
		
		// draw horizontal line
		for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
		{
			// check what pixels are enabled
			bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

			// read pixel from frame buffer if we need to check mask bit
			//DestPixel = *ptr;
#ifdef USE_VECTOR_LOADSTORE
			uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
			uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
#endif


#ifdef USE_NATIVE_PIXELS
			uvDestPixel = uvDest;
			uvDestPixel.yw >>= 16;
			uvDestPixel &= 0xffff;
#endif
			
			//bgr_temp = bgr16;
			//vbgr_temp = uvbgr16;

			// semi-transparency //

#ifdef USE_MORE_JUMPS
			if ( Command_ABE != 0 )
#endif
			{
			// semi-transparency
			//if ( Command_ABE != 0 )
			//{
			//	//bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
			//	vbgr_temp = vSemiTransparency16 ( vDestPixel, vbgr_temp, GPU_CTRL_Read_ABR );
			//}

			//ivRedF = ( vbgr16 >> 0 ) & 0x1f;
			//ivBlueF = ( vbgr16 >> 5 ) & 0x1f;
			//ivGreenF = ( vbgr16 >> 10 ) & 0x1f;

			ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
			ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
			ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

			//ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
			//ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
			//ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );
			ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
			ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
			ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

			ivRedB = clamp( ivRedB, 0, 31 );
			ivGreenB = clamp( ivGreenB, 0, 31 );
			ivBlueB = clamp( ivBlueB, 0, 31 );

			uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

			// just set bshift to 16/31 and fsign to if alpha not enabled
			//uvbgr_temp = ( Command_ABE != 0 ) ? uvbgr_temp : uvbgr16;

			
			// check if we should set mask bit when drawing
			//bgr_temp |= SetPixelMask;
			uvbgr_temp |= SetPixelMask;

			}

			// draw pixel if we can draw to mask pixels or mask bit not set
			//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
			uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

			// only enabled pixels should be active
			uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


#ifdef USE_NATIVE_PIXELS
			// mask vram //
			uvDest [ 0 ] &= 0x0000ffff;
			uvDest [ 1 ] &= 0xffff0000;
			uvDest [ 2 ] &= 0x0000ffff;
			uvDest [ 3 ] &= 0xffff0000;

			uvDestPixel.yw <<= 16;
			uvDest |= uvDestPixel;
#endif
			
			// store pixels //
#ifdef USE_VECTOR_LOADSTORE
			VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
			//VRAM [ iPtr ] = DestPixel;
			VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
			VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
			VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
			VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif

			// update pointer for pixel out
			//iPtr += xinc;
			ivPtr += group_vxinc;
		}
		
	}	// end for ( Line = StartY + group_yoffset + yid; Line <= EndY; Line += yinc )

	}	// end if ( bDraw == 1 )

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x60 && Comm <= 0x63 ) || ( Comm >= 0x70 && Comm <= 0x73 ) || ( Comm >= 0x78 && Comm <= 0x7b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	//barrier ();

#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}



uint Draw_Rectangle_60 ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	

	int iPtr;
	
	

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_BottomRightX
//2: DrawArea_TopLeftX
//3: DrawArea_BottomRightY
//4: DrawArea_TopLeftY
//5: DrawArea_OffsetX
//6: DrawArea_OffsetY
//7: GetBGR24 ( Buffer [ 0 ] );
//8: GetXY ( Buffer [ 1 ] );
//9: GetHW ( Buffer [ 2 ] );

	
	
	
	uint DestPixel;
	uint bgr_temp;
	int x_across;
	int Line;

	uint bgr16;
	int x, y, w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	int x0;
	int y0;
	int x1;
	int y1;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	uint Comm;
	int bDraw;

	uint uIdx;

		uIndex <<= 4;

	
	do
	{
		/*
		bgr16 = inputdata [ uIndex + 7 ];
		bgr16 = ( ( bgr16 >> 9 ) & 0x7c00 ) | ( ( bgr16 >> 6 ) & 0x3e0 ) | ( ( bgr16 >> 3 ) & 0x1f );
		
		x = int( inputdata [ uIndex + 8 ] );
		y = x >> 16;
		
		
		// x and y are actually 11 bits
		x = ( x << ( 5 + 16 ) ) >> ( 5 + 16 );
		y = ( y << ( 5 + 16 ) ) >> ( 5 + 16 );
		
		w = int( inputdata [ uIndex + 10 ] );
		h = w >> 16;

		w &= 0xffff;
		h &= 0xffff;
		
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		
		// get top left corner of sprite and bottom right corner of sprite
		x0 = x + DrawArea_OffsetX;
		y0 = y + DrawArea_OffsetY;
		x1 = x0 + w - 1;
		y1 = y0 + h - 1;
		
		
		
		StartX = x0;
		EndX = x1;
		StartY = y0;
		EndY = y1;


		if ( StartY < DrawArea_TopLeftY )
		{
			StartY = DrawArea_TopLeftY;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY;
		}
		
		if ( StartX < DrawArea_TopLeftX )
		{
			StartX = DrawArea_TopLeftX;
		}
		
		if ( EndX > DrawArea_BottomRightX )
		{
			EndX = DrawArea_BottomRightX;
		}

		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;

		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		bDraw = 1;


		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			//return;
			bDraw = 0;
		}
		

		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			//return;
			bDraw = 0;
		}

		// check if sprite is within draw area
		if ( x1 < DrawArea_TopLeftX || x0 > DrawArea_BottomRightX || y1 < DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0; //return;
		*/

		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );
		StartX = data [ uIdx + 8 ];
		EndX = data [ uIdx + 9 ];
		StartY = data [ uIdx + 10 ];
		EndY = data [ uIdx + 11 ];
		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//u0 = data [ uIdx + 16 ];
		//v0 = data [ uIdx + 17 ];
		//TWYTWH = data [ uIdx + 18 ];
		//TWXTWW = data [ uIdx + 19 ];
		//Not_TWH = data [ uIdx + 20 ];
		//Not_TWW = data [ uIdx + 21 ];
		//TextureOffset = data [ uIdx + 22 ];
		//ClutOffset = data [ uIdx + 23 ];
		//clut_xoffset = data [ uIdx + 24 ];



	if ( bDraw == 1 )
	{

	// align the compute units with pixels
	xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	

	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
		iPtr = StartX + xid + ( Line << 10 );

		
		// draw horizontal line
		for ( x_across = StartX + xid; x_across <= EndX; x_across += group_xinc )
		{
			// read pixel from frame buffer if we need to check mask bit
			//DestPixel = *ptr;
			DestPixel = VRAM [ iPtr ];
			
			bgr_temp = bgr16;

			// semi-transparency
			if ( Command_ABE != 0 )
			{
				bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
			}
			
			// check if we should set mask bit when drawing
			bgr_temp |= SetPixelMask;

			// draw pixel if we can draw to mask pixels or mask bit not set
			DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
			// *ptr = DestPixel;
			VRAM [ iPtr ] = DestPixel;
			
			// update pointer for pixel out
			//ptr += xinc;
			iPtr += xinc;
		}
		
	}	// end for ( Line = StartY + group_yoffset + yid; Line <= EndY; Line += yinc )

	}	// end if ( bDraw == 1 )

		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x60 && Comm <= 0x63 ) || ( Comm >= 0x70 && Comm <= 0x73 ) || ( Comm >= 0x78 && Comm <= 0x7b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );


	//return;
	return ( uIndex >> 4 ) - 1;
	
}



#ifdef ENABLE_PRIMITIVE_LOOP
uint vDraw_Sprite_64 ( uint uIndex )
#else
void vDraw_Sprite_64 ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	int iPtr;


	// notes: looks like sprite size is same as specified by w/h

	
	int TexelIndex;
	
	
	
	int Temp;
	
	// new local variables
	uint bgr, bgr_temp;
	int iU, iV;
	int x_across;
	int Line;
	
	uint DestPixel;
	int TexCoordX, TexCoordY;

	
	uint bgr16;
	int x, y, w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	int x0;
	int y0;
	int x1;
	int y1;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	int u;
	int v;
	
	// bits 0-5 in upper halfword
	int clut_x;
	int clut_y;

	int TWY;
	int TWX;
	int TWH;
	int TWW;
		
	int tpage_tx;
	int tpage_ty;
	int tpage_tp;
	int Shift1;
	int Shift2;
	int And1;
	int And2;
	int TWYTWH;
	int TWXTWW;
	int Not_TWH;
	int Not_TWW;
	int TextureOffset;
	int ClutOffset;
	int clut_xoffset;

	int u0, v0;
	uint color_add;
	uint Command_TGE;


	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 vEndX;

	const ivec4 vZero = ivec4( 0 );

	uvec4 uvbgr, uvbgr2;
	uvec4 uvDest;

	ivec4 ivTexCoordX;
	ivec4 ivU;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivIndex;
	
	uint Comm;
	int bDraw;

	uint uIdx;


	// set local variables
	//if ( xxid == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		color_add = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		StartX = data [ uIdx + 8 ];
		EndX = data [ uIdx + 9 ];
		StartY = data [ uIdx + 10 ];
		EndY = data [ uIdx + 11 ];
		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];
		u0 = data [ uIdx + 16 ];
		v0 = data [ uIdx + 17 ];
		TWYTWH = data [ uIdx + 18 ];
		TWXTWW = data [ uIdx + 19 ];
		Not_TWH = data [ uIdx + 20 ];
		Not_TWW = data [ uIdx + 21 ];
		TextureOffset = data [ uIdx + 22 ];
		ClutOffset = data [ uIdx + 23 ];
		clut_xoffset = data [ uIdx + 24 ];


	

	if ( Command_TGE != 0 )
	{
		color_add = 0x00808080;
	}





	// setup color_add value
	//ivRedC = ivec4( uvcolor_add >> 16 ) & 0xff;
	//ivGreenC = ivec4( uvcolor_add >> 8 ) & 0xff;
	//ivBlueC = ivec4( uvcolor_add >> 0 ) & 0xff;
	ivRedC = ivec4( ( int( color_add ) >> 0 ) & 0xff );
	ivGreenC = ivec4( ( int( color_add ) >> 8 ) & 0xff );
	ivBlueC = ivec4( ( int( color_add ) >> 16 ) & 0xff );

	//ivRedF = ivec4( uvbgr16 >> 10 ) & 0x1f;
	//ivGreenF = ivec4( uvbgr16 >> 5 ) & 0x1f;
	//ivBlueF = ivec4( uvbgr16 >> 0 ) & 0x1f;

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( StartX & group_vxmask );

	vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


	//iV = v0;
	iV = v0 + yid;


	w = EndX - StartX + 1;


	//barrier ();

	//for ( Line = StartY; Line <= EndY; Line++ )
	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		
			// need to start texture coord from left again
			//iU = u0;
			//iU = u0 + xid;
			ivU = u0 + vxid;

			TexCoordY = ( ( iV & Not_TWH ) | ( TWYTWH ) ) & 0xff;
			TexCoordY <<= 10;

			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = StartX + xid + ( Line << 10 );
			ivPtr = ( StartX + vxid ) + ( Line << 10 );

#ifdef USE_NATIVE_PIXELS
			// 2 pixels per 32-bit word
			//ivPtr >>= 1;
#endif


			// draw horizontal line
			//for ( x_across = StartX + xid; x_across <= EndX; x_across += group_xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );



				//TexCoordX = ( ( iU & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				ivTexCoordX = ( ( ivU & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				// x-component should be shifted right 1 again since 2 pixels per?
				//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + TexCoordY;
				uvbgr[ 0 ] = VRAM [ ivIndex [ 0 ] ];
				uvbgr[ 1 ] = VRAM [ ivIndex [ 1 ] ];
				uvbgr[ 2 ] = VRAM [ ivIndex [ 2 ] ];
				uvbgr[ 3 ] = VRAM [ ivIndex [ 3 ] ];
				
				
				//if ( Shift1 != 0 )
				//{
				//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( int( bgr ) >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				//}
				ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );
				uvbgr2[0] = VRAM [ ivIndex [ 0 ] ];
				uvbgr2[1] = VRAM [ ivIndex [ 1 ] ];
				uvbgr2[2] = VRAM [ ivIndex [ 2 ] ];
				uvbgr2[3] = VRAM [ ivIndex [ 3 ] ];

				uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;
				
				//if ( bgr != 0 )
				//{
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					//uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
					//uvDestPixel = uvec4( VRAM [ ivPtr [ 3 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 0 ] ] );
					uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
					uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
					uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
					uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif

#ifdef USE_NATIVE_PIXELS
					uvDestPixel = uvDest;
					uvDestPixel.yw >>= 16;
					uvDestPixel &= 0xffff;
#endif

					
					//bgr_temp = bgr;
					
//#ifdef ENABLE_COLOR_MULTIPLY
					// color multiply //

					//if ( Command_TGE == 0 )
					//{
					//	// brightness calculation
					//	bgr_temp = ColorMultiply1624 ( bgr_temp, color_add );
					//}

					//ivRedC = ivec4( uvcolor_add >> 16 ) & 0xff;
					//ivGreenC = ivec4( uvcolor_add >> 8 ) & 0xff;
					//ivBlueC = ivec4( uvcolor_add >> 0 ) & 0xff;

					ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
					ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
					ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;

#ifdef USE_MORE_JUMPS
					if ( Command_TGE == 0 )
#endif
					{
					ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
					ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
					ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );
					
					//uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

					// no need for selection, because can color multiply with 0x80
					//uvbgr_temp = ( Command_TGE == 0 ) ? uvbgr_temp : uvbgr;
					}
//#endif


//#ifdef ENABLE_SEMI_TRANSPARENCY
					// semi-transparency //

#ifdef USE_MORE_JUMPS
					if ( Command_ABE != 0 )
#endif
					{
					// semi-transparency
					//if ( Command_ABE != 0 && ( bgr & 0x8000 ) != 0 )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					//}+
					
					//ivRedF = ivec4( uvbgr_temp >> 0 ) & 0x1f;
					//ivBlueF = ivec4( uvbgr_temp >> 5 ) & 0x1f;
					//ivGreenF = ivec4( uvbgr_temp >> 10 ) & 0x1f;

					ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 0x1f );
					ivGreenF = clamp( ivGreenB, 0, 0x1f );
					ivBlueF = clamp( ivBlueB, 0, 0x1f );
					}

					uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

					// no need to select based on command_abe since can just set shift to 16 and sign to zero
					uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
//#endif
					
					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
					uvbgr_temp |= SetPixelMask | ( uvbgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;

					// only draw pixel if not key color (zero)
					uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );
					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


#ifdef USE_NATIVE_PIXELS
					// mask vram //
					uvDest [ 0 ] &= 0x0000ffff;
					uvDest [ 1 ] &= 0xffff0000;
					uvDest [ 2 ] &= 0x0000ffff;
					uvDest [ 3 ] &= 0xffff0000;
					uvDestPixel.yw <<= 16;
					uvDest |= uvDestPixel;
#endif

					
					// store pixels //
#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif
				//}
				
					
				/////////////////////////////////////////////////////////
				// interpolate texture coords across
				//iU += xinc;
				//iU += group_xinc;
				ivU += group_vxinc;
				
				// update pointer for pixel out
				//iPtr += group_xinc;
				ivPtr += group_vxinc;
					
			}
		
		iV += group_yinc;
		
	}

	}	// end if ( bDraw == 1 )
	
#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x64 && Comm <= 0x67 ) || ( Comm >= 0x74 && Comm <= 0x77 ) || ( Comm >= 0x7c && Comm <= 0x7f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	//barrier ();

#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}





uint Draw_Sprite_64 ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	int iPtr;


//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_BottomRightX
//2: DrawArea_TopLeftX
//3: DrawArea_BottomRightY
//4: DrawArea_TopLeftY
//5: DrawArea_OffsetX
//6: DrawArea_OffsetY
//7: TextureWindow
//8: GetBGR24 ( Buffer [ 0 ] );
//9: GetXY ( Buffer [ 1 ] );
//10: GetCLUT ( Buffer [ 2 ] );
//10: GetUV ( Buffer [ 2 ] );
//11: GetHW ( Buffer [ 3 ] );


	// notes: looks like sprite size is same as specified by w/h

	
	int TexelIndex;
	
	
	
	int Temp;
	
	// new local variables
	uint bgr, bgr_temp;
	int iU, iV;
	int x_across;
	int Line;
	
	uint DestPixel;
	int TexCoordX, TexCoordY;

	
	uint bgr16;
	int x, y, w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	int x0;
	int y0;
	int x1;
	int y1;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	int u;
	int v;
	
	// bits 0-5 in upper halfword
	int clut_x;
	int clut_y;

	int TWY;
	int TWX;
	int TWH;
	int TWW;
		
	int tpage_tx;
	int tpage_ty;
	int tpage_tp;
	int Shift1;
	int Shift2;
	int And1;
	int And2;
	int TWYTWH;
	int TWXTWW;
	int Not_TWH;
	int Not_TWW;
	int TextureOffset;
	int ClutOffset;
	int clut_xoffset;

	int u0, v0;
	uint color_add;
	uint Command_TGE;
	
	uint Comm;
	int bDraw;

	uint uIdx;


	//barrier();

	// set local variables
	//if ( xxid == 0 )
	//{
		uIndex <<= 4;

	do
	{
		/*
		// set bgr64
		color_add = inputdata [ uIndex + 7 ] & 0x00ffffff;


		
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		Command_TGE = ( inputdata [ uIndex + 7 ] >> 24 ) & 1;


		if ( ( color_add & 0x00ffffff ) == 0x00808080 ) Command_TGE = 1;

		
		x = int( inputdata [ uIndex + 8 ] );
		y = x >> 16;
		
		// x and y are actually 11 bits
		x = ( x << ( 5 + 16 ) ) >> ( 5 + 16 );
		y = ( y << ( 5 + 16 ) ) >> ( 5 + 16 );
		
		w = int ( inputdata [ uIndex + 10 ] );
		h = w >> 16;

		// get rid of any junk data
		w &= 0x3ff;
		h &= 0x1ff;

		u = int ( inputdata [ uIndex + 9 ] );
		v = u >> 8;

		// get rid of any junk data
		u &= 0xff;
		v &= 0xff;
		
		// bits 0-5 in upper halfword
		clut_x = int ( inputdata [ uIndex + 9 ] >> ( 16 + 0 ) ) & 0x3f;
		clut_y = int ( inputdata [ uIndex + 9 ] >> ( 16 + 6 ) ) & 0x1ff;
	
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;
				
		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;


		TWY = int ( inputdata [ uIndex + 4 ] >> 15 ) & 0x1f;
		TWX = int ( inputdata [ uIndex + 4 ] >> 10 ) & 0x1f;
		TWH = int ( inputdata [ uIndex + 4 ] >> 5 ) & 0x1f;
		TWW = int ( inputdata [ uIndex + 4 ] ) & 0x1f;
		
		// bits 0-3
		tpage_tx = int( GPU_CTRL_Read ) & 0xf;
		
		// bit 4
		tpage_ty = int( GPU_CTRL_Read >> 4 ) & 1;
		
		
		// bits 5-6
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		
		// bits 7-8
		tpage_tp = int( GPU_CTRL_Read >> 7 ) & 3;
		
		
		Shift1 = 0;
		Shift2 = 0;
		And1 = 0;
		And2 = 0;


		TWYTWH = ( ( TWY & TWH ) << 3 );
		TWXTWW = ( ( TWX & TWW ) << 3 );
		
		
		Not_TWH = ~( TWH << 3 );
		Not_TWW = ~( TWW << 3 );

		
		
		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		ClutOffset = clut_y << 10;

		
		//////////////////////////////////////////////////////
		// Get offset into color lookup table
		
		clut_xoffset = clut_x << 4;
		
		if ( tpage_tp == 0 )
		{
			And2 = 0xf;
			
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			And2 = 0xff;
			
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}
		
		
		
		
		
		// get top left corner of sprite and bottom right corner of sprite
		x0 = x + DrawArea_OffsetX;
		y0 = y + DrawArea_OffsetY;
		x1 = x0 + w - 1;
		y1 = y0 + h - 1;

		
		// get texture coords
		u0 = u;
		v0 = v;
		
		
		StartX = x0;
		EndX = x1;
		StartY = y0;
		EndY = y1;

		if ( StartY < DrawArea_TopLeftY )
		{
			v0 += ( DrawArea_TopLeftY - StartY );
			StartY = DrawArea_TopLeftY;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY;
		}
		
		if ( StartX < DrawArea_TopLeftX )
		{
			u0 += ( DrawArea_TopLeftX - StartX );
			StartX = DrawArea_TopLeftX;
		}
		
		if ( EndX > DrawArea_BottomRightX )
		{
			EndX = DrawArea_BottomRightX;
		}

		
		bDraw = 1;
		
	//}

	
	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	// initialize number of pixels drawn
	//NumberOfPixelsDrawn = 0;
	
	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	
	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}
	
	
	// check if sprite is within draw area
	if ( x1 < DrawArea_TopLeftX || x0 > DrawArea_BottomRightX || y1 < DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;
	*/

		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		color_add = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		StartX = data [ uIdx + 8 ];
		EndX = data [ uIdx + 9 ];
		StartY = data [ uIdx + 10 ];
		EndY = data [ uIdx + 11 ];
		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];
		u0 = data [ uIdx + 16 ];
		v0 = data [ uIdx + 17 ];
		TWYTWH = data [ uIdx + 18 ];
		TWXTWW = data [ uIdx + 19 ];
		Not_TWH = data [ uIdx + 20 ];
		Not_TWW = data [ uIdx + 21 ];
		TextureOffset = data [ uIdx + 22 ];
		ClutOffset = data [ uIdx + 23 ];
		clut_xoffset = data [ uIdx + 24 ];


	
	if ( bDraw == 1 )
	{
	// align the compute units with pixels
	xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	
	//iV = v0;
	iV = v0 + yid;

	//for ( Line = StartY; Line <= EndY; Line++ )
	for ( Line = StartY + yid; Line <= EndY; Line += group_yinc )
	{
		
			// need to start texture coord from left again
			//iU = u0;
			iU = u0 + xid;

			TexCoordY = ( ( iV & Not_TWH ) | ( TWYTWH ) ) & 0xff;
			TexCoordY <<= 10;

			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			iPtr = StartX + xid + ( Line << 10 );

			// draw horizontal line
			for ( x_across = StartX + xid; x_across <= EndX; x_across += group_xinc )
			{
				TexCoordX = ( ( iU & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				
				
				if ( Shift1 != 0 )
				{
					bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( int( bgr ) >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				}

				
				if ( bgr != 0 )
				{
					// read pixel from frame buffer if we need to check mask bit
					//DestPixel = *ptr;
					DestPixel = VRAM [ iPtr ];
					
					bgr_temp = bgr;
		
					
					if ( Command_TGE == 0 )
					{
						// brightness calculation
						//bgr_temp = Color24To16 ( ColorMultiply24 ( Color16To24 ( bgr_temp ), color_add ) );
						bgr_temp = ColorMultiply1624 ( bgr_temp, color_add );
					}
					
					
					// semi-transparency
					if ( Command_ABE != 0 && ( bgr & 0x8000 ) != 0 )
					{
						bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					}
					
					
					// check if we should set mask bit when drawing
					bgr_temp |= SetPixelMask | ( bgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;
					
				}
				
					
				/////////////////////////////////////////////////////////
				// interpolate texture coords across
				//iU += xinc;
				iU += group_xinc;
				
				// update pointer for pixel out
				//iPtr += xinc;
				iPtr += group_xinc;
				
					
			}
		
		/////////////////////////////////////////////////////////
		// interpolate texture coords down
		//iV += yinc;
		iV += group_yinc;
		
	}

	}	// end if ( bDraw == 1 )
	
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;

	} while ( ( ( Comm >= 0x64 && Comm <= 0x67 ) || ( Comm >= 0x74 && Comm <= 0x77 ) || ( Comm >= 0x7c && Comm <= 0x7f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );


	//barrier();


	//return;
	return ( uIndex >> 4 ) - 1;
}



#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Mono ( uint uIndex )
#else
void vDrawTriangle_Mono ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;


	
	int Temp;
	int iStartX, iEndX;
	int x_across;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;

	int DitherValue;
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	int Red, Green, Blue;



	uint bgr16;
	//uint bgr32;

	//int w, h, xmax, ymax, ymax2;
	//int x, y;

	int group_yoffset;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	//uint Command_TGE;

	//uint color_add;
	//int clut_xoffset, clut_yoffset;
	//int clut_x, clut_y, tpage_tx, tpage_ty;
	//uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;

	uint PixelMask, SetPixelMask;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	int Coord0, Coord1, Coord2;


	int gx [ 3 ], gy [ 3 ];
	uint gbgr [ 3 ];

	uint bgr32;

	int x_left, x_right;
	int LeftMostX, RightMostX;

	int dR_left, dG_left, dB_left;
	int dR_across, dG_across, dB_across;
	int R_left, G_left, B_left;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	//int Shift1, Shift2, And1, And2;
	//int TextureOffset;
	//int ClutOffset;

	//int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	//int TWX, TWY, TWW, TWH;

	//int u0, v0, u1, v1, u2, v2;
	//int u, v;

	//int dU_left, dV_left;
	//int dU_across, dV_across;
	//int U_left, V_left;
	//int gu [ 3 ], gv [ 3 ];

	int dRx_across;
	int dGx_across;
	int dBx_across;

	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;


	uint Comm;
	uint bDraw;

	uint uIdx;
	uint uLoop;


	// setup local vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];


	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );
		//GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		
		//EndY = data [ uIdx + 11 ];
		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//TWYTWH = data [ uIdx + 16 ];
		//TWXTWW = data [ uIdx + 17 ];
		//Not_TWH = data [ uIdx + 18 ];
		//Not_TWW = data [ uIdx + 19 ];
		//TextureOffset = data [ uIdx + 20 ];
		//ClutOffset = data [ uIdx + 21 ];
		//clut_xoffset = data [ uIdx + 22 ];
		//tpage_abr = data [ uIdx + 23 ];
		//dR_across = data [ uIdx + 24 ];
		//dG_across = data [ uIdx + 25 ];
		//dB_across = data [ uIdx + 26 ];
		//dU_across = data [ uIdx + 27 ];
		//dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;
		

		//dRx_across = dR_across * group_vxinc;
		//dGx_across = dG_across * group_vxinc;
		//dBx_across = dB_across * group_vxinc;

		//dUx_across = dU_across * xinc;
		//dVx_across = dV_across * xinc;

	ivRedF = ivec4( ( bgr32 >> 3 ) & 0x1f );
	ivGreenF = ivec4( ( bgr32 >> 11 ) & 0x1f );
	ivBlueF = ivec4( ( bgr32 >> 19 ) & 0x1f );

	uvbgr_temp = uvec4( bgr16 );
	uvbgr_temp |= SetPixelMask;

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


	// align the compute units with pixels

	//barrier ();


		for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];
		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		//R_left = data [ uIdx + 36 + uLoop ];
		//G_left = data [ uIdx + 37 + uLoop ];
		//B_left = data [ uIdx + 38 + uLoop ];
		//dR_left = data [ uIdx + 39 + uLoop ];
		//dG_left = data [ uIdx + 40 + uLoop ];
		//dB_left = data [ uIdx + 41 + uLoop ];
		//U_left = data [ uIdx + 42 ];
		//V_left = data [ uIdx + 43 ];
		//dU_left = data [ uIdx + 44 ];
		//dV_left = data [ uIdx + 45 ];
		

		




	
	/////////////////////////////////////////////
	// init x on the left and right
	
	

	//if ( EndY > StartY )
	//{
	
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;



	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	//Roff_left = R_left + ( dR_left * (yid) );
	//Goff_left = G_left + ( dG_left * (yid) );
	//Boff_left = B_left + ( dB_left * (yid) );
	
	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			
			//iR = Roff_left;
			//iG = Goff_left;
			//iB = Boff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
			}
			
			//iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			//iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			//iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( iStartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

			w = iEndX - iStartX + 1;


			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = iStartX + xid + ( Line << 10 );
			ivPtr = ( iStartX + vxid ) + ( Line << 10 );

			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );
			//ivR = iR + ( dR_across * vxid );
			//ivG = iG + ( dG_across * vxid );
			//ivB = iB + ( dB_across * vxid );



			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

					
					//bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
					
					// shade pixel color
				
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
#endif
					
//#ifdef ENABLE_SEMI_TRANSPARENCY

#ifdef USE_MORE_JUMPS
				if ( Command_ABE != 0 )
#endif
				{
					// semi-transparency
					//if ( Command_ABE != 0 )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					//}

				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 0x1f );
				ivGreenB = clamp( ivGreenB, 0, 0x1f );
				ivBlueB = clamp( ivBlueB, 0, 0x1f );
//#endif

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );


					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask;
					uvbgr_temp |= SetPixelMask;
				}
					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					// *ptr = DestPixel;
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif
						
//#ifdef INC_ACROSS
					//iR += ( dRx_across );
					//iG += ( dGx_across );
					//iB += ( dBx_across );
					//ivR += dRx_across;
					//ivG += dGx_across;
					//ivB += dBx_across;
//#endif
				
				//ptr += xinc;
				//iPtr += xinc;
				ivPtr += group_vxinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		//Roff_left += ( dR_left * yinc );
		//Goff_left += ( dG_left * yinc );
		//Boff_left += ( dB_left * yinc );
	}

	//} // end if ( EndY > StartY )
	

	}	// end for ( uLoop = 0; uLoop < 32; uLoop += 16 )
	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier();

	
	}	// end if ( bDraw == 1 )

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x30 && Comm <= 0x33 ) || ( Comm >= 0x38 && Comm <= 0x3b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}



uint DrawTriangle_Mono ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	int iPtr;

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_BottomRightX
//2: DrawArea_TopLeftX
//3: DrawArea_BottomRightY
//4: DrawArea_TopLeftY
//5: DrawArea_OffsetX
//6: DrawArea_OffsetY
//7: GetBGR24 ( Buffer [ 0 ] );
//8: GetXY0 ( Buffer [ 1 ] );
//9: GetXY1 ( Buffer [ 2 ] );
//10: GetXY2 ( Buffer [ 3 ] );



	
	int Temp;
	int iStartX, iEndX;
	int x_across;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	

	uint bgr16;
	uint bgr32;

	//int w, h, xmax, ymax, ymax2;
	//int x, y;

	int group_yoffset;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	uint Command_ABE;
	//uint GPU_CTRL_Read_DTD;
	//uint Command_TGE;

	//uint color_add;
	//int clut_xoffset, clut_yoffset;
	//int clut_x, clut_y, tpage_tx, tpage_ty;
	//uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;

	uint PixelMask, SetPixelMask;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	int Coord0, Coord1, Coord2;


	int gx [ 3 ], gy [ 3 ];
	//uint gbgr [ 3 ];

	int x_left, x_right;
	int LeftMostX, RightMostX;

	//int dR_left, dG_left, dB_left;
	//int dR_across, dG_across, dB_across;
	//int R_left, G_left, B_left;
	//int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	//int Shift1, Shift2, And1, And2;
	//int TextureOffset;
	//int ClutOffset;

	//int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	//int TWX, TWY, TWW, TWH;

	//int u0, v0, u1, v1, u2, v2;
	//int u, v;

	//int dU_left, dV_left;
	//int dU_across, dV_across;
	//int U_left, V_left;
	//int gu [ 3 ], gv [ 3 ];


	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;

	// setup local vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;

	do
	{
		/*
		// no bitmaps in opencl ??
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;
		
		
		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 5 ) >> 21 );
		gx [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 21 ) >> 21 );
		gy [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 5 ) >> 21 );
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;
		
		Coord0 = 0;
		Coord1 = 1;
		Coord2 = 2;
		
		
		// get color(s)
		//bgr32 = gbgr [ 0 ];
		bgr32 = inputdata [ uIndex + 7 ] & 0x00ffffff;
		
		// ?? convert to 16-bit ?? (or should leave 24-bit?)
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		///////////////////////////////////
		// put top coordinates in x0,y0
		if ( gy [ Coord1 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord1;
			Coord1 = Temp;
		}
		
		if ( gy [ Coord2 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord2;
			Coord2 = Temp;
		}
		
		///////////////////////////////////////
		// put middle coordinates in x1,y1
		if ( gy [ Coord2 ] < gy [ Coord1 ] )
		{
			Temp = Coord1;
			Coord1 = Coord2;
			Coord2 = Temp;
		}
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		x2 = gx [ Coord2 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		y2 = gy [ Coord2 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 = DrawArea_OffsetX + x0;
		y0 = DrawArea_OffsetY + y0;
		x1 = DrawArea_OffsetX + x1;
		y1 = DrawArea_OffsetY + y1;
		x2 = DrawArea_OffsetX + x2;
		y2 = DrawArea_OffsetY + y2;
		
		
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );

		
		
		
		/////////////////////////////////////////////////
		// draw top part of triangle
		
		// denominator is negative when x1 is on the left, positive when x1 is on the right
		t0 = y1 - y2;
		t1 = y0 - y2;
		denominator = ( ( x0 - x2 ) * t0 ) - ( ( x1 - x2 ) * t1 );

		
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
			if ( ( y1 - y0 ) != 0 )
			{
				/////////////////////////////////////////////
				// init x on the left and right
				x_left = ( x0 << 16 );
				x_right = x_left;
				
				if ( denominator < 0 )
				{
					dx_left = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_left = ( ((s64)( x1 - x0 )) * r10 ) >> 32;
					//dx_right = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
				}
				else
				{
					dx_right = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_right = ( ((s64)( x1 - x0 )) * r10 ) >> 32;
					//dx_left = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
				}
			}
			else
			{
				if ( denominator < 0 )
				{
					// change x_left and x_right where y1 is on left
					x_left = ( x1 << 16 );
					x_right = ( x0 << 16 );
				
					dx_left = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
					dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_left = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
					//dx_right = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
				}
				else
				{
					x_right = ( x1 << 16 );
					x_left = ( x0 << 16 );
				
					dx_right = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
					dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_right = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
					//dx_left = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
				}
			}
		//}
		


	
		////////////////
		// *** TODO *** at this point area of full triangle can be calculated and the rest of the drawing can be put on another thread *** //
		
		
		
		StartY = y0;
		EndY = y1;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}

		bDraw = 1;

	//}	// end if ( !local_id )
	
	

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier();

	
	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	
	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	// check if sprite is within draw area
	if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || y2 <= DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0; //return;
	
	// skip drawing if distance between vertices is greater than max allowed by GPU
	//if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( x2 - x1 ) > c_MaxPolygonWidth ) || ( y1 - y0 > c_MaxPolygonHeight ) || ( y2 - y1 > c_MaxPolygonHeight ) )
	if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( y2- y0 ) > c_MaxPolygonHeight ) )
	{
		// skip drawing polygon
		//return;
		bDraw = 0;
	}
	*/

		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );
		//GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		
		//EndY = data [ uIdx + 11 ];
		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//TWYTWH = data [ uIdx + 16 ];
		//TWXTWW = data [ uIdx + 17 ];
		//Not_TWH = data [ uIdx + 18 ];
		//Not_TWW = data [ uIdx + 19 ];
		//TextureOffset = data [ uIdx + 20 ];
		//ClutOffset = data [ uIdx + 21 ];
		//clut_xoffset = data [ uIdx + 22 ];
		//tpage_abr = data [ uIdx + 23 ];
		//dR_across = data [ uIdx + 24 ];
		//dG_across = data [ uIdx + 25 ];
		//dB_across = data [ uIdx + 26 ];
		//dU_across = data [ uIdx + 27 ];
		//dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;
		

		//dRx_across = dR_across * xinc;
		//dGx_across = dG_across * xinc;
		//dBx_across = dB_across * xinc;

		//dUx_across = dU_across * xinc;
		//dVx_across = dV_across * xinc;

		for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		{
		
		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];
		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		//R_left = data [ uIdx + 36 ];
		//G_left = data [ uIdx + 37 ];
		//B_left = data [ uIdx + 38 ];
		//dR_left = data [ uIdx + 39 ];
		//dG_left = data [ uIdx + 40 ];
		//dB_left = data [ uIdx + 41 ];
		//U_left = data [ uIdx + 42 ];
		//V_left = data [ uIdx + 43 ];
		//dU_left = data [ uIdx + 44 ];
		//dV_left = data [ uIdx + 45 ];

	


	//if ( EndY > StartY )
	//{

	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );


	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
		
			if ( iStartX < DrawArea_TopLeftX )
			{
				iStartX = DrawArea_TopLeftX;
			}
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			iPtr = iStartX + xid + ( Line << 10 );
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			{
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
				// *ptr = DestPixel;
				VRAM [ iPtr ] = DestPixel;
				
				//ptr += xinc;
				iPtr += xinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		//x_left += dx_left;
		//x_right += dx_right;
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
	}

	//} // end if ( EndY > StartY )

	}	// end for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();
	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	
	/*
	//if ( ( xid + yid ) == 0 )
	//{
	
		//////////////////////////////////////////////////////
		// check if y1 is on the left or on the right
		if ( denominator < 0 )
		{
			// y1 is on the left //
			
			x_left = ( x1 << 16 );
			
			// need to recalculate the other side when doing this in parallel with this algorithm
			x_right = ( x0 << 16 ) + ( ( y1 - y0 ) * dx_right );
			
			//if ( y2 - y1 )
			//{
				dx_left = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
				//dx_left = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
			//}
		}
		else
		{
			// y1 is on the right //
			
			x_right = ( x1 << 16 );
			
			// need to recalculate the other side when doing this in parallel with this algorithm
			x_left = ( x0 << 16 ) + ( ( y1 - y0 ) * dx_left );
			
			//if ( y2 - y1 )
			//{
				dx_right = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
				//dx_right = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
			//}
		}
		
		
		
		// the line starts at y1 from here
		//Line = y1;

		StartY = y1;
		EndY = y2;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}
		
	//}
	*/

	/*
		StartY = data [ uIdx + 46 ];
		EndY = data [ uIdx + 47 ];
		x_left = data [ uIdx + 48 ];
		x_right = data [ uIdx + 49 ];
		dx_left = data [ uIdx + 50 ];
		dx_right = data [ uIdx + 51 ];
		//R_left = data [ uIdx + 52 ];
		//G_left = data [ uIdx + 53 ];
		//B_left = data [ uIdx + 54 ];
		//dR_left = data [ uIdx + 55 ];
		//dG_left = data [ uIdx + 56 ];
		//dB_left = data [ uIdx + 57 ];
		//U_left = data [ uIdx + 58 ];
		//V_left = data [ uIdx + 59 ];
		//dU_left = data [ uIdx + 60 ];
		//dV_left = data [ uIdx + 61 ];

	
	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	if ( EndY > StartY )
	{
	
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	//////////////////////////////////////////////
	// draw down to y2
	for ( Line = StartY + group_yoffset + yid; Line < EndY; Line += yinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			if ( iStartX < DrawArea_TopLeftX )
			{
				iStartX = DrawArea_TopLeftX;
			}
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				iEndX = DrawArea_BottomRightX;
			}

			// align the compute units with pixels
			xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			iPtr = iStartX + xid + ( Line << 10 );
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			{
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
				// *ptr = DestPixel;
				VRAM [ iPtr ] = DestPixel;
				
				//ptr += xinc;
				iPtr += xinc;
			}
			
		}
		
		/////////////////////////////////////
		// update x on left and right
		//x_left += dx_left;
		//x_right += dx_right;
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
	}
	
	} // end if ( EndY > StartY )
	*/

	}	// end if ( bDraw == 1 )
	
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x20 && Comm <= 0x23 ) || ( Comm >= 0x28 && Comm <= 0x2b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );


	//return;
	return ( uIndex >> 4 ) - 1;
}





#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Gradient ( uint uIndex )
#else
void vDrawTriangle_Gradient ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_BottomRightX
//2: DrawArea_TopLeftX
//3: DrawArea_BottomRightY
//4: DrawArea_TopLeftY
//5: DrawArea_OffsetX
//6: DrawArea_OffsetY
//7: GetBGR0_8 ( Buffer [ 0 ] );
//8: GetXY0 ( Buffer [ 1 ] );
//9: GetBGR1_8 ( Buffer [ 2 ] );
//10: GetXY1 ( Buffer [ 3 ] );
//11: GetBGR2_8 ( Buffer [ 4 ] );
//12: GetXY2 ( Buffer [ 5 ] );

	
	int Temp;
	int iStartX, iEndX;
	int x_across;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;

	int DitherValue;
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	int Red, Green, Blue;



	//uint bgr16;
	//uint bgr32;

	//int w, h, xmax, ymax, ymax2;
	//int x, y;

	int group_yoffset;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	//uint Command_TGE;

	//uint color_add;
	//int clut_xoffset, clut_yoffset;
	//int clut_x, clut_y, tpage_tx, tpage_ty;
	//uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;

	uint PixelMask, SetPixelMask;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	int Coord0, Coord1, Coord2;


	int gx [ 3 ], gy [ 3 ];
	uint gbgr [ 3 ];

	int x_left, x_right;
	int LeftMostX, RightMostX;

	int dR_left, dG_left, dB_left;
	int dR_across, dG_across, dB_across;
	int R_left, G_left, B_left;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	//int Shift1, Shift2, And1, And2;
	//int TextureOffset;
	//int ClutOffset;

	//int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	//int TWX, TWY, TWW, TWH;

	//int u0, v0, u1, v1, u2, v2;
	//int u, v;

	//int dU_left, dV_left;
	//int dU_across, dV_across;
	//int U_left, V_left;
	//int gu [ 3 ], gv [ 3 ];

	int dRx_across;
	int dGx_across;
	int dBx_across;

	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 vEndX;
	ivec4 ivIndex;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;


	uint Comm;
	uint bDraw;

	uint uIdx;
	uint uLoop;


	// setup local vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];


	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		
		//EndY = data [ uIdx + 11 ];
		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//TWYTWH = data [ uIdx + 16 ];
		//TWXTWW = data [ uIdx + 17 ];
		//Not_TWH = data [ uIdx + 18 ];
		//Not_TWW = data [ uIdx + 19 ];
		//TextureOffset = data [ uIdx + 20 ];
		//ClutOffset = data [ uIdx + 21 ];
		//clut_xoffset = data [ uIdx + 22 ];
		//tpage_abr = data [ uIdx + 23 ];
		dR_across = data [ uIdx + 24 ];
		dG_across = data [ uIdx + 25 ];
		dB_across = data [ uIdx + 26 ];
		//dU_across = data [ uIdx + 27 ];
		//dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;
		

		dRx_across = dR_across * group_vxinc;
		dGx_across = dG_across * group_vxinc;
		dBx_across = dB_across * group_vxinc;

		//dUx_across = dU_across * xinc;
		//dVx_across = dV_across * xinc;


	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


	// align the compute units with pixels

	//barrier ();


		for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];
		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		R_left = data [ uIdx + 36 + uLoop ];
		G_left = data [ uIdx + 37 + uLoop ];
		B_left = data [ uIdx + 38 + uLoop ];
		dR_left = data [ uIdx + 39 + uLoop ];
		dG_left = data [ uIdx + 40 + uLoop ];
		dB_left = data [ uIdx + 41 + uLoop ];
		//U_left = data [ uIdx + 42 ];
		//V_left = data [ uIdx + 43 ];
		//dU_left = data [ uIdx + 44 ];
		//dV_left = data [ uIdx + 45 ];
		

		




	
	/////////////////////////////////////////////
	// init x on the left and right
	
	

	//if ( EndY > StartY )
	//{
	
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;



	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	Roff_left = R_left + ( dR_left * (yid) );
	Goff_left = G_left + ( dG_left * (yid) );
	Boff_left = B_left + ( dB_left * (yid) );
	
	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			
			iR = Roff_left;
			iG = Goff_left;
			iB = Boff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
			}
			
			iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( iStartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

			w = iEndX - iStartX + 1;


			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = iStartX + xid + ( Line << 10 );
			ivPtr = ( iStartX + vxid ) + ( Line << 10 );

			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );
			ivR = iR + ( dR_across * vxid );
			ivG = iG + ( dG_across * vxid );
			ivB = iB + ( dB_across * vxid );



			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

					
#ifdef USE_MORE_JUMPS
				if ( GPU_CTRL_Read_DTD != 0 )
#endif
				{
				ivIndex = ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 );
				ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );
				ivDitherValue[0] = c_iDitherValues16 [ ivIndex[0] ];
				ivDitherValue[1] = c_iDitherValues16 [ ivIndex[1] ];
				ivDitherValue[2] = c_iDitherValues16 [ ivIndex[2] ];
				ivDitherValue[3] = c_iDitherValues16 [ ivIndex[3] ];

				// perform dither
				ivRedF = ivR + ivDitherValue;
				ivGreenF = ivG + ivDitherValue;
				ivBlueF = ivB + ivDitherValue;
				
				// perform shift
				ivRedF >>= ( 16 + 3 );
				ivGreenF >>= ( 16 + 3 );
				ivBlueF >>= ( 16 + 3 );
				
				ivRedF = clamp ( ivRedF, 0, 31 );
				ivGreenF = clamp ( ivGreenF, 0, 31 );
				ivBlueF = clamp ( ivBlueF, 0, 31 );
				}
#ifdef USE_MORE_JUMPS
				else
				{
				ivRedF = ivR >> (16+3);
				ivGreenF = ivG >> (16+3);
				ivBlueF = ivB >> (16+3);
				}
#endif
					
					//bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
					
					// shade pixel color
				
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
#endif
					
					
//#ifdef ENABLE_SEMI_TRANSPARENCY
					// semi-transparency
					//if ( Command_ABE != 0 )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					//}

#ifdef USE_MORE_JUMPS
				if ( Command_ABE != 0 )
#endif
				{
				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedF = clamp( ivRedB, 0, 0x1f );
				ivGreenF = clamp( ivGreenB, 0, 0x1f );
				ivBlueF = clamp( ivBlueB, 0, 0x1f );
				}


				uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );


					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask;
					uvbgr_temp |= SetPixelMask;

					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );


					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					// *ptr = DestPixel;
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif
					
					//iR += ( dRx_across );
					//iG += ( dGx_across );
					//iB += ( dBx_across );
					ivR += dRx_across;
					ivG += dGx_across;
					ivB += dBx_across;
				
				//ptr += xinc;
				//iPtr += xinc;
				ivPtr += group_vxinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		Roff_left += ( dR_left * yinc );
		Goff_left += ( dG_left * yinc );
		Boff_left += ( dB_left * yinc );
	}

	//} // end if ( EndY > StartY )
	

	}	// end for ( uLoop = 0; uLoop < 32; uLoop += 16 )
	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier();

	
	}	// end if ( bDraw == 1 )

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x30 && Comm <= 0x33 ) || ( Comm >= 0x38 && Comm <= 0x3b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}





uint DrawTriangle_Gradient ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_BottomRightX
//2: DrawArea_TopLeftX
//3: DrawArea_BottomRightY
//4: DrawArea_TopLeftY
//5: DrawArea_OffsetX
//6: DrawArea_OffsetY
//7: GetBGR0_8 ( Buffer [ 0 ] );
//8: GetXY0 ( Buffer [ 1 ] );
//9: GetBGR1_8 ( Buffer [ 2 ] );
//10: GetXY1 ( Buffer [ 3 ] );
//11: GetBGR2_8 ( Buffer [ 4 ] );
//12: GetXY2 ( Buffer [ 5 ] );

	
	int Temp;
	int iStartX, iEndX;
	int x_across;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;

	int DitherValue;
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	int Red, Green, Blue;



	//uint bgr16;
	//uint bgr32;

	//int w, h, xmax, ymax, ymax2;
	//int x, y;

	int group_yoffset;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	//uint Command_TGE;

	//uint color_add;
	//int clut_xoffset, clut_yoffset;
	//int clut_x, clut_y, tpage_tx, tpage_ty;
	//uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;

	uint PixelMask, SetPixelMask;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	int Coord0, Coord1, Coord2;


	int gx [ 3 ], gy [ 3 ];
	uint gbgr [ 3 ];

	int x_left, x_right;
	int LeftMostX, RightMostX;

	int dR_left, dG_left, dB_left;
	int dR_across, dG_across, dB_across;
	int R_left, G_left, B_left;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	//int Shift1, Shift2, And1, And2;
	//int TextureOffset;
	//int ClutOffset;

	//int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	//int TWX, TWY, TWW, TWH;

	//int u0, v0, u1, v1, u2, v2;
	//int u, v;

	//int dU_left, dV_left;
	//int dU_across, dV_across;
	//int U_left, V_left;
	//int gu [ 3 ], gv [ 3 ];

	int dRx_across;
	int dGx_across;
	int dBx_across;


	uint Comm;
	uint bDraw;

	uint uIdx;
	uint uLoop;


	// setup local vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;

	do
	{

		/*
		// no bitmaps in opencl ??
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;
		
		
		gbgr [ 0 ] = inputdata [ uIndex + 7 ] & 0x00ffffff;
		gbgr [ 1 ] = inputdata [ uIndex + 10 ] & 0x00ffffff;
		gbgr [ 2 ] = inputdata [ uIndex + 13 ] & 0x00ffffff;
		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 5 ) >> 21 );
		gx [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 21 ) >> 21 );
		gy [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 5 ) >> 21 );
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		
		
		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;
		
		Coord0 = 0;
		Coord1 = 1;
		Coord2 = 2;
		
		
		///////////////////////////////////
		// put top coordinates in x0,y0
		if ( gy [ Coord1 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord1;
			Coord1 = Temp;
		}
		
		if ( gy [ Coord2 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord2;
			Coord2 = Temp;
		}
		
		///////////////////////////////////////
		// put middle coordinates in x1,y1
		if ( gy [ Coord2 ] < gy [ Coord1 ] )
		{
			Temp = Coord1;
			Coord1 = Coord2;
			Coord2 = Temp;
		}
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		x2 = gx [ Coord2 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		y2 = gy [ Coord2 ];

		// get rgb-values
		r0 = int( gbgr [ Coord0 ] ) & 0xff;
		r1 = int( gbgr [ Coord1 ] ) & 0xff;
		r2 = int( gbgr [ Coord2 ] ) & 0xff;
		g0 = int( gbgr [ Coord0 ] >> 8 ) & 0xff;
		g1 = int( gbgr [ Coord1 ] >> 8 ) & 0xff;
		g2 = int( gbgr [ Coord2 ] >> 8 ) & 0xff;
		b0 = int( gbgr [ Coord0 ] >> 16 ) & 0xff;
		b1 = int( gbgr [ Coord1 ] >> 16 ) & 0xff;
		b2 = int( gbgr [ Coord2 ] >> 16 ) & 0xff;
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 = DrawArea_OffsetX + x0;
		y0 = DrawArea_OffsetY + y0;
		x1 = DrawArea_OffsetX + x1;
		y1 = DrawArea_OffsetY + y1;
		x2 = DrawArea_OffsetX + x2;
		y2 = DrawArea_OffsetY + y2;
		
		
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );

		
		/////////////////////////////////////////////////
		// draw top part of triangle
		
		// denominator is negative when x1 is on the left, positive when x1 is on the right
		t0 = y1 - y2;
		t1 = y0 - y2;
		denominator = ( ( x0 - x2 ) * t0 ) - ( ( x1 - x2 ) * t1 );
		if ( denominator != 0 )
		{
			//dR_across = ( ( ( ( ( r0 - r2 ) * t0 ) - ( ( r1 - r2 ) * t1 ) ) ) << 16 ) / denominator;
			//dG_across = ( ( ( ( ( g0 - g2 ) * t0 ) - ( ( g1 - g2 ) * t1 ) ) ) << 16 ) / denominator;
			//dB_across = ( ( ( ( ( b0 - b2 ) * t0 ) - ( ( b1 - b2 ) * t1 ) ) ) << 16 ) / denominator;
			//dR_across = (s32) (( ( ( (double) ( ( ( r0 - r2 ) * t0 ) - ( ( r1 - r2 ) * t1 ) ) ) ) / (double)denominator)*65536.0);
			//dG_across = (s32) (( ( ( (double) ( ( ( g0 - g2 ) * t0 ) - ( ( g1 - g2 ) * t1 ) ) ) ) / (double)denominator)*65536.0);
			//dB_across = (s32) (( ( ( (double) ( ( ( b0 - b2 ) * t0 ) - ( ( b1 - b2 ) * t1 ) ) ) ) / (double)denominator)*65536.0);

			dR_across = ( ( ( ( ( r0 - r2 ) * t0 ) - ( ( r1 - r2 ) * t1 ) ) ) << 8 ) / denominator;
			dG_across = ( ( ( ( ( g0 - g2 ) * t0 ) - ( ( g1 - g2 ) * t1 ) ) ) << 8 ) / denominator;
			dB_across = ( ( ( ( ( b0 - b2 ) * t0 ) - ( ( b1 - b2 ) * t1 ) ) ) << 8 ) / denominator;
			
			dR_across <<= 8;
			dG_across <<= 8;
			dB_across <<= 8;

			dRx_across = dR_across * xinc;
			dGx_across = dG_across * xinc;
			dBx_across = dB_across * xinc;
		}
		
		
		
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
			if ( ( y1 - y0 ) != 0 )
			{
				/////////////////////////////////////////////
				// init x on the left and right
				x_left = ( x0 << 16 );
				x_right = x_left;
				
				R_left = ( r0 << 16 );
				G_left = ( g0 << 16 );
				B_left = ( b0 << 16 );
				
				if ( denominator < 0 )
				{
					dx_left = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_left = ( ((s64)( x1 - x0 )) * r10 ) >> 32;
					//dx_right = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
					
					dR_left = (( r1 - r0 ) << 16 ) / ( y1 - y0 );
					dG_left = (( g1 - g0 ) << 16 ) / ( y1 - y0 );
					dB_left = (( b1 - b0 ) << 16 ) / ( y1 - y0 );
					//dR_left = (s32)((( (double)( r1 - r0 ) ) / (double)( y1 - y0 ))*65536);
					//dG_left = (s32)((( (double)( g1 - g0 ) ) / (double)( y1 - y0 ))*65536);
					//dB_left = (s32)((( (double)( b1 - b0 ) ) / (double)( y1 - y0 ))*65536);
				}
				else
				{
					dx_right = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_right = ( ((s64)( x1 - x0 )) * r10 ) >> 32;
					//dx_left = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
					
					dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
					dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
					dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
					//dR_left = (s32)((( (double)( r2 - r0 ) ) / (double)( y2 - y0 ))*65536);
					//dG_left = (s32)((( (double)( g2 - g0 ) ) / (double)( y2 - y0 ))*65536);
					//dB_left = (s32)((( (double)( b2 - b0 ) ) / (double)( y2 - y0 ))*65536);
				}
			}
			else
			{
				if ( denominator < 0 )
				{
					// change x_left and x_right where y1 is on left
					x_left = ( x1 << 16 );
					x_right = ( x0 << 16 );
					
					dx_left = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
					dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_left = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
					//dx_right = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
					
					R_left = ( r1 << 16 );
					G_left = ( g1 << 16 );
					B_left = ( b1 << 16 );

					dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
					dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
					dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
					//dR_left = (s32)((( (double)( r2 - r1 ) ) / (double)( y2 - y1 ))*65536);
					//dG_left = (s32)((( (double)( g2 - g1 ) ) / (double)( y2 - y1 ))*65536);
					//dB_left = (s32)((( (double)( b2 - b1 ) ) / (double)( y2 - y1 ))*65536);
				}
				else
				{
					x_right = ( x1 << 16 );
					x_left = ( x0 << 16 );
				
					dx_right = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
					dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_right = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
					//dx_left = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
					
					R_left = ( r0 << 16 );
					G_left = ( g0 << 16 );
					B_left = ( b0 << 16 );
					
					dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
					dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
					dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
					//dR_left = (s32)((( (double)( r2 - r0 ) ) / (double)( y2 - y0 ))*65536);
					//dG_left = (s32)((( (double)( g2 - g0 ) ) / (double)( y2 - y0 ))*65536);
					//dB_left = (s32)((( (double)( b2 - b0 ) ) / (double)( y2 - y0 ))*65536);
				}
			}
		//}
		


	
		////////////////
		// *** TODO *** at this point area of full triangle can be calculated and the rest of the drawing can be put on another thread *** //
		
		
		
		// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
		R_left |= ( 1 << 15 );
		G_left |= ( 1 << 15 );
		B_left |= ( 1 << 15 );
		
		
		StartY = y0;
		EndY = y1;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
			
			R_left += dR_left * Temp;
			G_left += dG_left * Temp;
			B_left += dB_left * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}

		
		bDraw = 1;
		

	//}	// end if ( !local_id )
	
	

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier();

	
	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	
	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	// check if sprite is within draw area
	if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || y2 <= DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;
	
	// skip drawing if distance between vertices is greater than max allowed by GPU
	//if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( x2 - x1 ) > c_MaxPolygonWidth ) || ( y1 - y0 > c_MaxPolygonHeight ) || ( y2 - y1 > c_MaxPolygonHeight ) )
	if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( y2- y0 ) > c_MaxPolygonHeight ) )
	{
		// skip drawing polygon
		//return;
		bDraw = 0;
	}
	*/

		
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];


	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		
		//EndY = data [ uIdx + 11 ];
		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//TWYTWH = data [ uIdx + 16 ];
		//TWXTWW = data [ uIdx + 17 ];
		//Not_TWH = data [ uIdx + 18 ];
		//Not_TWW = data [ uIdx + 19 ];
		//TextureOffset = data [ uIdx + 20 ];
		//ClutOffset = data [ uIdx + 21 ];
		//clut_xoffset = data [ uIdx + 22 ];
		//tpage_abr = data [ uIdx + 23 ];
		dR_across = data [ uIdx + 24 ];
		dG_across = data [ uIdx + 25 ];
		dB_across = data [ uIdx + 26 ];
		//dU_across = data [ uIdx + 27 ];
		//dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;
		

		dRx_across = dR_across * xinc;
		dGx_across = dG_across * xinc;
		dBx_across = dB_across * xinc;

		//dUx_across = dU_across * xinc;
		//dVx_across = dV_across * xinc;

		for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];
		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		R_left = data [ uIdx + 36 + uLoop ];
		G_left = data [ uIdx + 37 + uLoop ];
		B_left = data [ uIdx + 38 + uLoop ];
		dR_left = data [ uIdx + 39 + uLoop ];
		dG_left = data [ uIdx + 40 + uLoop ];
		dB_left = data [ uIdx + 41 + uLoop ];
		//U_left = data [ uIdx + 42 ];
		//V_left = data [ uIdx + 43 ];
		//dU_left = data [ uIdx + 44 ];
		//dV_left = data [ uIdx + 45 ];
		

		




	
	/////////////////////////////////////////////
	// init x on the left and right
	
	

	//if ( EndY > StartY )
	//{
	
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	Roff_left = R_left + ( dR_left * (yid) );
	Goff_left = G_left + ( dG_left * (yid) );
	Boff_left = B_left + ( dB_left * (yid) );
	
	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			
			iR = Roff_left;
			iG = Goff_left;
			iB = Boff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
			}
			
			iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			iPtr = iStartX + xid + ( Line << 10 );

			
			
			iR += ( dR_across * xid );
			iG += ( dG_across * xid );
			iB += ( dB_across * xid );



			// draw horizontal line
			// x_left and x_right need to be rounded off
			for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			{
				if ( GPU_CTRL_Read_DTD != 0 )
				{
					DitherValue = c_iDitherValues16 [ ( x_across & 3 ) + ( ( Line & 3 ) << 2 ) ];
					
					// perform dither
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					//Red = Clamp5 ( Red );
					//Green = Clamp5 ( Green );
					//Blue = Clamp5 ( Blue );
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
				
					
					
					bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
					
					// shade pixel color
				
					// read pixel from frame buffer if we need to check mask bit
					//DestPixel = *ptr;
					DestPixel = VRAM [ iPtr ];
					
					
					// semi-transparency
					if ( Command_ABE != 0 )
					{
						bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					}
					
					// check if we should set mask bit when drawing
					bgr_temp |= SetPixelMask;

					
					// draw pixel if we can draw to mask pixels or mask bit not set
					DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					// *ptr = DestPixel;
					VRAM [ iPtr ] = DestPixel;
						
					iR += ( dRx_across );
					iG += ( dGx_across );
					iB += ( dBx_across );
				
				//ptr += xinc;
				iPtr += xinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		Roff_left += ( dR_left * yinc );
		Goff_left += ( dG_left * yinc );
		Boff_left += ( dB_left * yinc );
	}

	//} // end if ( EndY > StartY )
	

	}	// end for ( uLoop = 0; uLoop < 32; uLoop += 16 )
	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier();

	/*
	//if ( ( xid + yid ) == 0 )
	//{
		//////////////////////////////////////////////////////
		// check if y1 is on the left or on the right
		if ( denominator < 0 )
		{
			x_left = ( x1 << 16 );
			x_right = ( x0 << 16 ) + ( dx_right * ( y1 - y0 ) );

			R_left = ( r1 << 16 );
			G_left = ( g1 << 16 );
			B_left = ( b1 << 16 );
			
			// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
			R_left |= ( 1 << 15 );
			G_left |= ( 1 << 15 );
			B_left |= ( 1 << 15 );
			
			//if ( y2 - y1 )
			//{
				dx_left = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				//dx_left = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
				
				dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
				dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
				dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
				//dR_left = ( ((s64)( r2 - r1 )) * r21 ) >> 24;
				//dG_left = ( ((s64)( g2 - g1 )) * r21 ) >> 24;
				//dB_left = ( ((s64)( b2 - b1 )) * r21 ) >> 24;
				//dR_left = (s32)((( (double)( r2 - r1 ) ) / (double)( y2 - y1 ))*65536);
				//dG_left = (s32)((( (double)( g2 - g1 ) ) / (double)( y2 - y1 ))*65536);
				//dB_left = (s32)((( (double)( b2 - b1 ) ) / (double)( y2 - y1 ))*65536);
			//}
		}
		else
		{
			x_right = ( x1 << 16 );
			x_left = ( x0 << 16 ) + ( dx_left * ( y1 - y0 ) );
			
			R_left = ( ( r0 << 16 ) | 0x8000 ) + ( dR_left * ( y1 - y0 ) );
			G_left = ( ( g0 << 16 ) | 0x8000 ) + ( dG_left * ( y1 - y0 ) );
			B_left = ( ( b0 << 16 ) | 0x8000 ) + ( dB_left * ( y1 - y0 ) );
			
			//if ( y2 - y1 )
			//{
				dx_right = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				//dx_right = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
				
			//}
		}
		

		StartY = y1;
		EndY = y2;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
			
			R_left += dR_left * Temp;
			G_left += dG_left * Temp;
			B_left += dB_left * Temp;
			
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}
		
		// offset to get to this compute unit's scanline
		//group_yoffset = 0;
	//}
	*/

		/*
		StartY = data [ uIdx + 46 ];
		EndY = data [ uIdx + 47 ];
		x_left = data [ uIdx + 48 ];
		x_right = data [ uIdx + 49 ];
		dx_left = data [ uIdx + 50 ];
		dx_right = data [ uIdx + 51 ];
		R_left = data [ uIdx + 52 ];
		G_left = data [ uIdx + 53 ];
		B_left = data [ uIdx + 54 ];
		dR_left = data [ uIdx + 55 ];
		dG_left = data [ uIdx + 56 ];
		dB_left = data [ uIdx + 57 ];
		//U_left = data [ uIdx + 58 ];
		//V_left = data [ uIdx + 59 ];
		//dU_left = data [ uIdx + 60 ];
		//dV_left = data [ uIdx + 61 ];
		

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier();

	if ( EndY > StartY )
	{
	
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	Roff_left = R_left + ( dR_left * (yid) );
	Goff_left = G_left + ( dG_left * (yid) );
	Boff_left = B_left + ( dB_left * (yid) );
	
	//////////////////////////////////////////////
	// draw down to y2
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			
			iR = Roff_left;
			iG = Goff_left;
			iB = Boff_left;
			
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
			}
			
			
			iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;
			
			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			iPtr = iStartX + xid + ( Line << 10 );

			iR += ( dR_across * xid );
			iG += ( dG_across * xid );
			iB += ( dB_across * xid );
			


			// draw horizontal line
			// x_left and x_right need to be rounded off
			for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			{
				
				if ( GPU_CTRL_Read_DTD != 0 )
				{
					DitherValue = c_iDitherValues16 [ ( x_across & 3 ) + ( ( Line & 3 ) << 2 ) ];
					
					// perform dither
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					//Red = Clamp5 ( Red );
					//Green = Clamp5 ( Green );
					//Blue = Clamp5 ( Blue );
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
					
					bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
					

					// shade pixel color
				
					// read pixel from frame buffer if we need to check mask bit
					//DestPixel = *ptr;
					DestPixel = VRAM [ iPtr ];
					
					// semi-transparency
					if ( Command_ABE != 0 )
					{
						bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					}
					
					// check if we should set mask bit when drawing
					bgr_temp |= SetPixelMask;


					// draw pixel if we can draw to mask pixels or mask bit not set
					DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					// *ptr = DestPixel;
					VRAM [ iPtr ] = DestPixel;
				
					
				iR += ( dRx_across );
				iG += ( dGx_across );
				iB += ( dBx_across );
				
				//ptr += xinc;
				iPtr += xinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		Roff_left += ( dR_left * yinc );
		Goff_left += ( dG_left * yinc );
		Boff_left += ( dB_left * yinc );
	}
	
	
	} // end if ( EndY > StartY )
	*/
	
	}	// end if ( bDraw == 1 )

		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x30 && Comm <= 0x33 ) || ( Comm >= 0x38 && Comm <= 0x3b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );


	//return;
	return ( uIndex >> 4 ) - 1;

}



#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_TextureGradient ( uint uIndex )
#else
void vDrawTriangle_TextureGradient ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;


	
	//global u16* private ptr;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	int Line;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;
	

	
	int xoff_left, xoff_right;
	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	//global u16* local ptr_texture;
	//global u16* local ptr_clut;
	
	int TexCoordX, TexCoordY;



//uint bgr16;
//uint bgr32;

//int w, h, xmax, ymax, ymax2;
//int x, y;

//int group_yoffset;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;
uint GPU_CTRL_Read_DTD;
uint Command_TGE;

//uint color_add;
int clut_xoffset, clut_yoffset;
int clut_x, clut_y, tpage_tx, tpage_ty;
uint tpage_abr, tpage_tp, command_abr;

int StartX, EndX, StartY, EndY;

uint PixelMask, SetPixelMask;

int x0, x1, x2, y0, y1, y2;

int dx_left, dx_right;
int t0, t1, denominator;

int Coord0, Coord1, Coord2;


int gx [ 3 ], gy [ 3 ];
uint gbgr [ 3 ];

int x_left, x_right;
int LeftMostX, RightMostX;

int dR_left, dG_left, dB_left;
int dR_across, dG_across, dB_across;
int R_left, G_left, B_left;
int r0, r1, r2, g0, g1, g2, b0, b1, b2;

int Shift1, Shift2, And1, And2;
int TextureOffset;
int ClutOffset;

int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
int TWX, TWY, TWW, TWH;

int u0, v0, u1, v1, u2, v2;
int u, v;

int dU_left, dV_left;
int dU_across, dV_across;
int U_left, V_left;
int gu [ 3 ], gv [ 3 ];

int dUx_across;
int dVx_across;

int dRx_across;
int dGx_across;
int dBx_across;


	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	uvec4 uvbgr, uvbgr2;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivTexCoordY;
	ivec4 ivTexCoordX;
	ivec4 ivU;
	ivec4 ivV;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;


	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;


	//barrier ();

	// setup vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif
		

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];
		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];
		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];
		dR_across = data [ uIdx + 24 ];
		dG_across = data [ uIdx + 25 ];
		dB_across = data [ uIdx + 26 ];
		dU_across = data [ uIdx + 27 ];
		dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;

		dRx_across = dR_across * group_vxinc;
		dGx_across = dG_across * group_vxinc;
		dBx_across = dB_across * group_vxinc;

		dUx_across = dU_across * group_vxinc;
		dVx_across = dV_across * group_vxinc;

	//if ( Command_TGE != 0 )
	//{
	//	color_add = 0x00808080;
	//}

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( tpage_abr )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


		for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];
		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		R_left = data [ uIdx + 36 + uLoop ];
		G_left = data [ uIdx + 37 + uLoop ];
		B_left = data [ uIdx + 38 + uLoop ];
		dR_left = data [ uIdx + 39 + uLoop ];
		dG_left = data [ uIdx + 40 + uLoop ];
		dB_left = data [ uIdx + 41 + uLoop ];
		U_left = data [ uIdx + 42 + uLoop ];
		V_left = data [ uIdx + 43 + uLoop ];
		dU_left = data [ uIdx + 44 + uLoop ];
		dV_left = data [ uIdx + 45 + uLoop ];
		

		
		
	

	//if ( EndY > StartY )
	//{
	
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	Roff_left = R_left + ( dR_left * (yid) );
	Goff_left = G_left + ( dG_left * (yid) );
	Boff_left = B_left + ( dB_left * (yid) );
	
	Uoff_left = U_left + ( dU_left * (yid) );
	Voff_left = V_left + ( dV_left * (yid) );
	

	//////////////////////////////////////////////
	// draw down to y1
	//for ( Line = StartY; Line < EndY; Line++ )
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			iR = Roff_left;
			iG = Goff_left;
			iB = Boff_left;
			
			iU = Uoff_left;
			iV = Voff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
				
			}
			
			iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			iU += ( dU_across >> 8 ) * ( Temp >> 8 );
			iV += ( dV_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( iStartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

			w = iEndX - iStartX + 1;


			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = iStartX + xid + ( Line << 10 );
			ivPtr = ( iStartX + vxid ) + ( Line << 10 );


			//DitherLine = & ( DitherArray [ ( Line & 0x3 ) << 2 ] );
			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );
			ivR = iR + ( dR_across * vxid );
			ivG = iG + ( dG_across * vxid );
			ivB = iB + ( dB_across * vxid );

			//iU += ( dU_across * xid );
			//iV += ( dV_across * xid );
			ivU = iU + ( dU_across * vxid );
			ivV = iV + ( dV_across * vxid );
			
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );
				
				//TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				//TexCoordY <<= 10;
				//TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				ivTexCoordY = ( ( ( ivV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				ivTexCoordY <<= 10;
				ivTexCoordX = ( ( ( ivU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				// x-component should be shifted right 1 again since 2 pixels per?
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + ivTexCoordY;
				uvbgr[ 0 ] = VRAM [ ivIndex [ 0 ] ];
				uvbgr[ 1 ] = VRAM [ ivIndex [ 1 ] ];
				uvbgr[ 2 ] = VRAM [ ivIndex [ 2 ] ];
				uvbgr[ 3 ] = VRAM [ ivIndex [ 3 ] ];
				


#ifdef USE_MORE_JUMPS
				if ( Shift1 != 0 )
#endif
				{
				//if ( Shift1 != 0 )
				//{
				//	//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
				//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				//}
				ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );
				uvbgr2[0] = VRAM [ ivIndex [ 0 ] ];
				uvbgr2[1] = VRAM [ ivIndex [ 1 ] ];
				uvbgr2[2] = VRAM [ ivIndex [ 2 ] ];
				uvbgr2[3] = VRAM [ ivIndex [ 3 ] ];

				uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;
				}
				
				//if ( bgr != 0 )
				//{
					
					// shade pixel color
					
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
					uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
					uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
					uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif
					
					//bgr_temp = bgr;

				ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
				ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
				ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;

#ifdef USE_MORE_JUMPS
				if ( Command_TGE == 0 )
#endif
				{

					/*
					if ( Command_TGE == 0 )
					{
						if ( GPU_CTRL_Read_DTD != 0 )
						{
							DitherValue = c_iDitherValues16 [ ( x_across & 3 ) + ( ( Line & 3 ) << 2 ) ];
							
							// perform dither
							Red = iR + DitherValue;
							Green = iG + DitherValue;
							Blue = iB + DitherValue;
							
							// perform shift
							Red >>= ( 16 );
							Green >>= ( 16 );
							Blue >>= ( 16 );
							
							//Red = Clamp5 ( Red );
							//Green = Clamp5 ( Green );
							//Blue = Clamp5 ( Blue );
							Red = clamp ( Red, 0, 255 );
							Green = clamp ( Green, 0, 255 );
							Blue = clamp ( Blue, 0, 255 );
						}
						else
						{
							Red = iR >> ( 16 );
							Green = iG >> ( 16 );
							Blue = iB >> ( 16 );
						}

						
						ucolor_add = ( Blue << 16 ) | ( Green << 8 ) | Red;

						// brightness calculation
						//bgr_temp = Color24To16 ( ColorMultiply24 ( Color16To24 ( bgr_temp ), color_add ) );
						bgr_temp = ColorMultiply1624 ( bgr_temp, ucolor_add );
					}
					*/

				ivRedC = ivR;
				ivGreenC = ivG;
				ivBlueC = ivB;

#ifdef USE_MORE_JUMPS
				if ( GPU_CTRL_Read_DTD != 0 )
#endif
				{

				ivIndex = ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 );
				ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );
				ivDitherValue[0] = c_iDitherValues16 [ ivIndex[0] ];
				ivDitherValue[1] = c_iDitherValues16 [ ivIndex[1] ];
				ivDitherValue[2] = c_iDitherValues16 [ ivIndex[2] ];
				ivDitherValue[3] = c_iDitherValues16 [ ivIndex[3] ];

				// perform dither
				ivRedC = ivRedC + ivDitherValue;
				ivGreenC = ivGreenC + ivDitherValue;
				ivBlueC = ivBlueC + ivDitherValue;
				
				// perform shift
				//ivRedC >>= ( 16 );
				//ivGreenC >>= ( 16 );
				//ivBlueC >>= ( 16 );
				
				ivRedC = clamp ( ivRedC, 0, 255 << 16 );
				ivGreenC = clamp ( ivGreenC, 0, 255 << 16 );
				ivBlueC = clamp ( ivBlueC, 0, 255 << 16 );
				}

				// perform shift
				ivRedC >>= ( 16 );
				ivGreenC >>= ( 16 );
				ivBlueC >>= ( 16 );

				ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
				ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
				ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );
				}

#ifdef USE_MORE_JUMPS
					if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )
#endif
					{

					// semi-transparency
					//if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					//}
					ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 0x1f );
					ivGreenF = clamp( ivGreenB, 0, 0x1f );
					ivBlueF = clamp( ivBlueB, 0, 0x1f );

					//bvAlpha = notEqual( uvbgr & 0x8000, vZero );
					//ivRedF = mix( ivRedF, ivRedB, bvAlpha );
					//ivGreenF = mix( ivGreenF, ivGreenB, bvAlpha );
					//ivBlueF = mix( ivBlueF, ivBlueB, bvAlpha );
					}

					uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

					// no need to select based on command_abe since can just set shift to 16 and sign to zero
					uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
					

					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
					uvbgr_temp |= SetPixelMask | ( uvbgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;

					// only draw pixel if not key color (zero)
					uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );
					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ! ( DestPixel & PixelMask ) ) *ptr = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );

					// store pixels //
#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif

				//}
						
				ivR += ( dRx_across );
				ivG += ( dGx_across );
				ivB += ( dBx_across );
			
				ivU += ( dUx_across );
				ivV += ( dVx_across );
					
				//ptr += xinc;
				//iPtr += xinc;
				ivPtr += group_vxinc;
				
				
			}

			
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		Roff_left += ( dR_left * yinc );
		Goff_left += ( dG_left * yinc );
		Boff_left += ( dB_left * yinc );
		
		Uoff_left += ( dU_left * yinc );
		Voff_left += ( dV_left * yinc );
	}

	//} // end if ( EndY > StartY )

	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	

	}	// end if ( bDraw == 1 )


#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x34 && Comm <= 0x37 ) || ( Comm >= 0x3c && Comm <= 0x3f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	//barrier ();

#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
		
}




uint DrawTriangle_TextureGradient ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;


//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7:GetBGR0_8 ( Buffer [ 0 ] );
//8:GetXY0 ( Buffer [ 1 ] );
//9:GetCLUT ( Buffer [ 2 ] );
//9:GetUV0 ( Buffer [ 2 ] );
//10:GetBGR1_8 ( Buffer [ 3 ] );
//11:GetXY1 ( Buffer [ 4 ] );
//12:GetTPAGE ( Buffer [ 5 ] );
//12:GetUV1 ( Buffer [ 5 ] );
//13:GetBGR2_8 ( Buffer [ 6 ] );
//14:GetXY2 ( Buffer [ 7 ] );
//15:GetUV2 ( Buffer [ 8 ] );

	
	
	//global u16* private ptr;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	int Line;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;
	

	
	int xoff_left, xoff_right;
	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	//global u16* local ptr_texture;
	//global u16* local ptr_clut;
	
	int TexCoordX, TexCoordY;



//uint bgr16;
//uint bgr32;

//int w, h, xmax, ymax, ymax2;
//int x, y;

int group_yoffset;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;
uint GPU_CTRL_Read_DTD;
uint Command_TGE;

//uint color_add;
int clut_xoffset, clut_yoffset;
int clut_x, clut_y, tpage_tx, tpage_ty;
uint tpage_abr, tpage_tp, command_abr;

int StartX, EndX, StartY, EndY;

uint PixelMask, SetPixelMask;

int x0, x1, x2, y0, y1, y2;

int dx_left, dx_right;
int t0, t1, denominator;

int Coord0, Coord1, Coord2;


int gx [ 3 ], gy [ 3 ];
uint gbgr [ 3 ];

int x_left, x_right;
int LeftMostX, RightMostX;

int dR_left, dG_left, dB_left;
int dR_across, dG_across, dB_across;
int R_left, G_left, B_left;
int r0, r1, r2, g0, g1, g2, b0, b1, b2;

int Shift1, Shift2, And1, And2;
int TextureOffset;
int ClutOffset;

int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
int TWX, TWY, TWW, TWH;

int u0, v0, u1, v1, u2, v2;
int u, v;

int dU_left, dV_left;
int dU_across, dV_across;
int U_left, V_left;
int gu [ 3 ], gv [ 3 ];

int dUx_across;
int dVx_across;

int dRx_across;
int dGx_across;
int dBx_across;


	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;


	// setup vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;
		
	do
	{
		
		/*
		// no bitmaps in opencl ??
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		Command_TGE = ( inputdata [ uIndex + 7 ] >> 24 ) & 1;

		
		gbgr [ 0 ] = inputdata [ uIndex + 7 ] & 0x00ffffff;
		gbgr [ 1 ] = inputdata [ uIndex + 10 ] & 0x00ffffff;
		gbgr [ 2 ] = inputdata [ uIndex + 13 ] & 0x00ffffff;
		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 5 ) >> 21 );
		gx [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 21 ) >> 21 );
		gy [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 5 ) >> 21 );

		gu [ 0 ] = int( inputdata [ uIndex + 9 ] ) & 0xff;
		gu [ 1 ] = int( inputdata [ uIndex + 12 ] ) & 0xff;
		gu [ 2 ] = int( inputdata [ uIndex + 15 ] ) & 0xff;
		gv [ 0 ] = int( inputdata [ uIndex + 9 ] >> 8 ) & 0xff;
		gv [ 1 ] = int( inputdata [ uIndex + 12 ] >> 8 ) & 0xff;
		gv [ 2 ] = int( inputdata [ uIndex + 15 ] >> 8 ) & 0xff;

		
		//GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		
		
		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;
		
		Coord0 = 0;
		Coord1 = 1;
		Coord2 = 2;
		
		
		///////////////////////////////////
		// put top coordinates in x0,y0
		if ( gy [ Coord1 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord1;
			Coord1 = Temp;
		}
		
		if ( gy [ Coord2 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord2;
			Coord2 = Temp;
		}
		
		///////////////////////////////////////
		// put middle coordinates in x1,y1
		if ( gy [ Coord2 ] < gy [ Coord1 ] )
		{
			Temp = Coord1;
			Coord1 = Coord2;
			Coord2 = Temp;
		}
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		x2 = gx [ Coord2 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		y2 = gy [ Coord2 ];

		// get u,v coords
		u0 = gu [ Coord0 ];
		u1 = gu [ Coord1 ];
		u2 = gu [ Coord2 ];
		v0 = gv [ Coord0 ];
		v1 = gv [ Coord1 ];
		v2 = gv [ Coord2 ];

		// get rgb-values
		r0 = int( gbgr [ Coord0 ] ) & 0xff;
		r1 = int( gbgr [ Coord1 ] ) & 0xff;
		r2 = int( gbgr [ Coord2 ] ) & 0xff;
		g0 = int( gbgr [ Coord0 ] >> 8 ) & 0xff;
		g1 = int( gbgr [ Coord1 ] >> 8 ) & 0xff;
		g2 = int( gbgr [ Coord2 ] >> 8 ) & 0xff;
		b0 = int( gbgr [ Coord0 ] >> 16 ) & 0xff;
		b1 = int( gbgr [ Coord1 ] >> 16 ) & 0xff;
		b2 = int( gbgr [ Coord2 ] >> 16 ) & 0xff;
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 = DrawArea_OffsetX + x0;
		y0 = DrawArea_OffsetY + y0;
		x1 = DrawArea_OffsetX + x1;
		y1 = DrawArea_OffsetY + y1;
		x2 = DrawArea_OffsetX + x2;
		y2 = DrawArea_OffsetY + y2;
		
		
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );

		

		// bits 0-5 in upper halfword
		clut_x = int ( inputdata [ uIndex + 9 ] >> ( 16 + 0 ) ) & 0x3f;
		clut_y = int ( inputdata [ uIndex + 9 ] >> ( 16 + 6 ) ) & 0x1ff;

		
		
		TWY = int ( inputdata [ uIndex + 4 ] >> 15 ) & 0x1f;
		TWX = int ( inputdata [ uIndex + 4 ] >> 10 ) & 0x1f;
		TWH = int ( inputdata [ uIndex + 4 ] >> 5 ) & 0x1f;
		TWW = int ( inputdata [ uIndex + 4 ] ) & 0x1f;
		
		// bits 0-3
		//tpage_tx = int( GPU_CTRL_Read ) & 0xf;
		
		// bit 4
		//tpage_ty = int( GPU_CTRL_Read >> 4 ) & 1;
		
		
		// bits 5-6
		//GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		
		// bits 7-8
		//tpage_tp = int( GPU_CTRL_Read >> 7 ) & 3;



		tpage_tx = int( inputdata [ uIndex + 12 ] >> ( 16 + 0 ) ) & 0xf;
		tpage_ty = int( inputdata [ uIndex + 12 ] >> ( 16 + 4 ) ) & 1;
		tpage_abr = ( inputdata [ uIndex + 12 ] >> ( 16 + 5 ) ) & 3;
		tpage_tp = ( inputdata [ uIndex + 12 ] >> ( 16 + 7 ) ) & 3;


		
		Shift1 = 0;
		Shift2 = 0;
		And1 = 0;
		And2 = 0;


		TWYTWH = ( ( TWY & TWH ) << 3 );
		TWXTWW = ( ( TWX & TWW ) << 3 );
		
		
		Not_TWH = ~( TWH << 3 );
		Not_TWW = ~( TWW << 3 );

		
		
		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		ClutOffset = clut_y << 10;

		
		//////////////////////////////////////////////////////
		// Get offset into color lookup table
		
		clut_xoffset = clut_x << 4;
		
		if ( tpage_tp == 0 )
		{
			And2 = 0xf;
			
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			And2 = 0xff;
			
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}
		

		
		/////////////////////////////////////////////////
		// draw top part of triangle
		
		// denominator is negative when x1 is on the left, positive when x1 is on the right
		t0 = y1 - y2;
		t1 = y0 - y2;
		denominator = ( ( x0 - x2 ) * t0 ) - ( ( x1 - x2 ) * t1 );
		if ( denominator != 0 )
		{
			dR_across = ( ( ( ( ( r0 - r2 ) * t0 ) - ( ( r1 - r2 ) * t1 ) ) ) << 8 ) / denominator;
			dG_across = ( ( ( ( ( g0 - g2 ) * t0 ) - ( ( g1 - g2 ) * t1 ) ) ) << 8 ) / denominator;
			dB_across = ( ( ( ( ( b0 - b2 ) * t0 ) - ( ( b1 - b2 ) * t1 ) ) ) << 8 ) / denominator;
			
			dU_across = ( ( ( ( ( u0 - u2 ) * t0 ) - ( ( u1 - u2 ) * t1 ) ) ) << 8 ) / denominator;
			dV_across = ( ( ( ( ( v0 - v2 ) * t0 ) - ( ( v1 - v2 ) * t1 ) ) ) << 8 ) / denominator;
			
			dR_across <<= 8;
			dG_across <<= 8;
			dB_across <<= 8;
			
			dU_across <<= 8;
			dV_across <<= 8;
			
			dUx_across = dU_across * xinc;
			dVx_across = dV_across * xinc;

			dRx_across = dR_across * xinc;
			dGx_across = dG_across * xinc;
			dBx_across = dB_across * xinc;
		}
		
		
		
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
			if ( ( y1 - y0 ) != 0 )
			{
				/////////////////////////////////////////////
				// init x on the left and right
				x_left = ( x0 << 16 );
				x_right = x_left;
				
				R_left = ( r0 << 16 );
				G_left = ( g0 << 16 );
				B_left = ( b0 << 16 );

				U_left = ( u0 << 16 );
				V_left = ( v0 << 16 );
				
				if ( denominator < 0 )
				{
					//dx_left = ( ((s64)( x1 - x0 )) * r10 ) >> 32;
					//dx_right = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
					dx_left = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_left = divide_s32( ( ( x1 - x0 ) << 16 ), ( y1 - y0 ) );
					//dx_right = divide_s32( ( ( x2 - x0 ) << 16 ), ( y2 - y0 ) );
					
					dR_left = (( r1 - r0 ) << 16 ) / ( y1 - y0 );
					dG_left = (( g1 - g0 ) << 16 ) / ( y1 - y0 );
					dB_left = (( b1 - b0 ) << 16 ) / ( y1 - y0 );
					//dR_left = divide_s32( (( r1 - r0 ) << 16 ), ( y1 - y0 ) );
					//dG_left = divide_s32( (( g1 - g0 ) << 16 ), ( y1 - y0 ) );
					//dB_left = divide_s32( (( b1 - b0 ) << 16 ), ( y1 - y0 ) );
					
					dU_left = ( (( u1 - u0 ) << 16 ) ) / ( y1 - y0 );
					dV_left = ( (( v1 - v0 ) << 16 ) ) / ( y1 - y0 );
				}
				else
				{
					//dx_right = ( ((s64)( x1 - x0 )) * r10 ) >> 32;
					//dx_left = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
					dx_right = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_right = divide_s32( ( ( x1 - x0 ) << 16 ), ( y1 - y0 ) );
					//dx_left = divide_s32( ( ( x2 - x0 ) << 16 ), ( y2 - y0 ) );
					
					dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
					dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
					dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
					//dR_left = divide_s32( (( r2 - r0 ) << 16 ), ( y2 - y0 ) );
					//dG_left = divide_s32( (( g2 - g0 ) << 16 ), ( y2 - y0 ) );
					//dB_left = divide_s32( (( b2 - b0 ) << 16 ), ( y2 - y0 ) );
					
					dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
					dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
				}
			}
			else
			{
				if ( denominator < 0 )
				{
					// change x_left and x_right where y1 is on left
					x_left = ( x1 << 16 );
					x_right = ( x0 << 16 );
					
					R_left = ( r1 << 16 );
					G_left = ( g1 << 16 );
					B_left = ( b1 << 16 );

					U_left = ( u1 << 16 );
					V_left = ( v1 << 16 );
					
					if ( ( y2 - y1 ) != 0 )
					{
						//dx_left = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
						//dx_right = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
						dx_left = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						//dx_left = divide_s32( ( ( x2 - x1 ) << 16 ), ( y2 - y1 ) );
						//dx_right = divide_s32( ( ( x2 - x0 ) << 16 ), ( y2 - y0 ) );
						
						dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
						dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
						dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
						//dR_left = divide_s32( (( r2 - r1 ) << 16 ), ( y2 - y1 ) );
						//dG_left = divide_s32( (( g2 - g1 ) << 16 ), ( y2 - y1 ) );
						//dB_left = divide_s32( (( b2 - b1 ) << 16 ), ( y2 - y1 ) );
						
						dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
						dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
					}
				}
				else
				{
					x_right = ( x1 << 16 );
					x_left = ( x0 << 16 );
				
					R_left = ( r0 << 16 );
					G_left = ( g0 << 16 );
					B_left = ( b0 << 16 );
					
					U_left = ( u0 << 16 );
					V_left = ( v0 << 16 );
					
					if ( ( y2 - y1 ) != 0 )
					{
						//dx_right = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
						//dx_left = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
						dx_right = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						//dx_right = divide_s32( ( ( x2 - x1 ) << 16 ), ( y2 - y1 ) );
						//dx_left = divide_s32( ( ( x2 - x0 ) << 16 ), ( y2 - y0 ) );
						
						dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
						dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
						dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
						//dR_left = divide_s32( (( r2 - r0 ) << 16 ), ( y2 - y0 ) );
						//dG_left = divide_s32( (( g2 - g0 ) << 16 ), ( y2 - y0 ) );
						//dB_left = divide_s32( (( b2 - b0 ) << 16 ), ( y2 - y0 ) );
						
						dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
						dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
					}
				}
			}
		//}
		


	
		
		
		
		// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
		R_left |= ( 1 << 15 );
		G_left |= ( 1 << 15 );
		B_left |= ( 1 << 15 );

		U_left |= ( 1 << 15 );
		V_left |= ( 1 << 15 );

		//x_left += 0xffff;
		//x_right -= 1;
		
		StartY = y0;
		EndY = y1;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
			
			R_left += dR_left * Temp;
			G_left += dG_left * Temp;
			B_left += dB_left * Temp;
			
			U_left += dU_left * Temp;
			V_left += dV_left * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}


		bDraw = 1;		

	//}	// end if ( !local_id )
	
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	
	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	// check if sprite is within draw area
	if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || y2 <= DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;
	
	// skip drawing if distance between vertices is greater than max allowed by GPU
	//if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( x2 - x1 ) > c_MaxPolygonWidth ) || ( y1 - y0 > c_MaxPolygonHeight ) || ( y2 - y1 > c_MaxPolygonHeight ) )
	if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( y2- y0 ) > c_MaxPolygonHeight ) )
	{
		// skip drawing polygon
		//return;
		bDraw = 0;
	}
	*/

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];
		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];
		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];
		dR_across = data [ uIdx + 24 ];
		dG_across = data [ uIdx + 25 ];
		dB_across = data [ uIdx + 26 ];
		dU_across = data [ uIdx + 27 ];
		dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;

		dRx_across = dR_across * xinc;
		dGx_across = dG_across * xinc;
		dBx_across = dB_across * xinc;

		dUx_across = dU_across * xinc;
		dVx_across = dV_across * xinc;


		for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];
		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		R_left = data [ uIdx + 36 + uLoop ];
		G_left = data [ uIdx + 37 + uLoop ];
		B_left = data [ uIdx + 38 + uLoop ];
		dR_left = data [ uIdx + 39 + uLoop ];
		dG_left = data [ uIdx + 40 + uLoop ];
		dB_left = data [ uIdx + 41 + uLoop ];
		U_left = data [ uIdx + 42 + uLoop ];
		V_left = data [ uIdx + 43 + uLoop ];
		dU_left = data [ uIdx + 44 + uLoop ];
		dV_left = data [ uIdx + 45 + uLoop ];
		

		
		
	

	//if ( EndY > StartY )
	//{
	
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	Roff_left = R_left + ( dR_left * (yid) );
	Goff_left = G_left + ( dG_left * (yid) );
	Boff_left = B_left + ( dB_left * (yid) );
	
	Uoff_left = U_left + ( dU_left * (yid) );
	Voff_left = V_left + ( dV_left * (yid) );
	

	//////////////////////////////////////////////
	// draw down to y1
	//for ( Line = StartY; Line < EndY; Line++ )
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			iR = Roff_left;
			iG = Goff_left;
			iB = Boff_left;
			
			iU = Uoff_left;
			iV = Voff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
				
			}
			
			iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			iU += ( dU_across >> 8 ) * ( Temp >> 8 );
			iV += ( dV_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			iPtr = iStartX + xid + ( Line << 10 );

			//DitherLine = & ( DitherArray [ ( Line & 0x3 ) << 2 ] );
			
			
			iR += ( dR_across * xid );
			iG += ( dG_across * xid );
			iB += ( dB_across * xid );

			iU += ( dU_across * xid );
			iV += ( dV_across * xid );
			
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = StartX; x_across <= EndX; x_across += c_iVectorSize )
			for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			{
				
				TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				TexCoordY <<= 10;

				//TexCoordX = (u8) ( ( iU & ~( TWW << 3 ) ) | ( ( TWX & TWW ) << 3 ) );
				TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				
				if ( Shift1 != 0 )
				{
					//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
					bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				}

				
				if ( bgr != 0 )
				{
					
					// shade pixel color
					
					// read pixel from frame buffer if we need to check mask bit
					//DestPixel = *ptr;
					DestPixel = VRAM [ iPtr ];
					
					bgr_temp = bgr;
		
					
					if ( Command_TGE == 0 )
					{
						if ( GPU_CTRL_Read_DTD != 0 )
						{
							DitherValue = c_iDitherValues16 [ ( x_across & 3 ) + ( ( Line & 3 ) << 2 ) ];
							
							// perform dither
							Red = iR + DitherValue;
							Green = iG + DitherValue;
							Blue = iB + DitherValue;
							
							// perform shift
							Red >>= ( 16 );
							Green >>= ( 16 );
							Blue >>= ( 16 );
							
							//Red = Clamp5 ( Red );
							//Green = Clamp5 ( Green );
							//Blue = Clamp5 ( Blue );
							Red = clamp ( Red, 0, 255 );
							Green = clamp ( Green, 0, 255 );
							Blue = clamp ( Blue, 0, 255 );
						}
						else
						{
							Red = iR >> ( 16 );
							Green = iG >> ( 16 );
							Blue = iB >> ( 16 );
						}
						
						ucolor_add = ( Blue << 16 ) | ( Green << 8 ) | Red;

						// brightness calculation
						//bgr_temp = Color24To16 ( ColorMultiply24 ( Color16To24 ( bgr_temp ), color_add ) );
						bgr_temp = ColorMultiply1624 ( bgr_temp, ucolor_add );
					}
					
					
					// semi-transparency
					if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					{
						bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					}
					
					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ! ( DestPixel & PixelMask ) ) *ptr = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					
				}
						
				iR += ( dRx_across );
				iG += ( dGx_across );
				iB += ( dBx_across );
			
				iU += ( dUx_across );
				iV += ( dVx_across );
					
				//ptr += xinc;
				iPtr += xinc;
				
				
			}

			
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		Roff_left += ( dR_left * yinc );
		Goff_left += ( dG_left * yinc );
		Boff_left += ( dB_left * yinc );
		
		Uoff_left += ( dU_left * yinc );
		Voff_left += ( dV_left * yinc );
	}

	//} // end if ( EndY > StartY )

	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	
	/*
	//if ( ( xid + yid ) == 0 )
	//{
		//////////////////////////////////////////////////////
		// check if y1 is on the left or on the right
		if ( denominator < 0 )
		{
			x_left = ( x1 << 16 );

			x_right = ( x0 << 16 ) + ( dx_right * ( y1 - y0 ) );
			
			R_left = ( r1 << 16 );
			G_left = ( g1 << 16 );
			B_left = ( b1 << 16 );
			
			U_left = ( u1 << 16 );
			V_left = ( v1 << 16 );
			
			if ( ( y2 - y1 ) != 0 )
			{
				//dx_left = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
				dx_left = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				//dx_left = divide_s32( (( x2 - x1 ) << 16 ), ( y2 - y1 ) );
				
				//dR_left = ( ((s64)( r2 - r1 )) * r21 ) >> 24;
				//dG_left = ( ((s64)( g2 - g1 )) * r21 ) >> 24;
				//dB_left = ( ((s64)( b2 - b1 )) * r21 ) >> 24;
				dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
				dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
				dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
				//dR_left = divide_s32( (( r2 - r1 ) << 16 ), ( y2 - y1 ) );
				//dG_left = divide_s32( (( g2 - g1 ) << 16 ), ( y2 - y1 ) );
				//dB_left = divide_s32( (( b2 - b1 ) << 16 ), ( y2 - y1 ) );
				
				dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
				dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
			}
		}
		else
		{
			x_right = ( x1 << 16 );

			x_left = ( x0 << 16 ) + ( dx_left * ( y1 - y0 ) );
			
			R_left = ( r0 << 16 ) + ( dR_left * ( y1 - y0 ) );
			G_left = ( g0 << 16 ) + ( dG_left * ( y1 - y0 ) );
			B_left = ( b0 << 16 ) + ( dB_left * ( y1 - y0 ) );
			
			U_left = ( u0 << 16 ) + ( dU_left * ( y1 - y0 ) );
			V_left = ( v0 << 16 ) + ( dV_left * ( y1 - y0 ) );
			
			if ( ( y2 - y1 ) != 0 )
			{
				//dx_right = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
				dx_right = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				//dx_right = divide_s32( (( x2 - x1 ) << 16 ), ( y2 - y1 ) );
				
			}
		}


		R_left += ( 1 << 15 );
		G_left += ( 1 << 15 );
		B_left += ( 1 << 15 );

		U_left += ( 1 << 15 );
		V_left += ( 1 << 15 );
		

		
		StartY = y1;
		EndY = y2;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
			
			R_left += dR_left * Temp;
			G_left += dG_left * Temp;
			B_left += dB_left * Temp;
			
			U_left += dU_left * Temp;
			V_left += dV_left * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}
		
	//}
	*/

		/*
		StartY = data [ uIdx + 46 ];
		EndY = data [ uIdx + 47 ];
		x_left = data [ uIdx + 48 ];
		x_right = data [ uIdx + 49 ];
		dx_left = data [ uIdx + 50 ];
		dx_right = data [ uIdx + 51 ];
		R_left = data [ uIdx + 52 ];
		G_left = data [ uIdx + 53 ];
		B_left = data [ uIdx + 54 ];
		dR_left = data [ uIdx + 55 ];
		dG_left = data [ uIdx + 56 ];
		dB_left = data [ uIdx + 57 ];
		U_left = data [ uIdx + 58 ];
		V_left = data [ uIdx + 59 ];
		dU_left = data [ uIdx + 60 ];
		dV_left = data [ uIdx + 61 ];
		
	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	if ( EndY > StartY )
	{
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
	
	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	Roff_left = R_left + ( dR_left * (yid) );
	Goff_left = G_left + ( dG_left * (yid) );
	Boff_left = B_left + ( dB_left * (yid) );
	
	Uoff_left = U_left + ( dU_left * (yid) );
	Voff_left = V_left + ( dV_left * (yid) );
	

	//////////////////////////////////////////////
	// draw down to y2
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			iR = Roff_left;
			iG = Goff_left;
			iB = Boff_left;
			
			iU = Uoff_left;
			iV = Voff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
				
			}
			
			iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			iU += ( dU_across >> 8 ) * ( Temp >> 8 );
			iV += ( dV_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			iPtr = iStartX + xid + ( Line << 10 );

			//DitherLine = & ( DitherArray [ ( Line & 0x3 ) << 2 ] );
			
			
			
			iR += ( dR_across * xid );
			iG += ( dG_across * xid );
			iB += ( dB_across * xid );

			iU += ( dU_across * xid );
			iV += ( dV_across * xid );
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			{
				TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				TexCoordY <<= 10;

				//TexCoordX = (u8) ( ( iU & ~( TWW << 3 ) ) | ( ( TWX & TWW ) << 3 ) );
				TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				
				if ( Shift1 != 0 )
				{
					//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
					bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				}

				
				if ( bgr != 0 )
				{
					
					// shade pixel color
					
					// read pixel from frame buffer if we need to check mask bit
					//DestPixel = *ptr;
					DestPixel = VRAM [ iPtr ];
					
					bgr_temp = bgr;
		
					
					if ( Command_TGE == 0 )
					{
						if ( GPU_CTRL_Read_DTD != 0 )
						{
							DitherValue = c_iDitherValues16 [ ( x_across & 3 ) + ( ( Line & 3 ) << 2 ) ];
							
							// perform dither
							Red = iR + DitherValue;
							Green = iG + DitherValue;
							Blue = iB + DitherValue;
							
							// perform shift
							Red >>= ( 16 );
							Green >>= ( 16 );
							Blue >>= ( 16 );
							
							//Red = Clamp5 ( Red );
							//Green = Clamp5 ( Green );
							//Blue = Clamp5 ( Blue );
							Red = clamp ( Red, 0, 255 );
							Green = clamp ( Green, 0, 255 );
							Blue = clamp ( Blue, 0, 255 );
						}
						else
						{
							Red = iR >> ( 16 );
							Green = iG >> ( 16 );
							Blue = iB >> ( 16 );
						}
						
						ucolor_add = ( Blue << 16 ) | ( Green << 8 ) | Red;

						// brightness calculation
						//bgr_temp = Color24To16 ( ColorMultiply24 ( Color16To24 ( bgr_temp ), color_add ) );
						bgr_temp = ColorMultiply1624 ( bgr_temp, ucolor_add );
					}
					
					// semi-transparency
					if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					{
						bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					}
					
					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					
				}

					
				iR += ( dRx_across );
				iG += ( dGx_across );
				iB += ( dBx_across );
				
				iU += ( dUx_across );
				iV += ( dVx_across );
				
				//ptr += xinc;
				iPtr += xinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		Roff_left += ( dR_left * yinc );
		Goff_left += ( dG_left * yinc );
		Boff_left += ( dB_left * yinc );
		
		Uoff_left += ( dU_left * yinc );
		Voff_left += ( dV_left * yinc );
	}
	
	} // end if ( EndY > StartY )
	*/

	}	// end if ( bDraw == 1 )
	
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x34 && Comm <= 0x37 ) || ( Comm >= 0x3c && Comm <= 0x3f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );


	//return;
	return ( uIndex >> 4 ) - 1;
		
}




#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Texture ( uint uIndex )
#else
void vDrawTriangle_Texture ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;


	
	//global u16* private ptr;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	int Line;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;
	

	
	int xoff_left, xoff_right;
	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	//global u16* local ptr_texture;
	//global u16* local ptr_clut;
	
	int TexCoordX, TexCoordY;



//uint bgr16;
//uint bgr32;

//int w, h, xmax, ymax, ymax2;
//int x, y;

//int group_yoffset;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;
uint GPU_CTRL_Read_DTD;
uint Command_TGE;

//uint color_add;
int clut_xoffset, clut_yoffset;
int clut_x, clut_y, tpage_tx, tpage_ty;
uint tpage_abr, tpage_tp, command_abr;

int StartX, EndX, StartY, EndY;

uint PixelMask, SetPixelMask;

int x0, x1, x2, y0, y1, y2;

int dx_left, dx_right;
int t0, t1, denominator;

int Coord0, Coord1, Coord2;


int gx [ 3 ], gy [ 3 ];
uint gbgr [ 3 ];

uint bgr32;

int x_left, x_right;
int LeftMostX, RightMostX;

int dR_left, dG_left, dB_left;
int dR_across, dG_across, dB_across;
int R_left, G_left, B_left;
int r0, r1, r2, g0, g1, g2, b0, b1, b2;

int Shift1, Shift2, And1, And2;
int TextureOffset;
int ClutOffset;

int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
int TWX, TWY, TWW, TWH;

int u0, v0, u1, v1, u2, v2;
int u, v;

int dU_left, dV_left;
int dU_across, dV_across;
int U_left, V_left;
int gu [ 3 ], gv [ 3 ];

int dUx_across;
int dVx_across;

int dRx_across;
int dGx_across;
int dBx_across;


	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	uvec4 uvbgr, uvbgr2;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivTexCoordY;
	ivec4 ivTexCoordX;
	ivec4 ivU;
	ivec4 ivV;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;


	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;


	//barrier ();

	// setup vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;
		
#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];
		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];
		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];
		//dR_across = data [ uIdx + 24 ];
		//dG_across = data [ uIdx + 25 ];
		//dB_across = data [ uIdx + 26 ];
		dU_across = data [ uIdx + 27 ];
		dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;

		//dRx_across = dR_across * group_vxinc;
		//dGx_across = dG_across * group_vxinc;
		//dBx_across = dB_across * group_vxinc;

		dUx_across = dU_across * group_vxinc;
		dVx_across = dV_across * group_vxinc;

	if ( Command_TGE != 0 )
	{
		bgr32 = 0x00808080;
	}

	ivRedC = ivec4( ( bgr32 >> 0 ) & 0xff );
	ivGreenC = ivec4( ( bgr32 >> 8 ) & 0xff );
	ivBlueC = ivec4( ( bgr32 >> 16 ) & 0xff );

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( tpage_abr )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


		for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];
		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		//R_left = data [ uIdx + 36 + uLoop ];
		//G_left = data [ uIdx + 37 + uLoop ];
		//B_left = data [ uIdx + 38 + uLoop ];
		//dR_left = data [ uIdx + 39 + uLoop ];
		//dG_left = data [ uIdx + 40 + uLoop ];
		//dB_left = data [ uIdx + 41 + uLoop ];
		U_left = data [ uIdx + 42 + uLoop ];
		V_left = data [ uIdx + 43 + uLoop ];
		dU_left = data [ uIdx + 44 + uLoop ];
		dV_left = data [ uIdx + 45 + uLoop ];
		

		
		
	

	//if ( EndY > StartY )
	//{
	
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	//Roff_left = R_left + ( dR_left * (yid) );
	//Goff_left = G_left + ( dG_left * (yid) );
	//Boff_left = B_left + ( dB_left * (yid) );
	
	Uoff_left = U_left + ( dU_left * (yid) );
	Voff_left = V_left + ( dV_left * (yid) );
	

	//////////////////////////////////////////////
	// draw down to y1
	//for ( Line = StartY; Line < EndY; Line++ )
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			//iR = Roff_left;
			//iG = Goff_left;
			//iB = Boff_left;
			
			iU = Uoff_left;
			iV = Voff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
				
			}
			
			//iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			//iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			//iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			iU += ( dU_across >> 8 ) * ( Temp >> 8 );
			iV += ( dV_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( iStartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

			w = iEndX - iStartX + 1;


			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = iStartX + xid + ( Line << 10 );
			ivPtr = ( iStartX + vxid ) + ( Line << 10 );


			//DitherLine = & ( DitherArray [ ( Line & 0x3 ) << 2 ] );
			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );
			//ivR = iR + ( dR_across * vxid );
			//ivG = iG + ( dG_across * vxid );
			//ivB = iB + ( dB_across * vxid );

			//iU += ( dU_across * xid );
			//iV += ( dV_across * xid );
			ivU = iU + ( dU_across * vxid );
			ivV = iV + ( dV_across * vxid );
			
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );
				
				//TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				//TexCoordY <<= 10;
				//TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				ivTexCoordY = ( ( ( ivV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				ivTexCoordY <<= 10;
				ivTexCoordX = ( ( ( ivU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				// x-component should be shifted right 1 again since 2 pixels per?
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + ivTexCoordY;
				uvbgr[ 0 ] = VRAM [ ivIndex [ 0 ] ];
				uvbgr[ 1 ] = VRAM [ ivIndex [ 1 ] ];
				uvbgr[ 2 ] = VRAM [ ivIndex [ 2 ] ];
				uvbgr[ 3 ] = VRAM [ ivIndex [ 3 ] ];
				
#ifdef USE_MORE_JUMPS
				if ( Shift1 != 0 )
#endif
				{

				//if ( Shift1 != 0 )
				//{
				//	//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
				//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				//}
				ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );
				uvbgr2[0] = VRAM [ ivIndex [ 0 ] ];
				uvbgr2[1] = VRAM [ ivIndex [ 1 ] ];
				uvbgr2[2] = VRAM [ ivIndex [ 2 ] ];
				uvbgr2[3] = VRAM [ ivIndex [ 3 ] ];

				uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;
				}
				
				//if ( bgr != 0 )
				//{
					
					// shade pixel color
					
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
					uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
					uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
					uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif
					
					//bgr_temp = bgr;
		



				ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
				ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
				ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;

#ifdef USE_MORE_JUMPS
				if ( Command_TGE == 0 )
#endif
				{
				ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
				ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
				ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );
				}

#ifdef USE_MORE_JUMPS
					if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )
#endif
					{
					// semi-transparency
					//if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					//}
					ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 0x1f );
					ivGreenF = clamp( ivGreenB, 0, 0x1f );
					ivBlueF = clamp( ivBlueB, 0, 0x1f );
					}

					uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

					// no need to select based on command_abe since can just set shift to 16 and sign to zero
					uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
					
					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
					uvbgr_temp |= SetPixelMask | ( uvbgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;

					// only draw pixel if not key color (zero)
					uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );
					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ! ( DestPixel & PixelMask ) ) *ptr = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );

					// store pixels //
#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif

				//}
						
				//ivR += ( dRx_across );
				//ivG += ( dGx_across );
				//ivB += ( dBx_across );
			
				ivU += ( dUx_across );
				ivV += ( dVx_across );
					
				//ptr += xinc;
				//iPtr += xinc;
				ivPtr += group_vxinc;
				
				
			}

			
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		//Roff_left += ( dR_left * yinc );
		//Goff_left += ( dG_left * yinc );
		//Boff_left += ( dB_left * yinc );
		
		Uoff_left += ( dU_left * yinc );
		Voff_left += ( dV_left * yinc );
	}

	//} // end if ( EndY > StartY )

	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	

	}	// end if ( bDraw == 1 )
	
#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x34 && Comm <= 0x37 ) || ( Comm >= 0x3c && Comm <= 0x3f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	//barrier ();


#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}




uint DrawTriangle_Texture ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	int iPtr;


//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7:GetBGR0_8 ( Buffer [ 0 ] );
//8:GetXY0 ( Buffer [ 1 ] );
//9:GetCLUT ( Buffer [ 2 ] );
//9:GetUV0 ( Buffer [ 2 ] );
//10:GetBGR1_8 ( Buffer [ 3 ] );
//11:GetXY1 ( Buffer [ 4 ] );
//12:GetTPAGE ( Buffer [ 5 ] );
//12:GetUV1 ( Buffer [ 5 ] );
//13:GetBGR2_8 ( Buffer [ 6 ] );
//14:GetXY2 ( Buffer [ 7 ] );
//15:GetUV2 ( Buffer [ 8 ] );

	
	
	//global u16* private ptr;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	int Line;

	// more variables for gradient triangle
	//int iR, iG, iB;
	//int Roff_left, Goff_left, Boff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;
	

	
	int xoff_left, xoff_right;
	
	//int Red, Green, Blue;
	uint DestPixel;


	
	//global u16* local ptr_texture;
	//global u16* local ptr_clut;
	
	int TexCoordX, TexCoordY;

	
//uint bgr16;
//uint bgr32;

//int w, h, xmax, ymax, ymax2;
//int x, y;

int group_yoffset;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;
uint GPU_CTRL_Read_DTD;
uint Command_TGE;

uint color_add;
int clut_xoffset, clut_yoffset;
int clut_x, clut_y, tpage_tx, tpage_ty;
uint tpage_abr, tpage_tp, command_abr;

int StartX, EndX, StartY, EndY;

uint PixelMask, SetPixelMask;

int x0, x1, x2, y0, y1, y2;

int dx_left, dx_right;
int t0, t1, denominator;

int Coord0, Coord1, Coord2;


int gx [ 3 ], gy [ 3 ];
//uint gbgr [ 3 ];

int x_left, x_right;
int LeftMostX, RightMostX;

//int dR_left, dG_left, dB_left;
//int dR_across, dG_across, dB_across;
//int R_left, G_left, B_left;
//int r0, r1, r2, g0, g1, g2, b0, b1, b2;

int Shift1, Shift2, And1, And2;
int TextureOffset;
int ClutOffset;

int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
int TWX, TWY, TWW, TWH;

int u0, v0, u1, v1, u2, v2;
int u, v;

int dU_left, dV_left;
int dU_across, dV_across;
int U_left, V_left;
int gu [ 3 ], gv [ 3 ];

int dUx_across;
int dVx_across;


	uint Comm;
	int bDraw;
	uint uIdx;
	uint uLoop;

	// setup vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;
		
#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		/*
		// no bitmaps in opencl ??
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		Command_TGE = ( inputdata [ uIndex + 7 ] >> 24 ) & 1;

		
		//gbgr [ 0 ] = inputdata [ uIndex + 7 ] & 0x00ffffff;
		//gbgr [ 1 ] = inputdata [ uIndex + 10 ] & 0x00ffffff;
		//gbgr [ 2 ] = inputdata [ uIndex + 13 ] & 0x00ffffff;
		color_add = inputdata [ uIndex + 7 ] & 0x00ffffff;;

		if ( ( color_add & 0x00ffffff ) == 0x00808080 ) Command_TGE = 1;

		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 5 ) >> 21 );
		gx [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 21 ) >> 21 );
		gy [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 5 ) >> 21 );

		gu [ 0 ] = int( inputdata [ uIndex + 9 ] ) & 0xff;
		gu [ 1 ] = int( inputdata [ uIndex + 12 ] ) & 0xff;
		gu [ 2 ] = int( inputdata [ uIndex + 15 ] ) & 0xff;
		gv [ 0 ] = int( inputdata [ uIndex + 9 ] >> 8 ) & 0xff;
		gv [ 1 ] = int( inputdata [ uIndex + 12 ] >> 8 ) & 0xff;
		gv [ 2 ] = int( inputdata [ uIndex + 15 ] >> 8 ) & 0xff;

		
		//GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		
		// DTD is bit 9 in GPU_CTRL_Read
		//GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		
		
		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;
		
		Coord0 = 0;
		Coord1 = 1;
		Coord2 = 2;
		
		
		///////////////////////////////////
		// put top coordinates in x0,y0
		if ( gy [ Coord1 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord1;
			Coord1 = Temp;
		}
		
		if ( gy [ Coord2 ] < gy [ Coord0 ] )
		{
			Temp = Coord0;
			Coord0 = Coord2;
			Coord2 = Temp;
		}
		
		///////////////////////////////////////
		// put middle coordinates in x1,y1
		if ( gy [ Coord2 ] < gy [ Coord1 ] )
		{
			Temp = Coord1;
			Coord1 = Coord2;
			Coord2 = Temp;
		}
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		x2 = gx [ Coord2 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		y2 = gy [ Coord2 ];

		// get u,v coords
		u0 = gu [ Coord0 ];
		u1 = gu [ Coord1 ];
		u2 = gu [ Coord2 ];
		v0 = gv [ Coord0 ];
		v1 = gv [ Coord1 ];
		v2 = gv [ Coord2 ];

		// get rgb-values
		//r0 = int( gbgr [ Coord0 ] ) & 0xff;
		//r1 = int( gbgr [ Coord1 ] ) & 0xff;
		//r2 = int( gbgr [ Coord2 ] ) & 0xff;
		//g0 = int( gbgr [ Coord0 ] >> 8 ) & 0xff;
		//g1 = int( gbgr [ Coord1 ] >> 8 ) & 0xff;
		//g2 = int( gbgr [ Coord2 ] >> 8 ) & 0xff;
		//b0 = int( gbgr [ Coord0 ] >> 16 ) & 0xff;
		//b1 = int( gbgr [ Coord1 ] >> 16 ) & 0xff;
		//b2 = int( gbgr [ Coord2 ] >> 16 ) & 0xff;
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 = DrawArea_OffsetX + x0;
		y0 = DrawArea_OffsetY + y0;
		x1 = DrawArea_OffsetX + x1;
		y1 = DrawArea_OffsetY + y1;
		x2 = DrawArea_OffsetX + x2;
		y2 = DrawArea_OffsetY + y2;
		
		
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );

		
				

		// bits 0-5 in upper halfword
		clut_x = int ( inputdata [ uIndex + 9 ] >> ( 16 + 0 ) ) & 0x3f;
		clut_y = int ( inputdata [ uIndex + 9 ] >> ( 16 + 6 ) ) & 0x1ff;

		
		
		TWY = int ( inputdata [ uIndex + 4 ] >> 15 ) & 0x1f;
		TWX = int ( inputdata [ uIndex + 4 ] >> 10 ) & 0x1f;
		TWH = int ( inputdata [ uIndex + 4 ] >> 5 ) & 0x1f;
		TWW = int ( inputdata [ uIndex + 4 ] ) & 0x1f;
		
		// bits 0-3
		//tpage_tx = int( GPU_CTRL_Read ) & 0xf;
		
		// bit 4
		//tpage_ty = int( GPU_CTRL_Read >> 4 ) & 1;
		
		
		// bits 5-6
		//GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		
		// bits 7-8
		//tpage_tp = int( GPU_CTRL_Read >> 7 ) & 3;
		
		tpage_tx = int( inputdata [ uIndex + 12 ] >> ( 16 + 0 ) ) & 0xf;
		tpage_ty = int( inputdata [ uIndex + 12 ] >> ( 16 + 4 ) ) & 1;
		tpage_abr = ( inputdata [ uIndex + 12 ] >> ( 16 + 5 ) ) & 3;
		tpage_tp = ( inputdata [ uIndex + 12 ] >> ( 16 + 7 ) ) & 3;


		
		Shift1 = 0;
		Shift2 = 0;
		And1 = 0;
		And2 = 0;


		TWYTWH = ( ( TWY & TWH ) << 3 );
		TWXTWW = ( ( TWX & TWW ) << 3 );
		
		
		Not_TWH = ~( TWH << 3 );
		Not_TWW = ~( TWW << 3 );

		
		
		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		ClutOffset = clut_y << 10;

		
		//////////////////////////////////////////////////////
		// Get offset into color lookup table
		
		clut_xoffset = clut_x << 4;
		
		if ( tpage_tp == 0 )
		{
			And2 = 0xf;
			
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			And2 = 0xff;
			
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}
		

		
		/////////////////////////////////////////////////
		// draw top part of triangle
		
		// denominator is negative when x1 is on the left, positive when x1 is on the right
		t0 = y1 - y2;
		t1 = y0 - y2;
		denominator = ( ( x0 - x2 ) * t0 ) - ( ( x1 - x2 ) * t1 );
		if ( denominator != 0 )
		{
			//dR_across = ( ( ( ( ( r0 - r2 ) * t0 ) - ( ( r1 - r2 ) * t1 ) ) ) << 8 ) / denominator;
			//dG_across = ( ( ( ( ( g0 - g2 ) * t0 ) - ( ( g1 - g2 ) * t1 ) ) ) << 8 ) / denominator;
			//dB_across = ( ( ( ( ( b0 - b2 ) * t0 ) - ( ( b1 - b2 ) * t1 ) ) ) << 8 ) / denominator;
			
			dU_across = ( ( ( ( ( u0 - u2 ) * t0 ) - ( ( u1 - u2 ) * t1 ) ) ) << 8 ) / denominator;
			dV_across = ( ( ( ( ( v0 - v2 ) * t0 ) - ( ( v1 - v2 ) * t1 ) ) ) << 8 ) / denominator;
			
			//dR_across <<= 8;
			//dG_across <<= 8;
			//dB_across <<= 8;
			
			dU_across <<= 8;
			dV_across <<= 8;

			dUx_across = dU_across * xinc;
			dVx_across = dV_across * xinc;
		}
		
		
		
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
			if ( ( y1 - y0 ) != 0 )
			{
				/////////////////////////////////////////////
				// init x on the left and right
				x_left = ( x0 << 16 );
				x_right = x_left;
				
				//R_left = ( r0 << 16 );
				//G_left = ( g0 << 16 );
				//B_left = ( b0 << 16 );

				U_left = ( u0 << 16 );
				V_left = ( v0 << 16 );
				
				if ( denominator < 0 )
				{
					//dx_left = ( ((s64)( x1 - x0 )) * r10 ) >> 32;
					//dx_right = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
					dx_left = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					
					//dR_left = (( r1 - r0 ) << 16 ) / ( y1 - y0 );
					//dG_left = (( g1 - g0 ) << 16 ) / ( y1 - y0 );
					//dB_left = (( b1 - b0 ) << 16 ) / ( y1 - y0 );
					
					dU_left = ( (( u1 - u0 ) << 16 ) ) / ( y1 - y0 );
					dV_left = ( (( v1 - v0 ) << 16 ) ) / ( y1 - y0 );
				}
				else
				{
					//dx_right = ( ((s64)( x1 - x0 )) * r10 ) >> 32;
					//dx_left = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
					dx_right = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					
					//dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
					//dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
					//dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
					
					dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
					dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
				}
			}
			else
			{
				if ( denominator < 0 )
				{
					// change x_left and x_right where y1 is on left
					x_left = ( x1 << 16 );
					x_right = ( x0 << 16 );
					
					//R_left = ( r1 << 16 );
					//G_left = ( g1 << 16 );
					//B_left = ( b1 << 16 );

					U_left = ( u1 << 16 );
					V_left = ( v1 << 16 );
					
					if ( ( y2 - y1 ) != 0 )
					{
						//dx_left = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
						//dx_right = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
						dx_left = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						
						//dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
						//dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
						//dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
						
						dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
						dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
					}
				}
				else
				{
					x_right = ( x1 << 16 );
					x_left = ( x0 << 16 );
				
					//R_left = ( r0 << 16 );
					//G_left = ( g0 << 16 );
					//B_left = ( b0 << 16 );
					
					U_left = ( u0 << 16 );
					V_left = ( v0 << 16 );
					
					if ( ( y2 - y1 ) != 0 )
					{
						//dx_right = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
						//dx_left = ( ((s64)( x2 - x0 )) * r20 ) >> 32;
						dx_right = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						
						//dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
						//dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
						//dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
						
						dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
						dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
					}
				}
			}
		//}
		


	
		
		
		
		// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
		//R_left |= ( 1 << 15 );
		//G_left |= ( 1 << 15 );
		//B_left |= ( 1 << 15 );

		U_left |= ( 1 << 15 );
		V_left |= ( 1 << 15 );

		//x_left += 0xffff;
		//x_right -= 1;
		
		StartY = y0;
		EndY = y1;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
			
			//R_left += dR_left * Temp;
			//G_left += dG_left * Temp;
			//B_left += dB_left * Temp;
			
			U_left += dU_left * Temp;
			V_left += dV_left * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}

		
		bDraw = 1;

	//}	// end if ( !local_id )
	
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	
	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	// check if sprite is within draw area
	if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || y2 <= DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;
	
	// skip drawing if distance between vertices is greater than max allowed by GPU
	//if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( x2 - x1 ) > c_MaxPolygonWidth ) || ( y1 - y0 > c_MaxPolygonHeight ) || ( y2 - y1 > c_MaxPolygonHeight ) )
	if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( y2- y0 ) > c_MaxPolygonHeight ) )
	{
		// skip drawing polygon
		//return;
		bDraw = 0;
	}
	*/



		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		//GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		color_add = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		//GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];
		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];
		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];
		//dR_across = data [ uIdx + 24 ];
		//dG_across = data [ uIdx + 25 ];
		//dB_across = data [ uIdx + 26 ];
		dU_across = data [ uIdx + 27 ];
		dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;

		//dRx_across = dR_across * xinc;
		//dGx_across = dG_across * xinc;
		//dBx_across = dB_across * xinc;

		dUx_across = dU_across * xinc;
		dVx_across = dV_across * xinc;


		for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		{
		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];
		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		//R_left = data [ uIdx + 36 ];
		//G_left = data [ uIdx + 37 ];
		//B_left = data [ uIdx + 38 ];
		//dR_left = data [ uIdx + 39 ];
		//dG_left = data [ uIdx + 40 ];
		//dB_left = data [ uIdx + 41 ];
		U_left = data [ uIdx + 42 + uLoop ];
		V_left = data [ uIdx + 43 + uLoop ];
		dU_left = data [ uIdx + 44 + uLoop ];
		dV_left = data [ uIdx + 45 + uLoop ];
	
	
	

	//if ( EndY > StartY )
	//{
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
	
	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	//Roff_left = R_left + ( dR_left * (yid) );
	//Goff_left = G_left + ( dG_left * (yid) );
	//Boff_left = B_left + ( dB_left * (yid) );
	
	Uoff_left = U_left + ( dU_left * (yid) );
	Voff_left = V_left + ( dV_left * (yid) );
	

	//////////////////////////////////////////////
	// draw down to y1
	//for ( Line = StartY; Line < EndY; Line++ )
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			//iR = Roff_left;
			//iG = Goff_left;
			//iB = Boff_left;
			
			iU = Uoff_left;
			iV = Voff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
				
			}
			
			//iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			//iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			//iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			iU += ( dU_across >> 8 ) * ( Temp >> 8 );
			iV += ( dV_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			iPtr = iStartX + xid + ( Line << 10 );

			//DitherLine = & ( DitherArray [ ( Line & 0x3 ) << 2 ] );
			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );

			iU += ( dU_across * xid );
			iV += ( dV_across * xid );
			
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			{
				
				TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				TexCoordY <<= 10;

				//TexCoordX = (u8) ( ( iU & ~( TWW << 3 ) ) | ( ( TWX & TWW ) << 3 ) );
				TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				
				if ( Shift1 != 0 )
				{
					//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
					bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				}

				
				if ( bgr != 0 )
				{
					
					// shade pixel color
					
					// read pixel from frame buffer if we need to check mask bit
					//DestPixel = *ptr;
					DestPixel = VRAM [ iPtr ];
					
					bgr_temp = bgr;
		
					
					if ( Command_TGE == 0 )
					{
						//if ( GPU_CTRL_Read_DTD )
						//{
						//	DitherValue = c_iDitherValues16 [ ( x_across & 3 ) + ( ( Line & 3 ) << 2 ) ];
						//	
						//	// perform dither
						//	Red = iR + DitherValue;
						//	Green = iG + DitherValue;
						//	Blue = iB + DitherValue;
						//	
						//	// perform shift
						//	Red >>= ( 16 );
						//	Green >>= ( 16 );
						//	Blue >>= ( 16 );
						//	
						//	Red = clamp ( Red, 255 );
						//	Green = clamp ( Green, 0, 255 );
						//	Blue = clamp ( Blue, 0, 255 );
						//}
						//else
						//{
						//	Red = iR >> ( 16 );
						//	Green = iG >> ( 16 );
						//	Blue = iB >> ( 16 );
						//}
						//
						//color_add = ( Blue << 16 ) | ( Green << 8 ) | Red;

						// brightness calculation
						bgr_temp = ColorMultiply1624 ( bgr_temp, color_add );
					}
					
					
					// semi-transparency
					if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					{
						bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					}
					
					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ! ( DestPixel & PixelMask ) ) *ptr = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					
				}
						
				//iR += ( dR_across * xinc );
				//iG += ( dG_across * xinc );
				//iB += ( dB_across * xinc );
			
				//iU += ( dU_across * xinc );
				//iV += ( dV_across * xinc );
				iU += ( dUx_across );
				iV += ( dVx_across );
					
				//ptr += xinc;
				iPtr += xinc;
				
				
			}

			
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		//Roff_left += ( dR_left * yinc );
		//Goff_left += ( dG_left * yinc );
		//Boff_left += ( dB_left * yinc );
		
		Uoff_left += ( dU_left * yinc );
		Voff_left += ( dV_left * yinc );
	}

	//} // end if ( EndY > StartY )

	}	// end for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	
	/*
	//if ( ( xid + yid ) == 0 )
	//{
		//////////////////////////////////////////////////////
		// check if y1 is on the left or on the right
		if ( denominator < 0 )
		{
			x_left = ( x1 << 16 );

			x_right = ( x0 << 16 ) + ( dx_right * ( y1 - y0 ) );
			
			//R_left = ( r1 << 16 );
			//G_left = ( g1 << 16 );
			//B_left = ( b1 << 16 );
			
			U_left = ( u1 << 16 );
			V_left = ( v1 << 16 );
			
			if ( ( y2 - y1 ) != 0 )
			{
				//dx_left = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
				dx_left = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				
				//dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
				//dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
				//dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
				
				dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
				dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
			}
		}
		else
		{
			x_right = ( x1 << 16 );

			x_left = ( x0 << 16 ) + ( dx_left * ( y1 - y0 ) );
			
			//R_left = ( r0 << 16 ) + ( dR_left * ( y1 - y0 ) );
			//G_left = ( g0 << 16 ) + ( dG_left * ( y1 - y0 ) );
			//B_left = ( b0 << 16 ) + ( dB_left * ( y1 - y0 ) );
			
			U_left = ( u0 << 16 ) + ( dU_left * ( y1 - y0 ) );
			V_left = ( v0 << 16 ) + ( dV_left * ( y1 - y0 ) );
			
			if ( ( y2 - y1 ) != 0 )
			{
				//dx_right = ( ((s64)( x2 - x1 )) * r21 ) >> 32;
				dx_right = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				
			}
		}


		//R_left += ( 1 << 15 );
		//G_left += ( 1 << 15 );
		//B_left += ( 1 << 15 );

		U_left += ( 1 << 15 );
		V_left += ( 1 << 15 );
		

		
		StartY = y1;
		EndY = y2;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			x_left += dx_left * Temp;
			x_right += dx_right * Temp;
			
			//R_left += dR_left * Temp;
			//G_left += dG_left * Temp;
			//B_left += dB_left * Temp;
			
			U_left += dU_left * Temp;
			V_left += dV_left * Temp;
		}
		
		if ( EndY > DrawArea_BottomRightY )
		{
			EndY = DrawArea_BottomRightY + 1;
		}
		
	//}
	*/

		/*
		StartY = data [ uIdx + 46 ];
		EndY = data [ uIdx + 47 ];
		x_left = data [ uIdx + 48 ];
		x_right = data [ uIdx + 49 ];
		dx_left = data [ uIdx + 50 ];
		dx_right = data [ uIdx + 51 ];
		//R_left = data [ uIdx + 52 ];
		//G_left = data [ uIdx + 53 ];
		//B_left = data [ uIdx + 54 ];
		//dR_left = data [ uIdx + 55 ];
		//dG_left = data [ uIdx + 56 ];
		//dB_left = data [ uIdx + 57 ];
		U_left = data [ uIdx + 58 ];
		V_left = data [ uIdx + 59 ];
		dU_left = data [ uIdx + 60 ];
		dV_left = data [ uIdx + 61 ];


	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	if ( EndY > StartY )
	{
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
	
	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	//Roff_left = R_left + ( dR_left * (group_yoffset + yid) );
	//Goff_left = G_left + ( dG_left * (group_yoffset + yid) );
	//Boff_left = B_left + ( dB_left * (group_yoffset + yid) );

	Uoff_left = U_left + ( dU_left * (yid) );
	Voff_left = V_left + ( dV_left * (yid) );
	

	//////////////////////////////////////////////
	// draw down to y2
	for ( Line = StartY + yid; Line < EndY; Line += yinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			//iR = Roff_left;
			//iG = Goff_left;
			//iB = Boff_left;
			
			iU = Uoff_left;
			iV = Voff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
				
			}
			
			//iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			//iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			//iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			iU += ( dU_across >> 8 ) * ( Temp >> 8 );
			iV += ( dV_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
			xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			iPtr = iStartX + xid + ( Line << 10 );

			//DitherLine = & ( DitherArray [ ( Line & 0x3 ) << 2 ] );
			
			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );

			iU += ( dU_across * xid );
			iV += ( dV_across * xid );
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			{
				TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				TexCoordY <<= 10;

				//TexCoordX = (u8) ( ( iU & ~( TWW << 3 ) ) | ( ( TWX & TWW ) << 3 ) );
				TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				
				if ( Shift1 != 0 )
				{
					//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
					bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				}

				
				if ( bgr != 0 )
				{
					
					// shade pixel color
					
					// read pixel from frame buffer if we need to check mask bit
					//DestPixel = *ptr;
					DestPixel = VRAM [ iPtr ];
					
					bgr_temp = bgr;
		
					
					if ( Command_TGE == 0 )
					{
						
						//if ( GPU_CTRL_Read_DTD )
						//{
						//	DitherValue = c_iDitherValues16 [ ( x_across & 3 ) + ( ( Line & 3 ) << 2 ) ];
						//	
						//	// perform dither
						//	Red = iR + DitherValue;
						//	Green = iG + DitherValue;
						//	Blue = iB + DitherValue;
						//	
						//	// perform shift
						//	Red >>= ( 16 );
						//	Green >>= ( 16 );
						//	Blue >>= ( 16 );
						//	
						//	Red = clamp ( Red, 0, 255 );
						//	Green = clamp ( Green, 0, 255 );
						//	Blue = clamp ( Blue, 0, 255 );
						//}
						//else
						//{
						//	Red = iR >> ( 16 );
						//	Green = iG >> ( 16 );
						//	Blue = iB >> ( 16 );
						//}
						//
						//color_add = ( Blue << 16 ) | ( Green << 8 ) | Red;
						

						// brightness calculation
						bgr_temp = ColorMultiply1624 ( bgr_temp, color_add );
					}
					
					// semi-transparency
					if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					{
						bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					}
					
					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					
				}

					
				//iR += ( dR_across * xinc );
				//iG += ( dG_across * xinc );
				//iB += ( dB_across * xinc );
				
				//iU += ( dU_across * xinc );
				//iV += ( dV_across * xinc );
				iU += ( dUx_across );
				iV += ( dVx_across );
				
				//ptr += xinc;
				iPtr += xinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * yinc );
		xoff_right += ( dx_right * yinc );
		
		//Roff_left += ( dR_left * yinc );
		//Goff_left += ( dG_left * yinc );
		//Boff_left += ( dB_left * yinc );
		
		Uoff_left += ( dU_left * yinc );
		Voff_left += ( dV_left * yinc );
	}
	
	} // end if ( EndY > StartY )
	*/

	}	// end if ( bDraw == 1 )

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x24 && Comm <= 0x27 ) || ( Comm >= 0x2c && Comm <= 0x2f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


	return ( uIndex >> 4 ) - 1;
}




#ifdef ENABLE_PRIMITIVE_LOOP
uint Transfer_MoveImage_80 ( uint uIndex )
#else
void Transfer_MoveImage_80 ( uint uIndex )
#endif
{

	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );
	

	uint SrcPixel, DstPixel;
	uint DestPixel;
	
	int CurX, CurY;
	//global u16* private SrcPtr;
	//global u16* private DstPtr;
	//global u16* private SrcLinePtr;
	//global u16* private DstLinePtr;
	int iSrcPtr;
	int iDstPtr;
	int iSrcLinePtr;
	int iDstLinePtr;


	uint GPU_CTRL_Read;
	int w;
	int h;
	int Width;
	int Height;
	int sX;
	int sY;
	int dX;
	int dY;

	uint PixelMask;
	uint SetPixelMask;
	int SrcStartX;
	int DstStartX;
	int SrcStartY;
	int DstStartY;

	uint Comm;
	
	//if ( (xid + yid) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		w = int( inputdata [ uIndex + 10 ] );
		h = w >> 16;

		// Xsiz=((Xsiz-1) AND 3FFh)+1
		Width = ( ( w - 1 ) & 0x3ff ) + 1;
		
		// Ysiz=((Ysiz-1) AND 1FFh)+1
		Height = ( ( h - 1 ) & 0x1ff ) + 1;

		
		sX = int( inputdata [ uIndex + 8 ] );
		sY = sX >> 16;
		dX = int( inputdata [ uIndex + 9 ] );
		dY = dX >> 16;

		// nocash psx specifications: transfer/move vram-to-vram use masking
		// ME is bit 12
		//if ( GPU_CTRL_Read.ME ) PixelMask = 0x8000;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		//if ( GPU_CTRL_Read.MD ) SetPixelMask = 0x8000;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;
		
		// xpos & 0x3ff
		//sX &= 0x3ff;
		SrcStartX = sX & 0x3ff;
		//dX &= 0x3ff;
		DstStartX = dX & 0x3ff;
		
		// ypos & 0x1ff
		//sY &= 0x1ff;
		SrcStartY = sY & 0x1ff;
		//dY &= 0x1ff;
		DstStartY = dY & 0x1ff;
		
		
		// *** NOTE: coordinates wrap *** //
		
		//SrcXRun = c_lFrameBuffer_Width - SrcStartX;
		//SrcXRun = ( Width <= SrcXRun ) ? Width : SrcXRun;
		
		//DstXRun = c_lFrameBuffer_Width - DstStartX;
		//DstXRun = ( Width <= DstXRun ) ? Width : DstXRun;
		
		//Width1 = ( SrcXRun < DstXRun ) ? SrcXRun : DstXRun;
		//Width2 = ( SrcXRun > DstXRun ) ? SrcXRun : DstXRun;
	
	//}
	
	barrier ();
	
	for ( CurY = yid; CurY < Height; CurY += yinc )
	{
		// start Src/Dst pointers for line
		//SrcLinePtr = & ( VRAM [ ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10 ] );
		//DstLinePtr = & ( VRAM [ ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10 ] );
		iSrcLinePtr = ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		iDstLinePtr = ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		
		for ( CurX = xid; CurX < Width; CurX += xinc )
		{
			iSrcPtr = iSrcLinePtr + ( ( SrcStartX + CurX ) & c_lFrameBuffer_Width_Mask );
			iDstPtr = iDstLinePtr + ( ( DstStartX + CurX ) & c_lFrameBuffer_Width_Mask );

			//SrcPixel = VRAM [ iSrcPtr ];
			//DstPixel = VRAM [ iDstPtr ];

			//if ( ( DstPixel & PixelMask ) == 0 ) sVRAM [ iDstPtr ] = ( SrcPixel | SetPixelMask );
			sVRAM [ iDstPtr ] = VRAM [ iSrcPtr ];
		}

	}

	barrier ();

	for ( CurY = yid; CurY < Height; CurY += yinc )
	{
		// start Src/Dst pointers for line
		//iSrcLinePtr = ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		iDstLinePtr = ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		
		for ( CurX = xid; CurX < Width; CurX += xinc )
		{
			//iSrcPtr = iSrcLinePtr + ( ( SrcStartX + CurX ) & c_lFrameBuffer_Width_Mask );
			iDstPtr = iDstLinePtr + ( ( DstStartX + CurX ) & c_lFrameBuffer_Width_Mask );

			SrcPixel = sVRAM [ iDstPtr ];
			DstPixel = VRAM [ iDstPtr ];
			SrcPixel |= SetPixelMask;

			//if ( ( DstPixel & PixelMask ) == 0 ) VRAM [ iDstPtr ] = ( SrcPixel | SetPixelMask );

			VRAM [ iDstPtr ] = ( ( ( DstPixel & PixelMask ) == 0 ) ? SrcPixel : DstPixel );
		}

	}


	//}	// end if local_id

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( Comm == 0x80 ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	// this need to be complete first before proceeding
	barrier ();

#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}







#ifdef ENABLE_PIXELIN_BUFFER
void TransferPixelPacketIn ( uint uIndex )
#else
uint TransferPixelPacketIn ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	//int xid = int( gl_GlobalInvocationID.x );
	//int yid = int( gl_GlobalInvocationID.y );
	



	uint bgr2;
	uint pix0, pix1;
	uint DestPixel;
	uint Data;

	
	//int iX, iY;
	int CurX, CurY;

	int iPtr;
	int iCount;
	
	int xxpixel;
	int xximagepixel;


	uint GPU_CTRL_Read;
	int dX;
	int dY;
	int w;
	int h;
	int sX;
	int sY;
	
	int BS;

	uint uStartIndex;

	int xximagepixelstart;
	uint PixelMask;
	uint SetPixelMask;
	uint Comm;



	uIndex <<= 4;

	
	//if ( xxid == 0 )
	//{

		//Count = 0;

		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		dX = int( inputdata [ uIndex + 1 ] );
		dY = int( inputdata [ uIndex + 2 ] );
		w = int( inputdata [ uIndex + 3 ] );
		h = int( inputdata [ uIndex + 4 ] );
		//iX = int( inputdata [ uIndex + 5 ] );
		//iY = int( inputdata [ uIndex + 6 ] );
		sX = int( inputdata [ uIndex + 5 ] );
		sY = int( inputdata [ uIndex + 6 ] );
		
		BS = int( inputdata [ uIndex + 7 ] & 0xf );

		// count is per 2 pixels
		BS <<= 1;
		
		xximagepixelstart = sX + sY * w;

		// nocash psx specifications: transfer/move vram-to-vram use masking
		// ME is bit 12
		//if ( GPU_CTRL_Read.ME ) PixelMask = 0x8000;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		//if ( GPU_CTRL_Read.MD ) SetPixelMask = 0x8000;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

#ifdef ENABLE_PIXELIN_BUFFER

		uStartIndex = inputdata [ uIndex + 9 ];

		BS = int( inputdata [ uIndex + 10 ] );

		// count is per 2 pixels
		BS <<= 1;

#else
		Comm = inputdata [ uIndex + 7 ];

		SharedYMax = BS;
		if( BS == 16 )
		{
			SharedYMax = ( xxinc << 4 );
		}
	//}
#endif


	barrier ();


#ifdef ENABLE_PIXELIN_BUFFER

	for ( iCount = xxid; iCount < BS; iCount += xxinc )
	{

		//pix0 = inputdata [ uIndex + ( iCount & ~0xf ) + 8 + ( ( iCount & 0xf ) >> 1 ) ];
		pix0 = PixelInput32 [ uStartIndex + ( iCount >> 1 ) ];

		pix0 = ( pix0 >> ( ( iCount & 1 ) << 4 ) ) & 0xffff;
		pix0 |= SetPixelMask;

		// need the pixel count in the image ( sX + sY * w )
		xximagepixel = iCount + xximagepixelstart;

		CurX = xximagepixel % w;
		CurY = xximagepixel / w;

		iPtr = ( (dX + CurX) & 0x3ff ) + ( ( (dY + CurY) & 0x1ff ) << 10 );

		// read pixel from frame buffer if we need to check mask bit
		DestPixel = VRAM [ iPtr ];

		//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( pix0 | SetPixelMask );

		VRAM [ iPtr ] = ( ( ( DestPixel & PixelMask ) == 0 ) ? pix0 : DestPixel );
	}

#else	

	// check for conditions that don't match the transfer
	// need BS=8,Comm=command,sX and sY !=0
	if ( BS == 16 )
	{
		//Comm2 = inputdata [ uIndex + ( ( xxid + 1 ) << 4 ) + 7 ];

		if (
			(
			Comm != inputdata [ uIndex + ( ( xxid + 1 ) << 4 ) + 7 ]
			&& Comm ==  inputdata [ uIndex + ( ( xxid + 0 ) << 4 ) + 7 ]
			)
			||
			( ( uIndex + ( ( xxid + 1 ) << 4 ) ) >= ( 1 << ( 16 + 4 ) ) )
		)
		{
			atomicMin ( SharedYMax, ( xxid + 1 ) << 4 );
			//SharedYMax = ( xxid + 1 ) << 4;
		}
	}

	barrier ();

	for ( iCount = xxid; iCount < SharedYMax; iCount += xxinc )
	{
		pix0 = inputdata [ uIndex + ( iCount & ~0xf ) + 8 + ( ( iCount & 0xf ) >> 1 ) ];

		pix0 = ( pix0 >> ( ( iCount & 1 ) << 4 ) ) & 0xffff;
		pix0 |= SetPixelMask;

		// need the pixel count in the image ( sX + sY * w )
		xximagepixel = iCount + xximagepixelstart;

		CurX = xximagepixel % w;
		CurY = xximagepixel / w;

		iPtr = ( (dX + CurX) & 0x3ff ) + ( ( (dY + CurY) & 0x1ff ) << 10 );

		// read pixel from frame buffer if we need to check mask bit
		DestPixel = VRAM [ iPtr ];

		//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( pix0 | SetPixelMask );

		VRAM [ iPtr ] = ( ( ( DestPixel & PixelMask ) == 0 ) ? pix0 : DestPixel );
	}
	
#endif
	

	// this needs to be complete before proceeding
	barrier ();
	
#ifdef ENABLE_PIXELIN_BUFFER
	return;
#else
	return ( ( uIndex >> 4 ) + ( ( SharedYMax + 0xf ) >> 4 ) - 1 );
#endif
}



void main ()
{
	uint uIdx;
	uint uCommand;
	uint uIndex;
	//uint uTargetIndex;
	//uint iInputMask;

	// sometimes want to arrange things in the x direction only
	uint xxid = gl_LocalInvocationIndex;


	uint xid = gl_GlobalInvocationID.x;
	uint yid = gl_GlobalInvocationID.y;


	group_x = int( gl_WorkGroupID.x );
	group_y = int( gl_WorkGroupID.y );
	group_xcount = int( gl_NumWorkGroups.x );
	group_ycount = int( gl_NumWorkGroups.y );


	group_xshift = findLSB( group_xcount );
	group_yshift = findLSB( group_ycount );

	// get the increments
	//if ( xid + yid == 0 )
	//{
		xinc = int( gl_WorkGroupSize.x );
		yinc = int( gl_WorkGroupSize.y );
		xxinc = int( gl_WorkGroupSize.x ) * int( gl_WorkGroupSize.y );
	//}

	group_xinc = ( xinc << group_xshift );
	group_yinc = ( yinc << group_yshift );

	group_xmask = group_xinc - 1;
	group_ymask = group_yinc - 1;


	// for vector operations -> vector will be going in x-direction
	// 4 components per vector
	group_vxinc = group_xinc << 2;
	group_vxmask = group_vxinc - 1;


	//barrier ();

	precompute_data ();


	// for now, set next index to zero
	uIndex = 0;



	while ( uIndex < ( 1 << 16 ) )
	{
		
		// get the next command
		uCommand = inputdata [ ( uIndex << 4 ) + 7 ] >> 24;


		if ( uCommand == 0x02 )
		{
			//Draw_FrameBufferRectangle_02 ( uIndex );
			vDraw_FrameBufferRectangle_02 ( uIndex );
		}
		else if ( uCommand < 0x40 )
		{
			// triangle //

			if ( ( uCommand & 0x10 ) == 0 )
			{
				// mono //
				if ( ( uCommand & 0x04 ) == 0 )
				{
					// color //

#ifdef ENABLE_PRIMITIVE_LOOP
					//uIndex = DrawTriangle_Mono ( uIndex );
					uIndex = vDrawTriangle_Mono ( uIndex );
#else
					vDrawTriangle_Mono ( uIndex );
#endif
				}
				else
				{
					// texture //

#ifdef ENABLE_PRIMITIVE_LOOP
					//uIndex = DrawTriangle_Texture ( uIndex );
					uIndex = vDrawTriangle_Texture ( uIndex );
#else
					vDrawTriangle_Texture ( uIndex );
#endif
				}
			}
			else
			{
				// gradient //
				if ( ( uCommand & 0x04 ) == 0 )
				{
					// color //

#ifdef ENABLE_PRIMITIVE_LOOP
					//uIndex = DrawTriangle_Gradient ( uIndex );
					uIndex = vDrawTriangle_Gradient ( uIndex );
#else
					vDrawTriangle_Gradient ( uIndex );
#endif
				}
				else
				{
					// texture //

#ifdef ENABLE_PRIMITIVE_LOOP
					//uIndex = DrawTriangle_TextureGradient ( uIndex );
					uIndex = vDrawTriangle_TextureGradient ( uIndex );
#else
					vDrawTriangle_TextureGradient ( uIndex );
#endif
				}
			}
		}
		else if ( uCommand < 0x60 )
		{
			// line //
			if ( ( uCommand & 0x10 ) == 0 )
			{
				// mono //

				//Draw_Line ( uIndex );
				vDraw_Line ( uIndex );
			}
			else
			{
				// gradient //

				//Draw_Line_Gradient ( uIndex );
				vDraw_Line_Gradient ( uIndex );
			}
		}
		else if ( uCommand < 0x80 )
		{
			// rectangle/sprite //
			if ( ( uCommand & 0x04 ) == 0 )
			{
				// rectangle //
				
#ifdef ENABLE_PRIMITIVE_LOOP
				//uIndex = Draw_Rectangle_60 ( uIndex );
				uIndex = vDraw_Rectangle_60 ( uIndex );
#else
				vDraw_Rectangle_60 ( uIndex );
#endif
			}
			else
			{
				// sprite //

#ifdef ENABLE_PRIMITIVE_LOOP
				//uIndex = Draw_Sprite_64 ( uIndex );
				uIndex = vDraw_Sprite_64 ( uIndex );
#else
				vDraw_Sprite_64 ( uIndex );
#endif
			}
		}
		else if ( uCommand < 0xa0 )
		{
			// move //

#ifdef ENABLE_PRIMITIVE_LOOP
			uIndex = Transfer_MoveImage_80 ( uIndex );
#else
			Transfer_MoveImage_80 ( uIndex );
#endif
		}
		else if ( uCommand < 0xf0 )
		{
			// import //
#ifdef ENABLE_PIXELIN_BUFFER
			TransferPixelPacketIn ( uIndex );
#else
			uIndex = TransferPixelPacketIn ( uIndex );
#endif
		}
		else if ( uCommand < 0xff )
		{
			// command 0xfe
			draw_screen ( uIndex );
		}
		else
		{
			// done //
			barrier ();

			// invalidate all the entries
			for ( uIdx = xxid; uIdx < uIndex; uIdx += xxinc )
			{
				inputdata [ ( uIdx << 4 ) + 7 ] = -1;
			}

			return;
		}
		



		uIndex++;
	}

	barrier ();	

	// invalidate all the entries
	for ( uIdx = xxid; uIdx < uIndex; uIdx += xxinc )
	{
		inputdata [ ( uIdx << 4 ) + 7 ] = -1;
	}

	return;

}

)"