#version 450 core


//#define ENABLE_PRIMITIVE_LOOP
//#define USE_MORE_JUMPS
//#define USE_VECTOR_LOADSTORE

// draw with each shader unit on its own scanline
#define USE_NEW_SCANLINE_DRAW_TRANSFER
#define USE_NEW_SCANLINE_DRAW_MOVE
#define USE_NEW_SCANLINE_DRAW_CLEAR
#define USE_NEW_SCANLINE_DRAW_VARS
#define USE_NEW_SCANLINE_DRAW_RECTANGLE
#define USE_NEW_SCANLINE_DRAW_SPRITE
#define USE_NEW_SCANLINE_DRAW_TRIANGLE


//#define USE_NEW_SYNC_BEFORE_RUN
//#define USE_NEW_SYNC_BEFORE_SETUP
//#define USE_NEW_SYNC_BEFORE_TRANSFER
//#define USE_NEW_SYNC_BEFORE_MOVE
//#define USE_NEW_SYNC_BEFORE_DRAW

//#define USE_SHORTER_OBJECT_LIST

//#define ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT


#define SYNC_BEFORE_TRANSFER
#define SYNC_AFTER_TRANSFER
#define SYNC_BEFORE_MOVE
#define SYNC_AFTER_MOVE


layout (local_size_x = 16, local_size_y = 16) in;

layout (std430, binding = 0) restrict buffer sCmd {
	// the input commands to draw
	int data [ 128 * ( 1 << 16 ) ];
};

layout (std430, binding = 1) restrict buffer Cmd {
	// the input commands to draw
	uint inputdata [ 16 * ( 1 << 16 ) ];
};

layout (std430, binding = 3) buffer FrameBuf {

// the shader representation of vram
uint VRAM [ 1024 * 512 ];

};

layout (std430, binding = 3) buffer FrameBuf4 {

// the shader representation of vram
uvec4 VRAM4 [ ( 1024 * 512 ) >> 2 ];

};


layout (std430, binding = 4) restrict buffer ShadowFrameBuf {

// the shader representation of vram
uint sVRAM [ 1024 * 512 ];

};

layout (std430, binding = 2) restrict buffer ScreenBuf {
// the display window
uint pixelbuffer32 [ 1024 * 512 ];
};


layout (std430, binding = 5) restrict buffer InputPixels {
// the display window
uint PixelInput32 [ 1 << 20 ];
};


layout (binding = 5,rgba8) restrict writeonly uniform image2D destTex;


const int c_iDitherValues16 [] = { -4 << 16, 0 << 16, -3 << 16, 1 << 16,
								2 << 16, -2 << 16, 3 << 16, -1 << 16,
								-3 << 16, 1 << 16, -4 << 16, 0 << 16,
								3 << 16, -1 << 16, 2 << 16, -2 << 16 };

//shared int c_iDitherValues16 [ 16 ];

const int c_MaxPolygonWidth = 1023;
const int c_MaxPolygonHeight = 511;

const int c_lFrameBuffer_Width = 1024;
const int c_lFrameBuffer_Height = 512;
const int c_lFrameBuffer_Width_Mask = 1023;
const int c_lFrameBuffer_Height_Mask = 511;

shared int xinc;
shared int yinc;
shared int xxinc;

shared int xxmask;

shared int group_x, group_y;
shared int group_xcount, group_ycount;
shared int group_xinc, group_yinc;
shared int group_xshift, group_yshift;
shared int group_xmask, group_ymask;

shared int group_vxinc;
shared int group_vxmask;

shared int group_vyinc;

shared int group_yoffset;


#define intdivf(op1, op2, fp1, fp2, fpout) (int(( ( float( (op1) ) / float( 1 << (fp1) ) ) / ( float( (op2) ) / float( 1 << (fp2) ) ) ) * float(1 << (fpout))))
#define intdivd(op1, op2, fp1, fp2, fpout) (int(( ( double( (op1) ) / double( 1 << (fp1) ) ) / ( double( (op2) ) / double( 1 << (fp2) ) ) ) * double(1 << (fpout))))

#define intdivfv2(op1, op2, fp1, fp2, fpout) (ivec2( ( vec2( (op1) ) / vec2( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivfv3(op1, op2, fp1, fp2, fpout) (ivec3( ( vec3( (op1) ) / float( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivfv4(op1, op2, fp1, fp2, fpout) (ivec4( ( vec4( (op1) ) / float( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))

#define intdivdv2(op1, op2, fp1, fp2, fpout) (ivec2( ( dvec2( (op1) ) / double( (op2) ) ) * double( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivdv3(op1, op2, fp1, fp2, fpout) (ivec3( ( dvec3( (op1) ) / double( (op2) ) ) * double( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivdv4(op1, op2, fp1, fp2, fpout) (ivec4( ( dvec4( (op1) ) / double( (op2) ) ) * double( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))

//shared uint bgr16;
//shared uint bgr32;

//shared int w, h, xmax, ymax, ymax2;
//shared int x, y;



//shared uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
//shared int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
//shared int DrawArea_OffsetX, DrawArea_OffsetY;
//shared uint Command_ABE;

//shared uint PixelMask, SetPixelMask;




shared int sX, dX, sY, dY;
shared int SrcStartX, SrcStartY, DstStartX, DstStartY, Height, Width, SrcXRun, DstXRun, Width1, Width2;

shared int BS, Count;

//shared uint Comm;
shared int SharedYMax, xximagepixelstart;

shared uint GPU_CTRL_Read;
shared int DisplayRange_X1;
shared int DisplayRange_X2;
shared int DisplayRange_Y1;
shared int DisplayRange_Y2;
shared int ScreenArea_TopLeftX;
shared int ScreenArea_TopLeftY;
shared int bEnableScanline;
shared int Y_Pixel;

// need to know visible range of screen for NTSC and for PAL (each should be different)
// NTSC visible y range is usually from 16-256 (0x10-0x100) (height=240)
// PAL visible y range is usually from 35-291 (0x23-0x123) (height=256)
// NTSC visible x range is.. I don't know. start with from about gpu cycle#544 to about gpu cycle#3232 (must use gpu cycles since res changes)
shared int VisibleArea_StartX, VisibleArea_EndX, VisibleArea_StartY, VisibleArea_EndY, VisibleArea_Width, VisibleArea_Height;
// this allows you to calculate horizontal pixels
shared int GPU_CyclesPerPixel;
// need to know where to draw the actual image at
shared int Draw_StartX, Draw_StartY, Draw_EndX, Draw_EndY, Draw_Width, Draw_Height;

shared int Source_Height;
shared int TopBorder_Height, BottomBorder_Height, LeftBorder_Width, RightBorder_Width;
shared int current_width, current_height, current_size, current_xmax, current_ymax;

shared uint GPU_CTRL_Read_ISINTER;
shared uint GPU_CTRL_Read_HEIGHT;
shared uint GPU_CTRL_Read_WIDTH;
shared uint GPU_CTRL_Read_DEN;
shared uint GPU_CTRL_Read_ISRGB24;
shared uint GPU_CTRL_Read_VIDEO;



void prelist_data ()
{
	int xxid = int( gl_LocalInvocationIndex );

	int yid;

	int iIdx;
	int iIndex;
	int iStartY, iEndY;

	uint Comm;

	const uint Offset = ( 1 << 16 ) * 64;

	const uint Stride = 4096;

	iIdx = 0;

	// loop through each object
	for ( iIndex = 0; iIndex < ( 1 << 16 ); iIndex++ )
	{
		// get the command
		Comm = inputdata [ ( iIndex << 4 ) + 7 ] >> 24;

		// check if it is a render draw
		if ( ( Comm > 0x02 ) && ( Comm < 0x80 ) )
		{
			// drop in the lines for now
			if ( ( Comm >= 0x40 ) && ( Comm < 0x60 ) )
			{
				// drop command in list for now
				data [ Offset + ( xxid << 12 ) + iIdx ] = iIndex;
				iIdx++;
			}
			else
			{
				// get start and end y
				iStartY = data [ ( iIndex << 6 ) + 30 ];
				iEndY = data [ ( iIndex << 6 ) + 47 ];

				// check that shader line is between start and end
				yid = ( xxid - iStartY ) & xxmask;

				if ( ( iStartY + yid ) <= iEndY )
				{
					data [ Offset + ( xxid << 12 ) + iIdx ] = iIndex;
					iIdx++;
				}
			}

		}
		else
		{
			// drop command in list for now
			data [ Offset + ( xxid << 12 ) + iIdx ] = iIndex;
			iIdx++;

		}

		// terminate loop if 0xff
		if ( Comm == 0xff )
		{
			break;
		}
	}

}


void precompute_data ()
{
	//const int iDataCount = ( 1 << 16 );
	//const int iDataElementSize = 128;
	//const int iDataShift = 7;

	int xxid = int( gl_LocalInvocationIndex );

	uint uIdx;
	uint uIndex;

	uint Comm;
	uint CommPrev, CommNext;

	uint bgr32;
	uint bgr16;
	//int x0, x1, x2;
	//int y0, y1, y2;
	int w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	//int u0;
	//int v0;
	
	// bits 0-5 in upper halfword
	int clut_x;
	int clut_y;

	int TWY;
	int TWX;
	int TWH;
	int TWW;
		
	int tpage_tx;
	int tpage_ty;
	int tpage_tp;
	int Shift1;
	int Shift2;
	int And1;
	int And2;
	int TWYTWH;
	int TWXTWW;
	int Not_TWH;
	int Not_TWW;
	int TextureOffset;
	int ClutOffset;
	int clut_xoffset;

	uint Command_TGE;

	int Temp;
	uint GPU_CTRL_Read_DTD;

	int tpage_abr;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	ivec4 x, dx, gt;

	int Coord0, Coord1, Coord2;

	ivec4 Coord;

	//int gx [ 3 ], gy [ 3 ];
	//uint gbgr [ 3 ];
	ivec4 gx, gy;
	uvec4 gbgr;

	int x_left, x_right;
	int LeftMostX, RightMostX;

	int dR_left, dG_left, dB_left;
	int dR_across, dG_across, dB_across;
	int R_left, G_left, B_left;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	ivec4 C_left, dC_left;
	ivec4 grgb0, grgb1, grgb2;
	ivec4 gr, gg, gb;
	ivec4 dC_across;

	int u0, v0, u1, v1, u2, v2;
	int dU_left, dV_left;
	int dU_across, dV_across;
	int U_left, V_left;
	//int gu [ 3 ], gv [ 3 ];
	ivec4 gu, gv;

	ivec4 T_left, dT_left;
	ivec4 guv0, guv1, guv2;
	ivec4 dT_across;

	int bDraw;

	// need to know if object is textured or not
	int bTexture;


	// loop through data
	uIndex = xxid << 4;

	// need to make this first list 64 per element instead of 128
	//uIdx = xxid << 7;
	uIdx = xxid << 6;

	do
	{

		Comm = inputdata [ uIndex + 7 ] >> 24;


#ifdef USE_NEW_SYNC_BEFORE_SETUP
		// TODO
		// index 62 should be a conditional barrier
		// so that if it is like a transfer-in or frame-buffer-fill and the previous was a render command, then it would set a barrier before the transfer-in
		CommPrev = 0;
		if ( uIndex != 0 )
		{
			CommPrev = inputdata [ uIndex + 7 - 16 ] >> 24;
		}
		//CommNext = inputdata [ uIndex + 7 + 16 ] >> 24;

		// TODO: if current and previous are render draw, sync if the draw window/framebuffer changes

		// if previous was a render draw and current is something different, then current should have a sync before
		//if ( CommPrev > 0x02 && CommPrev < 0x80 )
		//{
		//	if ( Comm == 0x02 || Comm >= 0x80 )
		//	{
		//		// need to synchronize before //
		//		data [ uIdx + 62 ] = 1;
		//	}
		//}

		data [ uIdx + 62 ] = 0;

#ifdef USE_NEW_SYNC_BEFORE_DRAW
		// if current is render draw and previous was something different, then sync before
		if ( Comm > 0x02 && Comm < 0x80 )
		{
			if ( CommPrev == 0x02 || CommPrev >= 0x80 )
			{
				// need to synchronize before //
				data [ uIdx + 62 ] = 1;
			}
		}
#endif

#ifdef USE_NEW_SYNC_BEFORE_TRANSFER
		// current is transfer-in and previous was something different, then sync before
		if ( ( Comm == 0x02 ) || ( Comm >= 0xa0 && Comm < 0xf0 ) )
		{
			if ( ( CommPrev > 0x02 && CommPrev < 0xa0 ) || ( CommPrev >= 0xf0 ) )
			{
				// need to synchronize before //
				data [ uIdx + 62 ] = 1;
			}
		}
#endif

#ifdef USE_NEW_SYNC_BEFORE_MOVE
		// all moves for now should sync before
		if ( Comm >= 0x80 && Comm < 0xa0 )
		{
			// need to synchronize before //
			data [ uIdx + 62 ] = 1;
		}
#endif


#endif


		// pre compute common data //
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];

		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		bgr32 = inputdata [ uIndex + 7 ] & 0x00ffffff;
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );

		bDraw = 1;
		
		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			//return;
			bDraw = 0;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			//return;
			bDraw = 0;
		}


		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;

		Command_TGE = ( inputdata [ uIndex + 7 ] >> 24 ) & 1;

		// bits 0-5 in upper halfword
		clut_x = int ( inputdata [ uIndex + 9 ] >> ( 16 + 0 ) ) & 0x3f;
		clut_y = int ( inputdata [ uIndex + 9 ] >> ( 16 + 6 ) ) & 0x1ff;

		//////////////////////////////////////////////////////
		// Get offset into color lookup table
		ClutOffset = clut_y << 10;
		clut_xoffset = clut_x << 4;

		TWY = int ( inputdata [ uIndex + 4 ] >> 15 ) & 0x1f;
		TWX = int ( inputdata [ uIndex + 4 ] >> 10 ) & 0x1f;
		TWH = int ( inputdata [ uIndex + 4 ] >> 5 ) & 0x1f;
		TWW = int ( inputdata [ uIndex + 4 ] ) & 0x1f;

		TWYTWH = ( ( TWY & TWH ) << 3 );
		TWXTWW = ( ( TWX & TWW ) << 3 );
		
		Not_TWH = ~( TWH << 3 );
		Not_TWW = ~( TWW << 3 );

		Shift1 = 0;
		Shift2 = 0;
		And1 = 0;
		And2 = 0;

		// whether object is textured or not
		bTexture = int( Comm & 0x4 );


		if ( ( Comm >= 0x60 ) && ( Comm <= 0x7f ) )
		{

		// strictly for 2d objects //

		// bits 0-3
		tpage_tx = int( GPU_CTRL_Read ) & 0xf;
		
		// bit 4
		tpage_ty = int( GPU_CTRL_Read >> 4 ) & 1;
		
		// bits 7-8
		tpage_tp = int( GPU_CTRL_Read >> 7 ) & 3;
		

		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		
		if ( tpage_tp == 0 )
		{
			And2 = 0xf;
			
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			And2 = 0xff;
			
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}



		x0 = int( inputdata [ uIndex + 8 ] );
		y0 = x0 >> 16;
		
		// x and y are actually 11 bits
		x0 = ( x0 << ( 5 + 16 ) ) >> ( 5 + 16 );
		y0 = ( y0 << ( 5 + 16 ) ) >> ( 5 + 16 );

		// pixel/rectangle/sprite only //

		
		
		w = int( inputdata [ uIndex + 10 ] );
		h = w >> 16;

		//w &= 0xffff;
		//h &= 0xffff;
		w &= 0x3ff;
		h &= 0x1ff;
		
		// get top left corner of sprite and bottom right corner of sprite
		x0 = x0 + DrawArea_OffsetX;
		y0 = y0 + DrawArea_OffsetY;

		// when using combined renderer, don't subtract one for 2d
		//x1 = x0 + w - 1;
		//y1 = y0 + h - 1;
		x1 = x0 + w;
		y1 = y0 + h;


		StartX = x0;
		EndX = x1;
		StartY = y0;
		EndY = y1;

		
		// check if sprite is within draw area
		if ( x1 < DrawArea_TopLeftX || x0 > DrawArea_BottomRightX || y1 < DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;


		u0 = int ( inputdata [ uIndex + 9 ] );
		v0 = u0 >> 8;

		// get rid of any junk data
		u0 &= 0xff;
		v0 &= 0xff;

		//if ( StartY < DrawArea_TopLeftY )
		//{
		//	v0 += ( DrawArea_TopLeftY - StartY );
		//	StartY = DrawArea_TopLeftY;
		//}
		v0 += ( DrawArea_TopLeftY - min( StartY, DrawArea_TopLeftY ) );
		StartY = max( StartY, DrawArea_TopLeftY );

		
		//if ( EndY > DrawArea_BottomRightY )
		//{
		//	// when using combined renderer, need to add 1
		//	//EndY = DrawArea_BottomRightY;
		//	EndY = DrawArea_BottomRightY + 1;
		//}
		EndY = min( EndY, DrawArea_BottomRightY + 1 );

		
		//if ( StartX < DrawArea_TopLeftX )
		//{
		//	u0 += ( DrawArea_TopLeftX - StartX );
		//	StartX = DrawArea_TopLeftX;
		//}
		u0 += ( DrawArea_TopLeftX - min( StartX, DrawArea_TopLeftX ) );
		StartX = max( StartX, DrawArea_TopLeftX );

		
		//if ( EndX > DrawArea_BottomRightX )
		//{
		//	//EndX = DrawArea_BottomRightX;
		//	EndX = DrawArea_BottomRightX + 1;
		//}
		EndX = min( EndX, DrawArea_BottomRightX + 1 );


		if ( ( bgr32 & 0x00ffffff ) == 0x00808080 ) Command_TGE = 1;

		
		// if textured and tge==1, then bgr32 = 0x00808080
		if ( ( ( Comm & 0x4 ) != 0 ) && ( Command_TGE == 1 ) )
		{
			bgr32 = 0x00808080;
		}

		// bDraw
		// GPU_CTRL_Read_ABR,Command_ABE,Command_TGE,PixelMask,SetPixelMask
		// bgr32,bgr16
		// StartX,EndX,StartY,EndY
		// Shift1,Shift2,And1,And2
		// u0,v0
		// TWYTWH,TWXTWW,Not_TWH,Not_TWW
		// TextureOffset,ClutOffset,clut_xoffset
		data [ uIdx + 0 ] = bDraw;
		data [ uIdx + 1 ] = int( PixelMask );
		data [ uIdx + 2 ] = int( SetPixelMask );
		data [ uIdx + 3 ] = int( GPU_CTRL_Read_ABR );
		data [ uIdx + 4 ] = int( Command_ABE );
		data [ uIdx + 5 ] = int( Command_TGE );
		data [ uIdx + 6 ] = int( bgr32 );
		data [ uIdx + 7 ] = int( bgr16 );

		data [ uIdx + 8 ] = int( GPU_CTRL_Read_DTD );

		data [ uIdx + 9 ] = StartX;
		data [ uIdx + 10 ] = EndX;
		data [ uIdx + 11 ] = EndY;

		data [ uIdx + 12 ] = Shift1;
		data [ uIdx + 13 ] = Shift2;
		data [ uIdx + 14 ] = And1;
		data [ uIdx + 15 ] = And2;

		data [ uIdx + 16 ] = TWYTWH;
		data [ uIdx + 17 ] = TWXTWW;
		data [ uIdx + 18 ] = Not_TWH;
		data [ uIdx + 19 ] = Not_TWW;
		data [ uIdx + 20 ] = TextureOffset;
		data [ uIdx + 21 ] = ClutOffset;
		data [ uIdx + 22 ] = clut_xoffset;

		// for 2d use gpu ctrl abr instead of tpage abr
		data [ uIdx + 23 ] = int( GPU_CTRL_Read_ABR );	//tpage_abr;


		data [ uIdx + 24 ] = 0;	//dR_across;
		data [ uIdx + 25 ] = 0;	//dG_across;
		data [ uIdx + 26 ] = 0;	//dB_across;
		data [ uIdx + 27 ] = 1 << 16;	//dU_across;
		data [ uIdx + 28 ] = 0;	//dV_across;


		data [ uIdx + 29 ] = bTexture;


		data [ uIdx + 30 ] = StartY;
		data [ uIdx + 31 ] = EndY;
		data [ uIdx + 32 ] = StartX << 16;	//x_left;
		data [ uIdx + 33 ] = EndX << 16;	//x_right;
		data [ uIdx + 34 ] = 0;	//dx_left;
		data [ uIdx + 35 ] = 0;	//dx_right;
		data [ uIdx + 36 ] = int( bgr32 & 0xff ) << 16;	//R_left;
		data [ uIdx + 37 ] = int( ( bgr32 >> 8 ) & 0xff ) << 16;	//G_left;
		data [ uIdx + 38 ] = int( ( bgr32 >> 16 ) & 0xff ) << 16;	//B_left;
		data [ uIdx + 39 ] = 0;	//dR_left;
		data [ uIdx + 40 ] = 0;	//dG_left;
		data [ uIdx + 41 ] = 0;	//dB_left;
		data [ uIdx + 42 ] = u0 << 16;	//U_left;
		data [ uIdx + 43 ] = v0 << 16;	//V_left;
		data [ uIdx + 44 ] = 0;	//dU_left;
		data [ uIdx + 45 ] = 1 << 16;	//dV_left;

		data [ uIdx + 46 ] = StartY;
		data [ uIdx + 47 ] = EndY;
		data [ uIdx + 48 ] = StartX << 16;	//x_left;
		data [ uIdx + 49 ] = EndX << 16;	//x_right;
		data [ uIdx + 50 ] = 0;	//dx_left;
		data [ uIdx + 51 ] = 0;	//dx_right;
		data [ uIdx + 52 ] = int( bgr32 & 0xff ) << 16;	//R_left;
		data [ uIdx + 53 ] = int( ( bgr32 >> 8 ) & 0xff ) << 16;	//G_left;
		data [ uIdx + 54 ] = int( ( bgr32 >> 16 ) & 0xff ) << 16;	//B_left;
		data [ uIdx + 55 ] = 0;	//dR_left;
		data [ uIdx + 56 ] = 0;	//dG_left;
		data [ uIdx + 57 ] = 0;	//dB_left;
		data [ uIdx + 58 ] = u0 << 16;	//U_left;
		data [ uIdx + 59 ] = v0 << 16;	//V_left;
		data [ uIdx + 60 ] = 0;	//dU_left;
		data [ uIdx + 61 ] = 1 << 16;	//dV_left;


		// loop max at 16
		data [ uIdx + 63 ] = 16;


		}


		if ( ( Comm >= 0x20 ) && ( Comm <= 0x3f ) )
		{

		// strictly for 3d objects //
	// -----------------------------------------------

		//gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		//gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		//gx [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 21 ) >> 21 );
		//gy [ 1 ] = ( ( int( inputdata [ uIndex + 11 ] ) << 5 ) >> 21 );
		//gx [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 21 ) >> 21 );
		//gy [ 2 ] = ( ( int( inputdata [ uIndex + 14 ] ) << 5 ) >> 21 );
		gx.x = int( inputdata [ uIndex + 8 ] );
		gx.y = int( inputdata [ uIndex + 11 ] );
		gx.z = int( inputdata [ uIndex + 14 ] );
		gy = ( gx << 5 ) >> 21;
		//gx = ( gx << 21 ) >> 21;

		//Coord0 = 0;
		//Coord1 = 1;
		//Coord2 = 2;
		Coord.xyz = ivec3( 0, 1, 2 );

		///////////////////////////////////
		// put top coordinates in x0,y0
		Coord.xyz = ( gy [ Coord.y ] < gy [ Coord.x ] ) ? Coord.yxz : Coord.xyz;
		Coord.xyz = ( gy [ Coord.z ] < gy [ Coord.x ] ) ? Coord.zyx : Coord.xyz;
		Coord.xyz = ( gy [ Coord.z ] < gy [ Coord.y ] ) ? Coord.xzy : Coord.xyz;
		Coord.xyz *= 3;

		//gbgr [ 0 ] = inputdata [ uIndex + 7 ] & 0x00ffffff;
		//gbgr [ 1 ] = inputdata [ uIndex + 10 ] & 0x00ffffff;
		//gbgr [ 2 ] = inputdata [ uIndex + 13 ] & 0x00ffffff;
		gbgr.x = inputdata [ uIndex + 7 + Coord.x ];
		gbgr.y = inputdata [ uIndex + 7 + Coord.y ];
		gbgr.z = inputdata [ uIndex + 7 + Coord.z ];
		gbgr &= 0x00ffffff;

		gx.x = int( inputdata [ uIndex + 8 + Coord.x ] );
		gx.y = int( inputdata [ uIndex + 8 + Coord.y ] );
		gx.z = int( inputdata [ uIndex + 8 + Coord.z ] );
		gy = ( gx << 5 ) >> 21;
		gx = ( gx << 21 ) >> 21;

		//gu [ 0 ] = int( inputdata [ uIndex + 9 ] ) & 0xff;
		//gu [ 1 ] = int( inputdata [ uIndex + 12 ] ) & 0xff;
		//gu [ 2 ] = int( inputdata [ uIndex + 15 ] ) & 0xff;
		//gv [ 0 ] = int( inputdata [ uIndex + 9 ] >> 8 ) & 0xff;
		//gv [ 1 ] = int( inputdata [ uIndex + 12 ] >> 8 ) & 0xff;
		//gv [ 2 ] = int( inputdata [ uIndex + 15 ] >> 8 ) & 0xff;
		gu.x = int( inputdata [ uIndex + 9 + Coord.x ] );
		gu.y = int( inputdata [ uIndex + 9 + Coord.y ] );
		gu.z = int( inputdata [ uIndex + 9 + Coord.z ] );
		gv = ( gu >> 8 ) & 0xff;
		gu &= 0xff;
		
		//GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		
		// if not gradient, then all colors the same as first color
		if ( ( Comm & 0x10 ) == 0 )
		{
			//gbgr[1] = gbgr[0];
			//gbgr[2] = gbgr[0];
			gbgr = uvec4( bgr32 );
		}

		// if textured and tge==1, then bgr32 = 0x00808080
		if ( ( ( Comm & 0x4 ) != 0 ) && ( Command_TGE == 1 ) )
		{
			//gbgr[0] = 0x00808080;
			//gbgr[1] = 0x00808080;
			//gbgr[2] = 0x00808080;
			gbgr = uvec4( 0x00808080 );

			// also means no dithering on the texture
			GPU_CTRL_Read_DTD = 0;
		}


		// get rgb values
		gr = ivec4( gbgr ) & 0xff;
		gg = ivec4( gbgr >> 8 ) & 0xff;
		gb = ivec4( gbgr >> 16 ) & 0xff;
		
		//////////////////////////////////////////
		// get coordinates on screen
		//x0 = DrawArea_OffsetX + x0;
		//y0 = DrawArea_OffsetY + y0;
		//x1 = DrawArea_OffsetX + x1;
		//y1 = DrawArea_OffsetY + y1;
		//x2 = DrawArea_OffsetX + x2;
		//y2 = DrawArea_OffsetY + y2;
		gx += DrawArea_OffsetX;
		gy += DrawArea_OffsetY;
		
		
		// get the left/right most x
		//LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		//RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		LeftMostX = ( ( gx.x < gx.y ) ? gx.x : gx.y );
		LeftMostX = ( ( gx.z < LeftMostX ) ? gx.z : LeftMostX );
		RightMostX = ( ( gx.x > gx.y ) ? gx.x : gx.y );
		RightMostX = ( ( gx.z > RightMostX ) ? gx.z : RightMostX );


		tpage_tx = int( inputdata [ uIndex + 12 ] >> ( 16 + 0 ) ) & 0xf;
		tpage_ty = int( inputdata [ uIndex + 12 ] >> ( 16 + 4 ) ) & 1;
		tpage_abr = int( inputdata [ uIndex + 12 ] >> ( 16 + 5 ) ) & 3;
		tpage_tp = int( inputdata [ uIndex + 12 ] >> ( 16 + 7 ) ) & 3;


		// if not textured, then tpage abr is instead GPU_CTRL_Read_ABR
		if ( ( ( Comm & 0x4 ) == 0 ) )
		{
			tpage_abr = int( GPU_CTRL_Read_ABR );
		}



		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		
		if ( tpage_tp == 0 )
		{
			And2 = 0xf;
			
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			And2 = 0xff;
			
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}
		

		// transpose values
		grgb0.rgb = ivec3( gr.x, gg.x, gb.x );
		grgb1.rgb = ivec3( gr.y, gg.y, gb.y );
		grgb2.rgb = ivec3( gr.z, gg.z, gb.z );

		guv0.xy = ivec2( gu.x, gv.x );
		guv1.xy = ivec2( gu.y, gv.y );
		guv2.xy = ivec2( gu.z, gv.z );

		
		/////////////////////////////////////////////////
		// draw top part of triangle
		
		// denominator is negative when x1 is on the left, positive when x1 is on the right
		//t0 = y1 - y2;
		//t1 = y0 - y2;
		//denominator = ( ( x0 - x2 ) * t0 ) - ( ( x1 - x2 ) * t1 );
		gt.xy = gy.yx - gy.zz;
		denominator = ( ( gx.x - gx.z ) * gt.x ) - ( ( gx.y - gx.z ) * gt.y );
		if ( denominator != 0 )
		{
			/*
			dR_across = ( ( ( ( ( r0 - r2 ) * t0 ) - ( ( r1 - r2 ) * t1 ) ) ) << 8 ) / denominator;
			dG_across = ( ( ( ( ( g0 - g2 ) * t0 ) - ( ( g1 - g2 ) * t1 ) ) ) << 8 ) / denominator;
			dB_across = ( ( ( ( ( b0 - b2 ) * t0 ) - ( ( b1 - b2 ) * t1 ) ) ) << 8 ) / denominator;
			
			dU_across = ( ( ( ( ( u0 - u2 ) * t0 ) - ( ( u1 - u2 ) * t1 ) ) ) << 8 ) / denominator;
			dV_across = ( ( ( ( ( v0 - v2 ) * t0 ) - ( ( v1 - v2 ) * t1 ) ) ) << 8 ) / denominator;
			
			dR_across <<= 8;
			dG_across <<= 8;
			dB_across <<= 8;
			
			dU_across <<= 8;
			dV_across <<= 8;
			*/

			//dR_across = intdivd( ( ( ( ( ( gr.x - gr.z ) * gt.x ) - ( ( gr.y - gr.z ) * gt.y ) ) ) ), denominator, 0, 0, 16 );
			//dG_across = intdivd( ( ( ( ( ( gg.x - gg.z ) * gt.x ) - ( ( gg.y - gg.z ) * gt.y ) ) ) ), denominator, 0, 0, 16 );
			//dB_across = intdivd( ( ( ( ( ( gb.x - gb.z ) * gt.x ) - ( ( gb.y - gb.z ) * gt.y ) ) ) ), denominator, 0, 0, 16 );
			dC_across.rgb = intdivdv3( ( ( grgb0.rgb - grgb2.rgb ) * gt.x ) - ( ( grgb1.rgb - grgb2.rgb ) * gt.y ) , denominator, 0, 0, 16 );
			
			//dU_across = intdivd( ( ( ( ( ( gu.x - gu.z ) * gt.x ) - ( ( gu.y - gu.z ) * gt.y ) ) ) ), denominator, 0, 0, 16 );
			//dV_across = intdivd( ( ( ( ( ( gv.x - gv.z ) * gt.x ) - ( ( gv.y - gv.z ) * gt.y ) ) ) ), denominator, 0, 0, 16 );
			dT_across.xy = intdivdv2( ( ( guv0.xy - guv2.xy ) * gt.x ) - ( ( guv1.xy - guv2.xy ) * gt.y ), denominator, 0, 0, 16 );
		}
		
		
		
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
			//if ( ( y1 - y0 ) != 0 )
			if ( ( gy.y - gy.x ) != 0 )
			{
				/////////////////////////////////////////////
				// init x on the left and right
				//x_left = ( x0 << 16 );
				//x_right = x_left;
				x.xy = gx.xx << 16;
				
				//R_left = ( r0 << 16 );
				//G_left = ( g0 << 16 );
				//B_left = ( b0 << 16 );
				C_left.rgb = grgb0.rgb << 16;

				//U_left = ( u0 << 16 );
				//V_left = ( v0 << 16 );
				T_left.xy = guv0.xy << 16;
				
				if ( denominator < 0 )
				{
					//dx_left = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					//dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					dx.xy = ( ( gx.yz - gx.xx ) << 16 ) / ( gy.yz - gy.xx );
					
					//dR_left = (( r1 - r0 ) << 16 ) / ( y1 - y0 );
					//dG_left = (( g1 - g0 ) << 16 ) / ( y1 - y0 );
					//dB_left = (( b1 - b0 ) << 16 ) / ( y1 - y0 );
					dC_left.rgb = ( ( grgb1.rgb - grgb0.rgb ) << 16 ) / ( gy.y - gy.x );
					
					//dU_left = ( (( u1 - u0 ) << 16 ) ) / ( y1 - y0 );
					//dV_left = ( (( v1 - v0 ) << 16 ) ) / ( y1 - y0 );
					dT_left.xy = ( ( guv1.xy - guv0.xy ) << 16 ) / ( gy.y - gy.x );
				}
				else
				{
					//dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_right = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx.xy = ( ( gx.zy - gx.xx ) << 16 ) / ( gy.zy - gy.xx );
					
					//dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
					//dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
					//dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
					dC_left.rgb = ( ( grgb2.rgb - grgb0.rgb ) << 16 ) / ( gy.z - gy.x );
					
					//dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
					//dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
					dT_left.xy = ( ( guv2.xy - guv0.xy ) << 16 ) / ( gy.z - gy.x );
				}
			}
			else
			{
				if ( denominator < 0 )
				{
					// change x_left and x_right where y1 is on left
					//x_left = ( x1 << 16 );
					//x_right = ( x0 << 16 );
					x.xy = gx.yx << 16;
					
					//R_left = ( r1 << 16 );
					//G_left = ( g1 << 16 );
					//B_left = ( b1 << 16 );
					C_left.rgb = grgb1.rgb << 16;

					//U_left = ( u1 << 16 );
					//V_left = ( v1 << 16 );
					T_left.xy = guv1.xy << 16;
					
					//if ( ( y2 - y1 ) != 0 )
					if ( ( gy.z - gy.y ) != 0 )
					{
						//dx_left = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						//dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						dx.xy = ( ( gx.zz - gx.yx ) << 16 ) / ( gy.zz - gy.yx );
						
						//dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
						//dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
						//dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
						dC_left.rgb = ( ( grgb2.rgb - grgb1.rgb ) << 16 ) / ( gy.z - gy.y );
						
						//dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
						//dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
						dT_left.xy = ( ( guv2.xy - guv1.xy ) << 16 ) / ( gy.z - gy.y );
					}
				}
				else
				{
					//x_left = ( x0 << 16 );
					//x_right = ( x1 << 16 );
					x.xy = gx.xy << 16;
				
					//R_left = ( r0 << 16 );
					//G_left = ( g0 << 16 );
					//B_left = ( b0 << 16 );
					C_left.rgb = grgb0.rgb << 16;
					
					//U_left = ( u0 << 16 );
					//V_left = ( v0 << 16 );
					T_left.xy = guv0.xy << 16;
					
					//if ( ( y2 - y1 ) != 0 )
					if ( ( gy.z - gy.y ) != 0 )
					{
						//dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						//dx_right = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						dx.xy = ( ( gx.zz - gx.xy ) << 16 ) / ( gy.zz - gy.xy );
						
						//dR_left = (( r2 - r0 ) << 16 ) / ( y2 - y0 );
						//dG_left = (( g2 - g0 ) << 16 ) / ( y2 - y0 );
						//dB_left = (( b2 - b0 ) << 16 ) / ( y2 - y0 );
						dC_left.rgb = ( ( grgb2.rgb - grgb0.rgb ) << 16 ) / ( gy.z - gy.x );
						
						//dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
						//dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
						dT_left.xy = ( ( guv2.xy - guv0.xy ) << 16 ) / ( gy.z - gy.x );
					}
				}
			}
		//}
		

		
		
		// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
		//R_left |= ( 1 << 15 );
		//G_left |= ( 1 << 15 );
		//B_left |= ( 1 << 15 );
		C_left.rgb |= ( 1 << 15 );

		//U_left |= ( 1 << 15 );
		//V_left |= ( 1 << 15 );
		T_left.xy |= ( 1 << 15 );

		//x_left += 0xffff;
		//x_right -= 1;
		
		//StartY = y0;
		//EndY = y1;
		StartY = gy.x;
		EndY = gy.y;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			//x_left += dx_left * Temp;
			//x_right += dx_right * Temp;
			x.xy += dx.xy * Temp;
			
			//R_left += dR_left * Temp;
			//G_left += dG_left * Temp;
			//B_left += dB_left * Temp;
			C_left += dC_left * Temp;
			
			//U_left += dU_left * Temp;
			//V_left += dV_left * Temp;
			T_left += dT_left * Temp;
		}
		
		//if ( EndY > DrawArea_BottomRightY )
		//{
		//	EndY = DrawArea_BottomRightY + 1;
		//}
		EndY = min( EndY, DrawArea_BottomRightY + 1 );


		// check if sprite is within draw area
		//if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || y2 <= DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;
		if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || gy.z <= DrawArea_TopLeftY || gy.x > DrawArea_BottomRightY ) bDraw = 0;	//return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		//if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( x2 - x1 ) > c_MaxPolygonWidth ) || ( y1 - y0 > c_MaxPolygonHeight ) || ( y2 - y1 > c_MaxPolygonHeight ) )
		//if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( y2- y0 ) > c_MaxPolygonHeight ) )
		if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( gy.z - gy.x ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			//return;
			bDraw = 0;
		}


		data [ uIdx + 0 ] = bDraw;
		data [ uIdx + 1 ] = int( PixelMask );
		data [ uIdx + 2 ] = int( SetPixelMask );
		data [ uIdx + 3 ] = int( GPU_CTRL_Read_ABR );
		data [ uIdx + 4 ] = int( Command_ABE );
		data [ uIdx + 5 ] = int( Command_TGE );
		data [ uIdx + 6 ] = int( bgr32 );
		data [ uIdx + 7 ] = int( bgr16 );
		data [ uIdx + 8 ] = int( GPU_CTRL_Read_DTD );
		data [ uIdx + 9 ] = int( DrawArea_TopLeftX );
		data [ uIdx + 10 ] = int( DrawArea_BottomRightX );
		data [ uIdx + 11 ] = EndY;
		data [ uIdx + 12 ] = Shift1;
		data [ uIdx + 13 ] = Shift2;
		data [ uIdx + 14 ] = And1;
		data [ uIdx + 15 ] = And2;
		data [ uIdx + 16 ] = TWYTWH;
		data [ uIdx + 17 ] = TWXTWW;
		data [ uIdx + 18 ] = Not_TWH;
		data [ uIdx + 19 ] = Not_TWW;
		data [ uIdx + 20 ] = TextureOffset;
		data [ uIdx + 21 ] = ClutOffset;
		data [ uIdx + 22 ] = clut_xoffset;
		data [ uIdx + 23 ] = tpage_abr;
		data [ uIdx + 24 ] = dC_across.r;	//dR_across;
		data [ uIdx + 25 ] = dC_across.g;	//dG_across;
		data [ uIdx + 26 ] = dC_across.b;	//dB_across;
		data [ uIdx + 27 ] = dT_across.x;	//dU_across;
		data [ uIdx + 28 ] = dT_across.y;	//dV_across;
		data [ uIdx + 29 ] = bTexture;


		data [ uIdx + 30 ] = StartY;
		data [ uIdx + 31 ] = EndY;
		data [ uIdx + 32 ] = x.x;	//x_left;
		data [ uIdx + 33 ] = x.y;	//x_right;
		data [ uIdx + 34 ] = dx.x;	//dx_left;
		data [ uIdx + 35 ] = dx.y;	//dx_right;
		data [ uIdx + 36 ] = C_left.r;	//R_left;
		data [ uIdx + 37 ] = C_left.g;	//G_left;
		data [ uIdx + 38 ] = C_left.b;	//B_left;
		data [ uIdx + 39 ] = dC_left.r;	//dR_left;
		data [ uIdx + 40 ] = dC_left.g;	//dG_left;
		data [ uIdx + 41 ] = dC_left.b;	//dB_left;
		data [ uIdx + 42 ] = T_left.x;	//U_left;
		data [ uIdx + 43 ] = T_left.y;	//V_left;
		data [ uIdx + 44 ] = dT_left.x;	//dU_left;
		data [ uIdx + 45 ] = dT_left.y;	//dV_left;



	// -------------------------------------------


		//////////////////////////////////////////////////////
		// check if y1 is on the left or on the right
		if ( denominator < 0 )
		{
			//x_left = ( x1 << 16 );
			//x_right = ( x0 << 16 ) + ( dx_right * ( y1 - y0 ) );
			x.xy = gx.yx << 16;
			x.y += dx.y * ( gy.y - gy.x );
			
			///R_left = ( r1 << 16 );
			//G_left = ( g1 << 16 );
			//B_left = ( b1 << 16 );
			C_left = ( grgb1 << 16 );
			
			// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
			//R_left |= ( 1 << 15 );
			//G_left |= ( 1 << 15 );
			//B_left |= ( 1 << 15 );
			C_left |= ( 1 << 15 );

			//U_left = ( u1 << 16 );
			//V_left = ( v1 << 16 );
			T_left = guv1 << 16;
			
			//if ( ( y2 - y1 ) != 0 )
			if ( ( gy.z - gy.y ) != 0 )
			{
				//dx_left = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				dx.x = ( ( gx.z - gx.y ) << 16 ) / ( gy.z - gy.y );
				
				//dR_left = (( r2 - r1 ) << 16 ) / ( y2 - y1 );
				//dG_left = (( g2 - g1 ) << 16 ) / ( y2 - y1 );
				//dB_left = (( b2 - b1 ) << 16 ) / ( y2 - y1 );
				dC_left.rgb = ( ( grgb2.rgb - grgb1.rgb ) << 16 ) / ( gy.z - gy.y );
				
				//dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
				//dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
				dT_left.xy = ( ( guv2.xy - guv1.xy ) << 16 ) / ( gy.z - gy.y );
			}
		}
		else
		{
			//x_left = ( x0 << 16 ) + ( dx_left * ( y1 - y0 ) );
			//x_right = ( x1 << 16 );
			x.xy = gx.xy << 16;
			x.x += ( dx.x * ( gy.y - gy.x ) );
			
			//R_left = ( ( r0 << 16 ) | 0x8000 ) + ( dR_left * ( y1 - y0 ) );
			//G_left = ( ( g0 << 16 ) | 0x8000 ) + ( dG_left * ( y1 - y0 ) );
			//B_left = ( ( b0 << 16 ) | 0x8000 ) + ( dB_left * ( y1 - y0 ) );
			C_left.rgb = ( ( grgb0.rgb << 16 ) | 0x8000 ) + ( dC_left.rgb * ( gy.y - gy.x ) );
			
			//U_left = ( u0 << 16 ) + ( dU_left * ( y1 - y0 ) );
			//V_left = ( v0 << 16 ) + ( dV_left * ( y1 - y0 ) );
			T_left.xy = ( guv0.xy << 16 ) + ( dT_left.xy * ( gy.y - gy.x ) );
			
			//if ( ( y2 - y1 ) != 0 )
			if ( ( gy.z - gy.y ) != 0 )
			{
				//dx_right = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				dx.y = ( ( gx.z - gx.y ) << 16 ) / ( gy.z - gy.y );
			}
		}


		//R_left += ( 1 << 15 );
		//G_left += ( 1 << 15 );
		//B_left += ( 1 << 15 );

		//U_left += ( 1 << 15 );
		//V_left += ( 1 << 15 );
		T_left.xy += ( 1 << 15 );

		
		//StartY = y1;
		//EndY = y2;
		StartY = gy.y;
		EndY = gy.z;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				StartY = EndY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			//x_left += dx_left * Temp;
			//x_right += dx_right * Temp;
			x.xy += dx.xy * Temp;
			
			//R_left += dR_left * Temp;
			//G_left += dG_left * Temp;
			//B_left += dB_left * Temp;
			C_left.rgb += dC_left.rgb * Temp;
			
			//U_left += dU_left * Temp;
			//V_left += dV_left * Temp;
			T_left.xy += dT_left.xy * Temp;
		}
		
		//if ( EndY > DrawArea_BottomRightY )
		//{
		//	EndY = DrawArea_BottomRightY + 1;
		//}
		EndY = min( EndY, DrawArea_BottomRightY + 1 );


	// ---------------------------------------------

		
		data [ uIdx + 46 ] = StartY;
		data [ uIdx + 47 ] = EndY;
		data [ uIdx + 48 ] = x.x;	//x_left;
		data [ uIdx + 49 ] = x.y;	//x_right;
		data [ uIdx + 50 ] = dx.x;	//dx_left;
		data [ uIdx + 51 ] = dx.y;	//dx_right;
		data [ uIdx + 52 ] = C_left.r;	//R_left;
		data [ uIdx + 53 ] = C_left.g;	//G_left;
		data [ uIdx + 54 ] = C_left.b;	//B_left;
		data [ uIdx + 55 ] = dC_left.r;	//dR_left;
		data [ uIdx + 56 ] = dC_left.g;	//dG_left;
		data [ uIdx + 57 ] = dC_left.b;	//dB_left;
		data [ uIdx + 58 ] = T_left.x;	//U_left;
		data [ uIdx + 59 ] = T_left.y;	//V_left;
		data [ uIdx + 60 ] = dT_left.x;	//dU_left;
		data [ uIdx + 61 ] = dT_left.y;	//dV_left;
		
		// loop max at 32
		data [ uIdx + 63 ] = 32;

		}	// end if ( ( Comm >= 0x20 ) && ( Comm <= 0x3f ) )


// -------------------------------------------------------
		
		uIndex += ( xxinc << 4 );

		// need this to be 64 per element instead of 128
		//uIdx += ( xxinc << 7 );
		uIdx += ( xxinc << 6 );

	} while ( ( Comm != 0xff ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );

	barrier ();

	prelist_data ();

	barrier ();
}

void draw_texture ( int xsize, int ysize )
{
	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );

	ivec2 pos;
	uvec4 rgba;
	int pixel;
	vec4 frgba;

	// don't know if all the threads have completed all the other tasks yet
	barrier ();

	for ( pos.y = ( yid << group_yshift ) + group_y; pos.y < ysize; pos.y += group_yinc )
	{
		for ( pos.x = ( xid << group_xshift ) + group_x; pos.x < xsize; pos.x += group_xinc )
		{
			pixel = int( pixelbuffer32 [ pos.x + ( pos.y * xsize ) ] );

			//frgba.b = float( ( pixel >> 16 ) & 0xff ) / 255.0;
			//frgba.g = float( ( pixel >> 8 ) & 0xff ) / 255.0;
			//frgba.r = float( ( pixel >> 0 ) & 0xff ) / 255.0;
			//frgba.a = 1.0;

			frgba.b = float( ( pixel >> 16 ) & 0xff );
			frgba.g = float( ( pixel >> 8 ) & 0xff );
			frgba.r = float( ( pixel >> 0 ) & 0xff );

			frgba = frgba / 255.0;
			frgba.a = 1.0;

			imageStore( destTex, pos, frgba );
		}
	}
}

void draw_screen( uint uIndex )
{

	int xxid = int( gl_LocalInvocationIndex );
	


//inputdata format:
//0: GPU_CTRL_Read
//1: DisplayRange_Horizontal
//2: DisplayRange_Vertical
//3: ScreenArea_TopLeftX
//4: ScreenArea_TopLeftY
//5: bEnableScanline
//6: Y_Pixel
//7: --------
//8: Command

	
	const int c_iVisibleArea_StartX_Cycle = 584;
	const int c_iVisibleArea_EndX_Cycle = 3192;
	const int c_iVisibleArea_StartY_Pixel_NTSC = 15;
	const int c_iVisibleArea_EndY_Pixel_NTSC = 257;
	const int c_iVisibleArea_StartY_Pixel_PAL = 34;
	const int c_iVisibleArea_EndY_Pixel_PAL = 292;

	const int c_iVisibleArea_StartY [] = { c_iVisibleArea_StartY_Pixel_NTSC, c_iVisibleArea_StartY_Pixel_PAL };
	const int c_iVisibleArea_EndY [] = { c_iVisibleArea_EndY_Pixel_NTSC, c_iVisibleArea_EndY_Pixel_PAL };

	const int c_iGPUCyclesPerPixel [] = { 10, 7, 8, 0, 5, 0, 4, 0 };
	


	
	// so the max viewable width for PAL is 3232/4-544/4 = 808-136 = 672
	// so the max viewable height for PAL is 292-34 = 258
	
	// actually, will initially start with a 1 pixel border based on screen width/height and then will shift if something is off screen

	
	// there the frame buffer pixel, and then there's the screen buffer pixel
	uint Pixel16, Pixel32_0, Pixel32_1;
	uint pix0, pix1, pix2;
	
	
	
	//private Pixel_24bit_Format Pixel24;
	
	
	int FramePixel_X, FramePixel_Y;
	
	
	
	//global u16* private ptr_vram16;
	int iptr_vram16;
	//global u32* private ptr_pixelbuffer32;
	int iptr_pixelbuffer32;
	
	int current_x, current_y;
	int current_x2;

		
	
	
	
	if ( xxid == 0 )
	{
		uIndex <<= 4;

		
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DisplayRange_X1 = int( inputdata [ uIndex + 1 ] ) & 0xfff;
		DisplayRange_X2 = int( inputdata [ uIndex + 1 ] >> 12 ) & 0xfff;
		DisplayRange_Y1 = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DisplayRange_Y2 = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x7ff;
		ScreenArea_TopLeftX = int( inputdata [ uIndex + 3 ] ) & 0x3ff;
		ScreenArea_TopLeftY = int( inputdata [ uIndex + 3 ] >> 10 ) & 0x1ff;
		bEnableScanline = int( inputdata [ uIndex + 4 ] );
		Y_Pixel = int( inputdata [ uIndex + 5 ] );

		
		// bits 16-18
		GPU_CTRL_Read_WIDTH = ( GPU_CTRL_Read >> 16 ) & 7;
		
		// bit 19
		GPU_CTRL_Read_HEIGHT = ( GPU_CTRL_Read >> 19 ) & 1;
		
		// bit 20
		GPU_CTRL_Read_VIDEO = ( GPU_CTRL_Read >> 20 ) & 1;
		
		// bit 21
		GPU_CTRL_Read_ISRGB24 = ( GPU_CTRL_Read >> 21 ) & 1;
		
		// bit 22
		GPU_CTRL_Read_ISINTER = ( GPU_CTRL_Read >> 22 ) & 1;
		
		// bit 23
		GPU_CTRL_Read_DEN = ( GPU_CTRL_Read >> 23 ) & 1;
		
		
		// GPU cycles per pixel depends on width
		GPU_CyclesPerPixel = c_iGPUCyclesPerPixel [ GPU_CTRL_Read_WIDTH ];

		// get the pixel to start and stop drawing at
		Draw_StartX = DisplayRange_X1 / GPU_CyclesPerPixel;
		Draw_EndX = DisplayRange_X2 / GPU_CyclesPerPixel;
		Draw_StartY = DisplayRange_Y1;
		Draw_EndY = DisplayRange_Y2;

		Draw_Width = Draw_EndX - Draw_StartX;
		Draw_Height = Draw_EndY - Draw_StartY;
		// get the pixel to start and stop at for visible area
		VisibleArea_StartX = c_iVisibleArea_StartX_Cycle / GPU_CyclesPerPixel;
		VisibleArea_EndX = c_iVisibleArea_EndX_Cycle / GPU_CyclesPerPixel;

		// visible area start and end y depends on pal/ntsc
		VisibleArea_StartY = c_iVisibleArea_StartY [ GPU_CTRL_Read_VIDEO ];
		VisibleArea_EndY = c_iVisibleArea_EndY [ GPU_CTRL_Read_VIDEO ];

		VisibleArea_Width = VisibleArea_EndX - VisibleArea_StartX;
		VisibleArea_Height = VisibleArea_EndY - VisibleArea_StartY;


		Source_Height = Draw_Height;
		

		
		if ( ( GPU_CTRL_Read_ISINTER != 0 ) && ( GPU_CTRL_Read_HEIGHT != 0 ) )
		{
			// 480i mode //
			
			// if not simulating scanlines, then the draw height should double too
			if ( bEnableScanline == 0 )
			{
				VisibleArea_EndY += Draw_Height;
				VisibleArea_Height += Draw_Height;
				
				Draw_EndY += Draw_Height;
				
				Draw_Height <<= 1;
			}
			
			Source_Height <<= 1;
		}
		

		
		
		if ( GPU_CTRL_Read_DEN == 0 )
		{
			BottomBorder_Height = VisibleArea_EndY - Draw_EndY;
			LeftBorder_Width = Draw_StartX - VisibleArea_StartX;
			TopBorder_Height = Draw_StartY - VisibleArea_StartY;
			RightBorder_Width = VisibleArea_EndX - Draw_EndX;
			
			if ( BottomBorder_Height < 0 ) BottomBorder_Height = 0;
			if ( LeftBorder_Width < 0 ) LeftBorder_Width = 0;
			
			
			
			current_ymax = Draw_Height + BottomBorder_Height;
			current_xmax = Draw_Width + LeftBorder_Width;
			
			// make suree that ymax and xmax are not greater than the size of visible area
			if ( current_xmax > VisibleArea_Width )
			{
				// entire image is not on the screen, so take from left border and recalc xmax //

				LeftBorder_Width -= ( current_xmax - VisibleArea_Width );
				if ( LeftBorder_Width < 0 ) LeftBorder_Width = 0;
				current_xmax = Draw_Width + LeftBorder_Width;
				
				// make sure again we do not draw past the edge of screen
				if ( current_xmax > VisibleArea_Width ) current_xmax = VisibleArea_Width;
			}
			
			if ( current_ymax > VisibleArea_Height )
			{
				BottomBorder_Height -= ( current_ymax - VisibleArea_Height );
				if ( BottomBorder_Height < 0 ) BottomBorder_Height = 0;
				current_ymax = Draw_Height + BottomBorder_Height;
				
				// make sure again we do not draw past the edge of screen
				if ( current_ymax > VisibleArea_Height ) current_ymax = VisibleArea_Height;
			}
			
		}	// end if ( !GPU_CTRL_Read_DEN )
		
		
		
	}	// end if ( !local_id )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	barrier ();
	

	// *** new stuff *** //

	//FramePixel = 0;
	//ptr_pixelbuffer32 = PixelBuffer;
	iptr_pixelbuffer32 = 0;
	

	if ( GPU_CTRL_Read_DEN == 0 )
	{
		
		// current_y should start at zero for even field and one for odd
		current_y = 0;
		//current_y = group_yoffset + yid;
		
		
		// put in bottom border //
		
		
		// check if scanlines simulation is enabled
		if ( bEnableScanline != 0 )
		{
			// spread out workers on every other line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * ( group_yoffset + yid ) );
			
			// if this is an odd field, then start writing on the next line
			if ( ( Y_Pixel & 1 ) != 0 )
			{
				// odd field //
				
				iptr_pixelbuffer32 += VisibleArea_Width;
			}
		}
		

		while ( current_y < BottomBorder_Height )
		{
			//current_x = 0;
			current_x = xxid;
			
			while ( current_x < VisibleArea_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			}
			
			current_y++;
			//current_y += yinc;
			
			// added for opencl, update pixel buffer multiple lines
			//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			iptr_pixelbuffer32 += VisibleArea_Width;
			
			// check if scanline simulation is enabled
			if ( bEnableScanline != 0 )
			{
				// update again since doing every other line
				iptr_pixelbuffer32 += VisibleArea_Width;
				//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			}
		}
		
		
		// put in screen
		
		
		FramePixel_Y = ScreenArea_TopLeftY + Source_Height - 1;
		FramePixel_X = ScreenArea_TopLeftX;



		
		// for opencl, spread the workers across the lines
		//FramePixel_Y -= group_yoffset + yid;
		//FramePixel_Y -= ( current_y - BottomBorder_Height );
		
		// check if simulating scanlines
		if ( bEnableScanline != 0 )
		{
			// check if 480i
			if ( ( GPU_CTRL_Read_ISINTER != 0 ) && ( GPU_CTRL_Read_HEIGHT != 0 ) )
			{
				// 480i //
				
				// for opencl, spread interlace mode to every other line
				//FramePixel_Y -= ( current_y - BottomBorder_Height );
				
				// check if in odd field or even field
				if ( ( Y_Pixel & 1 ) != 0 )
				{
					// odd field //
					
					// if the height is even, then it is ok
					// if the height is odd, need to compensate
					if ( ( Source_Height & 1 ) == 0 )
					{
						FramePixel_Y--;
					}
				}
				else
				{
					// even field //
					
					// if the height is odd, then it is ok
					// if the height is even, need to compensate
					if ( ( Source_Height & 1 ) != 0 )
					{
						FramePixel_Y--;
					}
				}
				
			} // end if ( GPU_CTRL_Read.ISINTER && GPU_CTRL_Read.HEIGHT )
		}
		




	
		while ( current_y < current_ymax )
		{
			
			// put in the left border
			//current_x = 0;
			current_x = xxid;

			while ( current_x < LeftBorder_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			}
			

			// *** important note *** this wraps around the VRAM
			//ptr_vram16 = & (VRAM [ FramePixel_X + ( ( FramePixel_Y & c_lFrameBuffer_Height_Mask ) << 10 ) ]);
			iptr_vram16 = FramePixel_X + ( ( FramePixel_Y & c_lFrameBuffer_Height_Mask ) << 10 );
			

			// put in screeen pixels
			if ( GPU_CTRL_Read_ISRGB24 == 0 )
			{
				
				while ( current_x < current_xmax )
				{

					//Pixel16 = *ptr_vram16++;
					//Pixel16 = ptr_vram16 [ current_x - LeftBorder_Width ];
					Pixel16 = VRAM [ iptr_vram16 + current_x - LeftBorder_Width ];
					
					// the previous pixel conversion is wrong
					Pixel32_0 = ( ( Pixel16 & 0x1f ) << 3 ) | ( ( Pixel16 & 0x3e0 ) << 6 ) | ( ( Pixel16 & 0x7c00 ) << 9 );
					
					// *ptr_pixelbuffer32++ = Pixel32_0;
					//ptr_pixelbuffer32 [ current_x ] = Pixel32_0;
					pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = Pixel32_0;
					
					
					//current_x++;
					current_x += xxinc;
				}
				
			}
			else
			{
				current_x = LeftBorder_Width + ( xxid << 1 );
				current_x2 = ( xxid << 1 ) + xxid;
				while ( current_x < current_xmax )
				{
					
					//Pixel24.Pixel0 = *ptr_vram16++;
					//Pixel24.Pixel1 = *ptr_vram16++;
					//Pixel24.Pixel2 = *ptr_vram16++;
					//Pixel24.Pixel0 = ptr_vram16 [ ( ( ( current_x - LeftBorder_Width ) >> 1 ) * 3 ) + 0 ];
					//Pixel24.Pixel1 = ptr_vram16 [ ( ( ( current_x - LeftBorder_Width ) >> 1 ) * 3 ) + 1 ];
					//Pixel24.Pixel2 = ptr_vram16 [ ( ( ( current_x - LeftBorder_Width ) >> 1 ) * 3 ) + 2 ];
					pix0 = VRAM [ iptr_vram16 + current_x2 + 0 ];
					pix1 = VRAM [ iptr_vram16 + current_x2 + 1 ];
					pix2 = VRAM [ iptr_vram16 + current_x2 + 2 ];
					
					// draw first pixel
					//Pixel32_0 = ( ((u32)Pixel24.Red0) ) | ( ((u32)Pixel24.Green0) << 8 ) | ( ((u32)Pixel24.Blue0) << 16 );
					Pixel32_0 = ( pix0 & 0xffff ) | ( ( pix1 & 0xff ) << 16 );
					
					// draw second pixel
					//Pixel32_1 = ( ((u32)Pixel24.Red1) ) | ( ((u32)Pixel24.Green1) << 8 ) | ( ((u32)Pixel24.Blue1) << 16 );
					Pixel32_1 = ( ( pix2 & 0xffff ) << 8 ) | ( ( pix1 >> 8 ) & 0xff );
					
					// *ptr_pixelbuffer32++ = Pixel32_0;
					// *ptr_pixelbuffer32++ = Pixel32_1;
					//ptr_pixelbuffer32 [ current_x ] = Pixel32_0;
					//ptr_pixelbuffer32 [ current_x + 1 ] = Pixel32_1;
					pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = Pixel32_0;
					pixelbuffer32 [ iptr_pixelbuffer32 + current_x + 1 ] = Pixel32_1;
					
					//current_x += 2;
					current_x += ( xxinc << 1 );
					current_x2 += ( xxinc << 1 ) + xxinc;
					
				}
				current_x = LeftBorder_Width + ( Draw_Width << 1 ) + xxid;
				
				
			}
			
			
			// put in right border
			while ( current_x < VisibleArea_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			}
			
			
			current_y++;
			//current_y += yinc;
			
			// for opencl, update pixel buffer to next line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			iptr_pixelbuffer32 += VisibleArea_Width;
			
			if ( bEnableScanline != 0 )
			{
				// check if this is 480i
				if ( ( GPU_CTRL_Read_ISINTER != 0 ) && ( GPU_CTRL_Read_HEIGHT != 0 ) )
				{
					// 480i mode //
					
					// jump two lines in source image
					FramePixel_Y -= 2;
					//FramePixel_Y -= ( yinc << 1 );
				}
				else
				{
					// go to next line in frame buffer
					FramePixel_Y--;
					//FramePixel_Y -= yinc;
				}
				
				// also go to next line in destination buffer
				iptr_pixelbuffer32 += VisibleArea_Width;
				//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			}
			else
			{
				// go to next line in frame buffer
				FramePixel_Y--;
				//FramePixel_Y -= yinc;
			}
			
			
			
		} // end while ( current_y < current_ymax )
		

		// put in top border //
		
		
		while ( current_y < VisibleArea_Height )
		{
			//current_x = 0;
			current_x = xxid;
			
			while ( current_x < VisibleArea_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			} // end while ( current_x < VisibleArea_Width )
				
			current_y++;
			//current_y += yinc;
				
			// for opencl, update pixel buffer to next line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			iptr_pixelbuffer32 += VisibleArea_Width;
			
			// check if scanline simulation is enabled
			if ( bEnableScanline != 0 )
			{
				// also go to next line in destination buffer
				iptr_pixelbuffer32 += VisibleArea_Width;
				//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			}
			
		} // end while ( current_y < current_ymax )
		
	}
	else
	{
		// display disabled //
		
		
		current_y = 0;
		//current_y = group_yoffset + yid;
		
		// set initial row for pixel buffer pointer
		//ptr_pixelbuffer32 += ( VisibleArea_Width * current_y );
		
		if ( bEnableScanline != 0 )
		{
			// space out to every other line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * current_y );
			
			if ( ( Y_Pixel & 1 ) != 0 )
			{
				// odd field //
				
				iptr_pixelbuffer32 += VisibleArea_Width;
			}
		}
		
		while ( current_y < VisibleArea_Height )
		{
			//current_x = 0;
			current_x = xxid;
			
			while ( current_x < VisibleArea_Width )
			{
				// *ptr_pixelbuffer32++ = 0;
				//ptr_pixelbuffer32 [ current_x ] = 0;
				pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = 0;
				
				//current_x++;
				current_x += xxinc;
			}
			
			current_y++;
			//current_y += yinc;
			
			// for opencl, update pixel buffer to next line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			iptr_pixelbuffer32 += VisibleArea_Width;
			
			if ( bEnableScanline != 0 )
			{
				iptr_pixelbuffer32 += VisibleArea_Width;
				//ptr_pixelbuffer32 += ( VisibleArea_Width * yinc );
			}
			
		}
		

	}

	// check if simulating scanlines
	if ( bEnableScanline != 0 )
	{
		// the visible height is actually times 2 in the buffer for odd and even fields
		VisibleArea_Height <<= 1;
		
		// but, its actually times 2 and then minus one
		VisibleArea_Height--;
	}


	draw_texture ( VisibleArea_Width, VisibleArea_Height );

	// write back VisibleArea data
	//inputdata [ 8 ].Value = VisibleArea_Width;
	//inputdata [ 9 ].Value = VisibleArea_Height;

	//}	// end if ( !local_id )


	// this needs to be complete before proceeding
	barrier ();
}



void vDraw_FrameBufferRectangle_02 (uint iIdx)
{
	int xxid = int( gl_LocalInvocationIndex );

	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );
	

	
	int xoff, yoff;
	

	uint bgr16;
	uint bgr32;

	int w, h, xmax, ymax, ymax2;
	int x, y;

	int xinc2;

	uvec4 uvbgr16;

	//uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	//int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	//int DrawArea_OffsetX, DrawArea_OffsetY;
	//uint Command_ABE;

	//uint PixelMask, SetPixelMask;


	// set local variables
	//if ( (xid + yid) == 0 )
	//{
		iIdx <<= 4;

		// set bgr
		//bgr32 = inputdata [ 7 ].Value;
		bgr32 = inputdata [ iIdx + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		bgr16 |= ( bgr16 << 16 );
		
		
		//x = inputdata [ 8 ].x;
		//y = inputdata [ 8 ].y;
		x = int( inputdata [ iIdx + 8 ] );
		y = x >> 16;
		

		
		// x and y are actually 11 bits
		// doesn't matter for frame buffer
		//x = ( x << 21 ) >> 21;
		//y = ( y << 21 ) >> 21;
		
		//w = inputdata [ 9 ].w;
		//h = inputdata [ 9 ].h;
		w = int( inputdata [ iIdx + 9 ] );
		h = w >> 16;
		
		// Xpos=(Xpos AND 3F0h)
		x &= 0x3f0;
		
		// ypos & 0x1ff
		y &= 0x1ff;
		
		// Xsiz=((Xsiz AND 3FFh)+0Fh) AND (NOT 0Fh)
		w = ( ( w & 0x3ff ) + 0xf ) & ~0xf;
		
		// Ysiz=((Ysiz AND 1FFh))
		h &= 0x1ff;
	
		// adding xmax, ymax
		xmax = x + w;
		ymax = y + h;
		

		// make a color vector to store
		uvbgr16 = uvec4( bgr16 );

	//}
	


#ifdef SYNC_BEFORE_TRANSFER
	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	barrier ();
#endif

	
	// *** NOTE: coordinates wrap *** //
	
	// need to first make sure there is something to draw
	if ( h > 0 && w > 0 )
	{
#ifdef USE_NEW_SCANLINE_DRAW_CLEAR
		yid = ( xxid - y ) & xxmask;
		xid = 0;

		//for ( yoff = y + yid; yoff < ymax; yoff += yinc )
		for ( yoff = y + yid; yoff < ymax; yoff += xxinc )
		{
			//for ( xoff = x + ( xid << 2 ); xoff < xmax; xoff += ( xinc << 2 ) )
			for ( xoff = x + ( xid << 2 ); xoff < xmax; xoff += 4 )
			{
				//VRAM [ ( xoff & c_lFrameBuffer_Width_Mask ) + ( ( yoff & c_lFrameBuffer_Height_Mask ) << 10 ) ] = bgr16;
				VRAM4 [ ( ( xoff & c_lFrameBuffer_Width_Mask ) + ( ( yoff & c_lFrameBuffer_Height_Mask ) << 10 ) ) >> 2 ] = uvbgr16;
			}
		}
#else

		// don't use group_xinc because this only runs on one gpu core
		// can't run this on multiple gpu cores because runs on entire buffer
		for ( yoff = y + yid; yoff < ymax; yoff += yinc )
		{
			for ( xoff = x + ( xid << 2 ); xoff < xmax; xoff += ( xinc << 2 ) )
			{
				//VRAM [ ( xoff & c_lFrameBuffer_Width_Mask ) + ( ( yoff & c_lFrameBuffer_Height_Mask ) << 10 ) ] = bgr16;
				VRAM4 [ ( ( xoff & c_lFrameBuffer_Width_Mask ) + ( ( yoff & c_lFrameBuffer_Height_Mask ) << 10 ) ) >> 2 ] = uvbgr16;
			}
		}
#endif
				
	}	// end if ( h > 0 && w > 0 )


#ifdef SYNC_AFTER_TRANSFER
	// need to complete command before proceeding
	barrier ();
#endif

}




/*
uint ColorMultiply1624 ( uint Color16, uint Color24 )
{
	const int c_iBitsPerPixel16 = 5;
	const int c_iRedShift16 = c_iBitsPerPixel16 * 2;
	const int c_iRedMask16 = ( 0x1f << c_iRedShift16 );
	const int c_iGreenShift16 = c_iBitsPerPixel16 * 1;
	const int c_iGreenMask16 = ( 0x1f << c_iGreenShift16 );
	const int c_iBlueShift16 = 0;
	const int c_iBlueMask16 = ( 0x1f << c_iBlueShift16 );

	const int c_iBitsPerPixel24 = 8;
	const int c_iRedShift24 = c_iBitsPerPixel24 * 2;
	const int c_iRedMask24 = ( 0xff << ( c_iBitsPerPixel24 * 2 ) );
	const int c_iGreenShift24 = c_iBitsPerPixel24 * 1;
	const int c_iGreenMask24 = ( 0xff << ( c_iBitsPerPixel24 * 1 ) );
	const int c_iBlueShift24 = 0;
	const int c_iBlueMask24 = ( 0xff << ( c_iBitsPerPixel24 * 0 ) );
	
	int Red, Green, Blue;
	
	// the multiply should put it in 16.23 fixed point, but need it back in 8.8
	//Red = int( ( Color16 & c_iRedMask16 ) * ( Color24 & c_iRedMask24 ) );
	Red = int( ( ( Color16 & c_iRedMask16 ) >> 5 ) * ( ( Color24 & c_iRedMask24 ) >> 8 ) );
	//Red |= ( ( Red << ( 32 - ( 16 + 23 ) ) ) >> 31 );
	Red |= ( ( Red << ( 32 - ( 16 + 10 ) ) ) >> 31 );
	
	// to get to original position, shift back ( 23 - 8 ) = 15, then shift right 7, for total of 7 + 15 = 22 shift right
	// top bit (38) needs to end up in bit 15, so that would actually shift right by 23
	//Red >>= 23;
	// bit 25 needs to be in bit 15
	Red >>= 10;
	
	// the multiply should put it in 16.10 fixed point, but need it back in 8.30
	Green = int( ( ( Color16 & c_iGreenMask16 ) ) * ( ( Color24 & c_iGreenMask24 ) ) );
	Green |= ( ( Green << ( 32 - ( 16 + 10 ) ) ) >> 31 );
	
	// top bit (25) needs to end up in bit (10)
	Green >>= 15;
	
	// the multiply should put it in 13.0 fixed point
	Blue = int( ( ( Color16 & c_iBlueMask16 ) ) * ( ( Color24 & c_iBlueMask24 ) ) );
	Blue |= ( ( Blue << ( 32 - ( 13 + 0 ) ) ) >> 31 );
	
	// top bit (12) needs to end up in bit 5
	Blue >>= 7;
	
	return uint( ( Red & c_iRedMask16 ) | ( Green & c_iGreenMask16 ) | ( Blue & c_iBlueMask16 ) );
	
}



uvec4 vColorMultiply1624 ( uvec4 Color16, uvec4 Color24 )
{
	const uint c_iBitsPerPixel16 = 5;
	const uint c_iRedShift16 = c_iBitsPerPixel16 * 2;
	const uvec4 c_iRedMask16 = uvec4( 0x1f << c_iRedShift16 );
	const uint c_iGreenShift16 = c_iBitsPerPixel16 * 1;
	const uvec4 c_iGreenMask16 = uvec4( 0x1f << c_iGreenShift16 );
	const uint c_iBlueShift16 = 0;
	const uvec4 c_iBlueMask16 = uvec4( 0x1f << c_iBlueShift16 );

	const uint c_iBitsPerPixel24 = 8;
	const uvec4 c_iRedShift24 = uvec4( c_iBitsPerPixel24 * 2 );
	const uvec4 c_iRedMask24 = uvec4( 0xff << ( c_iBitsPerPixel24 * 2 ) );
	const uint c_iGreenShift24 = c_iBitsPerPixel24 * 1;
	const uvec4 c_iGreenMask24 = uvec4( 0xff << ( c_iBitsPerPixel24 * 1 ) );
	const uint c_iBlueShift24 = 0;
	const uvec4 c_iBlueMask24 = uvec4( 0xff << ( c_iBitsPerPixel24 * 0 ) );
	
	ivec4 Red, Green, Blue;
	
	// the multiply should put it in 16.23 fixed point, but need it back in 8.8
	//Red = int( ( Color16 & c_iRedMask16 ) * ( Color24 & c_iRedMask24 ) );
	Red = ivec4( ( ( Color16 & c_iRedMask16 ) >> 5 ) * ( ( Color24 & c_iRedMask24 ) >> 8 ) );
	//Red |= ( ( Red << ( 32 - ( 16 + 23 ) ) ) >> 31 );
	Red |= ( ( Red << ( 32 - ( 16 + 10 ) ) ) >> 31 );
	
	// to get to original position, shift back ( 23 - 8 ) = 15, then shift right 7, for total of 7 + 15 = 22 shift right
	// top bit (38) needs to end up in bit 15, so that would actually shift right by 23
	//Red >>= 23;
	// bit 25 needs to be in bit 15
	Red >>= 10;
	
	// the multiply should put it in 16.10 fixed point, but need it back in 8.30
	Green = ivec4( ( ( Color16 & c_iGreenMask16 ) ) * ( ( Color24 & c_iGreenMask24 ) ) );
	Green |= ( ( Green << ( 32 - ( 16 + 10 ) ) ) >> 31 );
	
	// top bit (25) needs to end up in bit (10)
	Green >>= 15;
	
	// the multiply should put it in 13.0 fixed point
	Blue = ivec4( ( ( Color16 & c_iBlueMask16 ) ) * ( ( Color24 & c_iBlueMask24 ) ) );
	Blue |= ( ( Blue << ( 32 - ( 13 + 0 ) ) ) >> 31 );
	
	// top bit (12) needs to end up in bit 5
	Blue >>= 7;
	
	return uvec4( ( Red & c_iRedMask16 ) | ( Green & c_iGreenMask16 ) | ( Blue & c_iBlueMask16 ) );
	
}
*/


uvec4 vSemiTransparency16 ( uvec4 B, uvec4 F, uint abrCode )
{
	
	const uint ShiftSame = 0;
	const uint ShiftHalf = 1;
	const uint ShiftQuarter = 2;
	
	const uint c_iBitsPerPixel = 5;
	const uvec4 c_iShiftHalf_Mask = uvec4( ~( ( 1 << ( c_iBitsPerPixel - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 2 ) - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 3 ) - 1 ) ) ) );
	const uvec4 c_iShiftQuarter_Mask = uvec4( ~( ( 3 << ( c_iBitsPerPixel - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 2 ) - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 3 ) - 2 ) ) ) );
	const uvec4 c_iClampMask = uvec4( ( 1 << ( c_iBitsPerPixel ) ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) + ( 1 << ( c_iBitsPerPixel * 3 ) ) );
	const uvec4 c_iLoBitMask = uvec4( ( 1 ) + ( 1 << c_iBitsPerPixel ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) );
	const uvec4 c_iPixelMask = uvec4( 0x7fff );
	
	//uint Red, Green, Blue;
	
	uvec4 Color, Actual, Mask;
	
	switch ( abrCode )
	{
		// 0.5xB+0.5 xF
		case 0:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftHalf ) + ( GetRed16( F ) >> ShiftHalf ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftHalf ) + ( GetGreen16( F ) >> ShiftHalf ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftHalf ) + ( GetBlue16( F ) >> ShiftHalf ) ) );
			
			Mask = B & F & c_iLoBitMask;
			Color = ( ( B >> 1 ) & c_iShiftHalf_Mask ) + ( ( F >> 1 ) & c_iShiftHalf_Mask ) + Mask;
			return Color;
			
			break;
		
		// 1.0xB+1.0 xF
		case 1:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
			
		// 1.0xB-1.0 xF
		case 2:
			//Color = SetRed16 ( Clamp5 ( (s32) ( GetRed16 ( B ) >> ShiftSame ) - (s32) ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( (s32) ( GetGreen16 ( B ) >> ShiftSame ) - (s32) ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( (s32) ( GetBlue16 ( B ) >> ShiftSame ) - (s32) ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B - F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual + Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color &= ~Mask;
			return Color;
			
			break;
			
		// 1.0xB+0.25xF
		case 3:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftQuarter ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftQuarter ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftQuarter ) ) );
			
			B &= c_iPixelMask;
			F = ( F >> 2 ) & c_iShiftQuarter_Mask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
	}
	
	return Color;
	
}



uint SemiTransparency16 ( uint B, uint F, uint abrCode )
{
	
	const uint ShiftSame = 0;
	const uint ShiftHalf = 1;
	const uint ShiftQuarter = 2;
	
	const uint c_iBitsPerPixel = 5;
	const uint c_iShiftHalf_Mask = ~( ( 1 << ( c_iBitsPerPixel - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 2 ) - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 3 ) - 1 ) ) );
	const uint c_iShiftQuarter_Mask = ~( ( 3 << ( c_iBitsPerPixel - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 2 ) - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 3 ) - 2 ) ) );
	const uint c_iClampMask = ( ( 1 << ( c_iBitsPerPixel ) ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) + ( 1 << ( c_iBitsPerPixel * 3 ) ) );
	const uint c_iLoBitMask = ( ( 1 ) + ( 1 << c_iBitsPerPixel ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) );
	const uint c_iPixelMask = 0x7fff;
	
	uint Red, Green, Blue;
	
	uint Color, Actual, Mask;
	
	switch ( abrCode )
	{
		// 0.5xB+0.5 xF
		case 0:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftHalf ) + ( GetRed16( F ) >> ShiftHalf ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftHalf ) + ( GetGreen16( F ) >> ShiftHalf ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftHalf ) + ( GetBlue16( F ) >> ShiftHalf ) ) );
			
			Mask = B & F & c_iLoBitMask;
			Color = ( ( B >> 1 ) & c_iShiftHalf_Mask ) + ( ( F >> 1 ) & c_iShiftHalf_Mask ) + Mask;
			return Color;
			
			break;
		
		// 1.0xB+1.0 xF
		case 1:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
			
		// 1.0xB-1.0 xF
		case 2:
			//Color = SetRed16 ( Clamp5 ( (s32) ( GetRed16 ( B ) >> ShiftSame ) - (s32) ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( (s32) ( GetGreen16 ( B ) >> ShiftSame ) - (s32) ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( (s32) ( GetBlue16 ( B ) >> ShiftSame ) - (s32) ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B - F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual + Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color &= ~Mask;
			return Color;
			
			break;
			
		// 1.0xB+0.25xF
		case 3:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftQuarter ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftQuarter ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftQuarter ) ) );
			
			B &= c_iPixelMask;
			F = ( F >> 2 ) & c_iShiftQuarter_Mask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
	}
	
	return Color;
	
}





void vDraw_Line ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	//s64 r10, r20, r21;
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;

	uint bgr32, bgr16;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;
	
	int w;
	ivec4 vLine;
	ivec4 vix;
	ivec4 vxid;
	ivec4 vyid;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	
	const ivec4 vZero = ivec4( 0 );

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	int iEndpointX, iEndpointY;

	// setup vars
	//if ( !local_id )
	//{
		
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		bgr32 = inputdata [ uIndex + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		

		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
		
		// get the endpoint, since it shouldn't be drawn
		iEndpointX = gx [ 1 ];
		iEndpointY = gy [ 1 ];

		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( ( RightMostX < DrawArea_TopLeftX ) || ( LeftMostX > DrawArea_BottomRightX ) || ( BottomMostY < DrawArea_TopLeftY ) || ( TopMostY > DrawArea_BottomRightY ) ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}

		uvbgr16 = uvec4( bgr16 );
		ivRedF = ivec4( uvbgr16 >> 0 ) & 0x1f;
		ivGreenF = ivec4( uvbgr16 >> 5 ) & 0x1f;
		ivBlueF = ivec4( uvbgr16 >> 10 ) & 0x1f;

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}

				
		
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;


	//barrier ();


	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
			////////////////////////////////////
			// get slopes
			
		iy = ( y0 << 16 ) + 0x8000;
		

		if ( line_length != 0 )
		{
			
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			dy <<= 8;

		}	// end if ( line_length )

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				
				iy += dy * Temp;
				StartX = DrawArea_TopLeftX;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				EndX = DrawArea_BottomRightX;
			}
		//}
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going up, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}	// end if ( dy <= 0 )
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}
		}	// end if ( dy >= 0 )
		
		
		// can optimize this some other time
		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;

		// align the compute units with pixels

		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
		xid = ( ( cxid << group_xshift ) + group_x );
		vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
		vxid = ( vxid ) - ( StartX & group_vxmask );

		vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


		w = EndX - StartX;

		// draw the line horizontally
		//for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		for ( vix = vxid; any( lessThanEqual( uvec4( vix ), uvec4( w ) ) ); vix += group_vxinc )
		{
			//Line = iy + (( ix - StartX ) * dy);
			//Line >>= 16;
			vLine = iy + (vix * dy);
			vLine >>= 16;
			
			//yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;
			vyid = ( ( ( cyid << group_yshift ) + group_y ) - vLine ) & group_ymask;

			//bvEnable = bvec4(ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )));
			bvEnable = bvec4( ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )) & ivec4(lessThanEqual( uvec4( vix ), uvec4( w ) )) & ivec4(notEqual(vix+StartX,ivec4(iEndpointX))) );

			//if ( yid == 0 )
			if ( any( bvEnable ) )
			{
				// need to know what line we are on
				vLine = mix( vZero, vLine, bvEnable );
				Line = vLine.x | vLine.y | vLine.z | vLine.w;

			//if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			//{
				// read pixel from frame buffer if we need to check mask bit
				//iPtr = ix + ( Line << 10 );
				//DestPixel = VRAM [ iPtr ];
				//ivPtr = (vix + StartX) + ( vLine << 10 );
				ivPtr = (vix + StartX) + ( Line << 10 );
				
#ifdef USE_VECTOR_LOADSTORE
				uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
				uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
				uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
				uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
				uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif
				
				//bgr_temp = bgr16;
	
				// semi-transparency
				//if ( Command_ABE != 0 )
				//{
				//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				//}
				
				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 31 );
				ivGreenB = clamp( ivGreenB, 0, 31 );
				ivBlueB = clamp( ivBlueB, 0, 31 );

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

				// check if we should set mask bit when drawing
				uvbgr_temp |= SetPixelMask;


				// draw pixel if we can draw to mask pixels or mask bit not set
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );

#ifdef USE_VECTOR_LOADSTORE
				VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
				VRAM [ ivPtr [ 0 ] ] = uvDestPixel [ 0 ];
				VRAM [ ivPtr [ 1 ] ] = uvDestPixel [ 1 ];
				VRAM [ ivPtr [ 2 ] ] = uvDestPixel [ 2 ];
				VRAM [ ivPtr [ 3 ] ] = uvDestPixel [ 3 ];
#endif

			//}	// end if ( Line >= DrawArea_TopLeftY && Line <= DrawArea_BottomRightY )

			}	// end if ( yid == 0 )
			
			//iy += dy;
			//iy += dy * xxinc;

		}	// end for ( ix = StartX; ix != EndX; ix += incdec )
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		if ( line_length != 0 )
		{
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			dx <<= 8;
		}
		
		//StartY = y0;
		//EndY = y1;
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				
				ix += dx * Temp;
				StartY = DrawArea_TopLeftY;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				//EndY = DrawArea_BottomRightY + 1;
				EndY = DrawArea_BottomRightY;
			}
		//}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

	
		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;



		w = EndY - StartY;

		// draw the line vertically
		//for ( viy = vyid; any( lessThan( uvec4( viy ), uvec4( w ) ) ); viy += group_yinc )
		for ( iy = yid; iy <= w; iy += group_yinc )
		{
			//Line = ix + (( iy - StartY ) * dx);
			//Line >>= 16;
			Line = ix + (iy * dx);
			Line >>= 16;
			
			// can optimize this some other time
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - Line ) & group_xmask;

			// align the compute units with pixels

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( Line & group_vxmask );

			//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


			//bvEnable = equal( vxid, vZero );
			//bvEnable = bvec4( ivec4(equal( vxid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftX) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightX) )) & ivec4(lessThanEqual( uvec4( iy ), uvec4( w ) )) & ivec4(notEqual(ivec4(iy+StartY),ivec4(iEndpointY))) );
			bvEnable = bvec4( ivec4(equal( vxid, vZero )) & ivec4( Line >= DrawArea_TopLeftX ) & ivec4( Line <= DrawArea_BottomRightX ) & ivec4( uint( iy ) <= uint( w ) ) & ivec4( (iy+StartY) != iEndpointY ) );


			//if ( xid == 0 )
			if ( any( bvEnable ) )
			{

			//if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			//{
				// read pixel from frame buffer if we need to check mask bit
				iPtr = Line + ( ( iy + StartY ) << 10 );
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}


				// check if we should set mask bit when drawing
				bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			//}	// end if ( Line >= DrawArea_TopLeftX && Line <= DrawArea_BottomRightX )

			}	// end if ( xid == 0 )
			
			//ix += dx;

		}	// end for ( iy = StartY; iy != EndY; iy += incdec )

	}	// end if else if ( x_distance > y_distance )


	//barrier ();


	return;
}



void Draw_Line ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7: GetBGR24 ( Buffer [ 0 ] );
//8: GetXY0 ( Buffer [ 1 ] );
//9: GetXY1 ( Buffer [ 2 ] );
//10: GetXY2 ( Buffer [ 3 ] );



	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	//s64 r10, r20, r21;
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;

	uint bgr32, bgr16;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;
	
	//u32 NumPixels;
	
//debug << "\nDrawTriangle_Mono_th";

	// setup vars
	//if ( !local_id )
	//{
		
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		bgr32 = inputdata [ uIndex + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		

		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
		
		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( ( RightMostX < DrawArea_TopLeftX ) || ( LeftMostX > DrawArea_BottomRightX ) || ( BottomMostY < DrawArea_TopLeftY ) || ( TopMostY > DrawArea_BottomRightY ) ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}
		
				
		
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;

	//barrier ();
	
	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
			////////////////////////////////////
			// get slopes
			
		iy = ( y0 << 16 ) + 0x8000;
		

		if ( line_length != 0 )
		{
			
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			dy <<= 8;

		}	// end if ( line_length )

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				
				iy += dy * Temp;
				StartX = DrawArea_TopLeftX;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				EndX = DrawArea_BottomRightX + 1;
			}
		//}
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going up, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}	// end if ( dy <= 0 )
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}
		}	// end if ( dy >= 0 )
		
		
		// can optimize this some other time
		xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
		
		// draw the line horizontally
		//for ( ix = StartX; ix != EndX; ix += incdec )
		for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		{
			Line = iy + (( ix - StartX ) * dy);
			Line >>= 16;
			
			yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;

			if ( yid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			{
				//ptr = & ( _GPU->VRAM [ ix + ( Line << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = ix + ( Line << 10 );
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			}	// end if ( Line >= DrawArea_TopLeftY && Line <= DrawArea_BottomRightY )

			}	// end if ( yid == 0 )
			
			//iy += dy;
			//iy += dy * xxinc;

		}	// end for ( ix = StartX; ix != EndX; ix += incdec )
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		if ( line_length != 0 )
		{
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			dx <<= 8;
		}
		
		//StartY = y0;
		//EndY = y1;
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				
				ix += dx * Temp;
				StartY = DrawArea_TopLeftY;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY + 1;
			}
		//}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

	
		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

		// draw the line vertically
		//for ( iy = StartY; iy != EndY; iy += incdec )
		for ( iy = StartY + yid; iy < EndY; iy += group_yinc )
		{
			Line = ix + (( iy - StartY ) * dx);
			Line >>= 16;
			
			// can optimize this some other time
			xid = ( ( ( cxid << group_xshift ) + group_x ) - Line ) & group_xmask;

			if ( xid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			{
				//ptr = & ( _GPU->VRAM [ Line + ( iy << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = Line + ( iy << 10 );
				DestPixel = VRAM [ iPtr ];
				
				bgr_temp = bgr16;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			}	// end if ( Line >= DrawArea_TopLeftX && Line <= DrawArea_BottomRightX )

			}	// end if ( xid == 0 )
			
			//ix += dx;

		}	// end for ( iy = StartY; iy != EndY; iy += incdec )

	}	// end if else if ( x_distance > y_distance )
	

	return;
}



void vDraw_Line_Gradient ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;



	int w;
	ivec4 ivIndex;
	ivec4 ivDitherValue;
	ivec4 vLine;
	ivec4 ivR, ivG, ivB;
	ivec4 vix;
	ivec4 vxid;
	ivec4 vyid;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;


	const ivec4 vZero = ivec4( 0 );

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;
	

	int iR, iG, iB;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;
	int Red, Blue, Green;
	int dr, dg, db;
	int DitherValue;
	
	int oR, oG, oB;
	
	int iEndpointX, iEndpointY;

	// setup vars
	//if ( !local_id )
	//{
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		//bgr32 = inputdata [ uIndex + 7 ];
		//bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		

		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );

		// get the endpoint, since it shouldn't be drawn
		iEndpointX = gx [ 1 ];
		iEndpointY = gy [ 1 ];
		
		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( RightMostX < DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || BottomMostY < DrawArea_TopLeftY || TopMostY > DrawArea_BottomRightY ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}
		


		

		
		gbgr [ 0 ] = int( inputdata [ uIndex + 7 ] ) & 0x00ffffff;
		gbgr [ 1 ] = int( inputdata [ uIndex + 9 ] ) & 0x00ffffff;
		
		

		// get rgb-values
		r0 = gbgr [ Coord0 ] & 0xff;
		r1 = gbgr [ Coord1 ] & 0xff;

		g0 = ( gbgr [ Coord0 ] >> 8 ) & 0xff;
		g1 = ( gbgr [ Coord1 ] >> 8 ) & 0xff;

		b0 = ( gbgr [ Coord0 ] >> 16 ) & 0xff;
		b1 = ( gbgr [ Coord1 ] >> 16 ) & 0xff;


	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}

	
	iR = ( r0 << 16 ) + 0x8000;
	iG = ( g0 << 16 ) + 0x8000;
	iB = ( b0 << 16 ) + 0x8000;
	
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;


	//barrier ();


	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
		//ix = x0;
		iy = ( y0 << 16 ) + 0x8000;
		//x_right = x_left;
		
		
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			//dx = ( ( x1 - x0 ) << 16 ) / line_length;
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dy <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				StartX = DrawArea_TopLeftX;
				
				iy += dy * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				EndX = DrawArea_BottomRightX;
			}
		
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}

		}
		
		oR = iR;
		oG = iG;
		oB = iB;
				
		// can optimize this some other time
		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;

		// align the compute units with pixels

		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
		xid = ( ( cxid << group_xshift ) + group_x );
		vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
		vxid = ( vxid ) - ( StartX & group_vxmask );

		vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );


		w = EndX - StartX;

		// draw the line horizontally
		//for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		for ( vix = vxid; any( lessThanEqual( uvec4( vix ), uvec4( w ) ) ); vix += group_vxinc )
		{

			//Line = iy + (( ix - StartX ) * dy);
			//Line >>= 16;
			vLine = iy + (vix * dy);
			vLine >>= 16;
			

			// can optimize this some other time
			//yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;
			vyid = ( ( ( cyid << group_yshift ) + group_y ) - vLine ) & group_ymask;

			bvEnable = bvec4( ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )) & ivec4(lessThanEqual( uvec4( vix ), uvec4( w ) )) & ivec4(notEqual(vix+StartX,ivec4(iEndpointX))) );


			//if ( yid == 0 )
			if ( any( bvEnable ) )
			{
				// need to know what line we are on
				vLine = mix( vZero, vLine, bvEnable );
				Line = vLine.x | vLine.y | vLine.z | vLine.w;

			//if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			//{
			ivR = oR + ( vix * dr );
			ivG = oG + ( vix * dg );
			ivB = oB + ( vix * db );

				
				//ivIndex = ( ( vix + StartX ) & 3 ) + ( ( vLine & 3 ) << 2 );
				ivIndex = ( ( vix + StartX ) & 3 ) + ( ( Line & 3 ) << 2 );
				ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );
				ivDitherValue[0] = c_iDitherValues16 [ ivIndex[0] ];
				ivDitherValue[1] = c_iDitherValues16 [ ivIndex[1] ];
				ivDitherValue[2] = c_iDitherValues16 [ ivIndex[2] ];
				ivDitherValue[3] = c_iDitherValues16 [ ivIndex[3] ];

				// perform dither
				ivRedF = ivR + ivDitherValue;
				ivGreenF = ivG + ivDitherValue;
				ivBlueF = ivB + ivDitherValue;
				
				// perform shift
				ivRedF >>= ( 16 + 3 );
				ivGreenF >>= ( 16 + 3 );
				ivBlueF >>= ( 16 + 3 );
				
				ivRedF = clamp ( ivRedF, 0, 31 );
				ivGreenF = clamp ( ivGreenF, 0, 31 );
				ivBlueF = clamp ( ivBlueF, 0, 31 );
				
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				//iPtr = ix + ( Line << 10 );
				//DestPixel = VRAM [ iPtr ];
				//ivPtr = (vix + StartX) + ( vLine << 10 );
				ivPtr = (vix + StartX) + ( Line << 10 );
				
#ifdef USE_VECTOR_LOADSTORE
				uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
				uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
				uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
				uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
				uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif
				
				//bgr_temp = bgr;
	
				// semi-transparency
				//if ( Command_ABE != 0 )
				//{
				//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				//}

				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 31 );
				ivGreenB = clamp( ivGreenB, 0, 31 );
				ivBlueB = clamp( ivBlueB, 0, 31 );

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
				// check if we should set mask bit when drawing
				uvbgr_temp |= SetPixelMask;


				// draw pixel if we can draw to mask pixels or mask bit not set
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				// testing
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, bvEnable );
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, bvEnable1 );
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, bvEnable2 );
				//uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable3 );

#ifdef USE_VECTOR_LOADSTORE
				VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
				//VRAM [ iPtr ] = DestPixel;
				VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
				VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
				VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
				VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif

			//}

			}	// end if ( yid == 0 )
			
			//iy += dy;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}
		
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		//if ( y1 - y0 )
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			//dy = ( ( y1 - y0 ) << 16 ) / line_length;,
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dx <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}
		
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
				
				ix += dx * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				//EndY = DrawArea_BottomRightY + 1;
				EndY = DrawArea_BottomRightY;
			}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

		oR = iR;
		oG = iG;
		oB = iB;

		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
	

		w = EndY - StartY;

		// draw the line vertically
		//for ( viy = vyid; any( lessThan( uvec4( viy ), uvec4( w ) ) ); viy += group_yinc )
		for ( iy = yid; iy <= w; iy += group_yinc )
		{
			//Line = ix + (( iy - StartY ) * dx);
			//Line >>= 16;
			Line = ix + (iy * dx);
			Line >>= 16;
			

			// align the compute units with pixels

			//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( Line & group_vxmask );

			//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

			//bvEnable = equal( vxid, vZero );
			//bvEnable = bvec4( ivec4(equal( vxid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftX) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightX) )) & ivec4(lessThanEqual( uvec4( iy ), uvec4( w ) )) & ivec4(notEqual(ivec4(iy+StartY),ivec4(iEndpointY))) );
			bvEnable = bvec4( ivec4(equal( vxid, vZero )) & ivec4( Line >= DrawArea_TopLeftX ) & ivec4( Line <= DrawArea_BottomRightX ) & ivec4( uint( iy ) <= uint( w ) ) & ivec4( (iy+StartY) != iEndpointY ) );


			//if ( xid == 0 )
			if ( any( bvEnable ) )
			{

			//if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			//{

			iR = oR + ( iy * dr);
			iG = oG + ( iy * dg);
			iB = oB + ( iy * db);

				if ( GPU_CTRL_Read_DTD != 0 )
				{
					//DitherValue = DitherLine [ x_across & 0x3 ];
					DitherValue = c_iDitherValues16 [ ( Line & 3 ) + ( ( iy & 3 ) << 2 ) ];
					
					// perform dither
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
				bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
				
				
				
				// read pixel from frame buffer if we need to check mask bit
				iPtr = Line + ( ( iy + StartY ) << 10 );
				DestPixel = VRAM [ iPtr ];
				//ivPtr = (vxid + Line) + ( vLine << 10 );
				
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}


				// check if we should set mask bit when drawing
				bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

			//}

			}	// end if ( xid == 0 )
			
			//ix += dx;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}


	}
	
	
	//barrier ();


	return;
}



void Draw_Line_Gradient ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;




	
	
	

	int iR, iG, iB;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;
	int Red, Blue, Green;
	int dr, dg, db;
	int DitherValue;
	
	int oR, oG, oB;
	
//debug << "\nDrawTriangle_Mono_th";

	// setup vars
	//if ( !local_id )
	//{
		uIndex <<= 4;
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		// ME is bit 12
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		//bgr32 = inputdata [ uIndex + 7 ];
		//bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		

		//gx [ 0 ] = int( ( inputdata [ 8 ].x << 5 ) >> 5 );
		//gy [ 0 ] = int( ( inputdata [ 8 ].y << 5 ) >> 5 );
		//gx [ 1 ] = int( ( inputdata [ 10 ].x << 5 ) >> 5 );
		//gy [ 1 ] = int( ( inputdata [ 10 ].y << 5 ) >> 5 );
		gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
		gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
		gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
		gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
		
		x_distance = abs( gx[0] - gx[1] );
		y_distance = abs( gy[0] - gy[1] );

		Coord0 = 0;
		Coord1 = 1;
		
		if ( x_distance > y_distance )
		{
			// sort coords from left to right if line is horizontal
			if ( gx [ Coord1 ] < gx [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		else
		{
			// sort coords from top to bottom if line is vertical
			if ( gy [ Coord1 ] < gy [ Coord0 ] )
			{
				Temp = Coord0;
				Coord0 = Coord1;
				Coord1 = Temp;
			}

		}
		
		
		// get x-values
		x0 = gx [ Coord0 ];
		x1 = gx [ Coord1 ];
		
		// get y-values
		y0 = gy [ Coord0 ];
		y1 = gy [ Coord1 ];
		
		//////////////////////////////////////////
		// get coordinates on screen
		x0 += DrawArea_OffsetX;
		y0 += DrawArea_OffsetY;
		x1 += DrawArea_OffsetX;
		y1 += DrawArea_OffsetY;
		
		// get the left/right most x
		LeftMostX = ( ( x0 < x1 ) ? x0 : x1 );
		//LeftMostX = ( ( x2 < LeftMostX ) ? x2 : LeftMostX );
		RightMostX = ( ( x0 > x1 ) ? x0 : x1 );
		//RightMostX = ( ( x2 > RightMostX ) ? x2 : RightMostX );
		TopMostY = ( ( y0 < y1 ) ? y0 : y1 );
		BottomMostY = ( ( y0 > y1 ) ? y0 : y1 );

		

		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			return;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			return;
		}

		// check if sprite is within draw area
		if ( RightMostX < DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || BottomMostY < DrawArea_TopLeftY || TopMostY > DrawArea_BottomRightY ) return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			return;
		}
		


		

		
		gbgr [ 0 ] = int( inputdata [ uIndex + 7 ] ) & 0x00ffffff;
		gbgr [ 1 ] = int( inputdata [ uIndex + 9 ] ) & 0x00ffffff;
		
		

		// get rgb-values
		r0 = gbgr [ Coord0 ] & 0xff;
		r1 = gbgr [ Coord1 ] & 0xff;

		g0 = ( gbgr [ Coord0 ] >> 8 ) & 0xff;
		g1 = ( gbgr [ Coord1 ] >> 8 ) & 0xff;

		b0 = ( gbgr [ Coord0 ] >> 16 ) & 0xff;
		b1 = ( gbgr [ Coord1 ] >> 16 ) & 0xff;

		
	
	iR = ( r0 << 16 ) + 0x8000;
	iG = ( g0 << 16 ) + 0x8000;
	iB = ( b0 << 16 ) + 0x8000;
	
	StartX = x0;
	EndX = x1;
	StartY = y0;
	EndY = y1;


	//barrier ();
	
	// check if line is horizontal
	if ( x_distance > y_distance )
	{
		
		// get the largest length
		line_length = x_distance;
		
			
		//ix = x0;
		iy = ( y0 << 16 ) + 0x8000;
		//x_right = x_left;
		
		
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			//dx = ( ( x1 - x0 ) << 16 ) / line_length;
			dy = ( ( y1 - y0 ) << 8 ) / line_length;
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dy <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}

		
		// check if line is going left or right
		//if ( x1 > x0 )
		//{
			// line is going to the right
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartX < DrawArea_TopLeftX )
			{
				Temp = DrawArea_TopLeftX - StartX;
				StartX = DrawArea_TopLeftX;
				
				iy += dy * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndX > DrawArea_BottomRightX )
			{
				EndX = DrawArea_BottomRightX + 1;
			}
		
		
		if ( dy < 0 )
		{
	
			if ( ( iy >> 16 ) < DrawArea_TopLeftY )
			{
				return;
			}
			//else
			//{
			//	// line is veering onto screen
			//	
			//	// get y value it hits screen at
			//	ix = ( ( ( y0 << 16 ) + 0x8000 ) - ( ((s32)DrawArea_TopLeftY) << 16 ) ) / ( dy >> 8 );
			//	ix -= ( x0 << 8 ) + 0xff;
			//	
			//}
			
			//if ( EndY < DrawArea_TopLeftY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_TopLeftY - 1;
			//}

		}
		
		if ( dy > 0 )
		{
			if ( ( iy >> 16 ) > DrawArea_BottomRightY )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndY > DrawArea_BottomRightY )
			//{
			//	// line is going down, so End Y would
			//	EndY = DrawArea_BottomRightY + 1;
			//}

		}
		
		oR = iR;
		oG = iG;
		oB = iB;
				
		// can optimize this some other time
		xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;

		// draw the line horizontally
		//for ( ix = StartX; ix != EndX; ix += incdec )
		for ( ix = StartX + xid; ix < EndX; ix += group_xinc )
		{

			//Line = iy >> 16;
			Line = iy + (( ix - StartX ) * dy);
			Line >>= 16;
			
			iR = oR + (( ix - StartX ) * dr);
			iG = oG + (( ix - StartX ) * dg);
			iB = oB + (( ix - StartX ) * db);

			// can optimize this some other time
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - ix ) & group_xmask;
			yid = ( ( ( cyid << group_yshift ) + group_y ) - Line ) & group_ymask;

			if ( yid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftY ) && ( Line <= DrawArea_BottomRightY ) )
			{
				if ( GPU_CTRL_Read_DTD != 0 )
				{
					//bgr = ( _Round( iR ) >> 32 ) | ( ( _Round( iG ) >> 32 ) << 8 ) | ( ( _Round( iB ) >> 32 ) << 16 );
					//bgr = ( _Round( iR ) >> 35 ) | ( ( _Round( iG ) >> 35 ) << 5 ) | ( ( _Round( iB ) >> 35 ) << 10 );
					//DitherValue = DitherLine [ x_across & 0x3 ];
					DitherValue = c_iDitherValues16 [ ( ix & 3 ) + ( ( Line & 3 ) << 2 ) ];
					
					// perform dither
					//Red = iR + DitherValue;
					//Green = iG + DitherValue;
					//Blue = iB + DitherValue;
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					//Red = Clamp5 ( ( iR + DitherValue ) >> 27 );
					//Green = Clamp5 ( ( iG + DitherValue ) >> 27 );
					//Blue = Clamp5 ( ( iB + DitherValue ) >> 27 );
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
					
				bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
				
				
				//ptr = & ( _GPU->VRAM [ ix + ( Line << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = ix + ( Line << 10 );
				DestPixel = VRAM [ iPtr ];
				
				//bgr_temp = bgr;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
			}

			}	// end if ( yid == 0 )
			
			//iy += dy;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}
		
	}
	else
	{
		// line is vertical //

		// get the largest length
		line_length = y_distance;
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
		ix = ( x0 << 16 ) + 0x8000;
		//iy = y0;
		//x_right = x_left;
		
		//if ( y1 - y0 )
		if ( line_length != 0 )
		{
			/////////////////////////////////////////////
			// init x on the left and right
			
			//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
			dx = ( ( x1 - x0 ) << 8 ) / line_length;
			//dy = ( ( y1 - y0 ) << 16 ) / line_length;,
			
			dr = ( ( r1 - r0 ) << 8 ) / line_length;
			dg = ( ( g1 - g0 ) << 8 ) / line_length;
			db = ( ( b1 - b0 ) << 8 ) / line_length;

			dx <<= 8;
			dr <<= 8;
			dg <<= 8;
			db <<= 8;
		}
		
		
		
		// check if line is going up or down
		//if ( y1 > y0 )
		//{
			// line is going to the down
			//incdec = 1;
			
			// clip against edge of screen
			if ( StartY < DrawArea_TopLeftY )
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
				
				ix += dx * Temp;
				iR += dr * Temp;
				iG += dg * Temp;
				iB += db * Temp;
			}
			
			if ( EndY > DrawArea_BottomRightY )
			{
				EndY = DrawArea_BottomRightY + 1;
			}
	
		if ( dx < 0 )
		{
			if ( ( ix >> 16 ) < DrawArea_TopLeftX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX < DrawArea_TopLeftX )
			//{
			//	EndX = DrawArea_TopLeftX - 1;
			//}
		}
		
		if ( dx > 0 )
		{
			if ( ( ix >> 16 ) > DrawArea_BottomRightX )
			{
				// line is veering off screen
				return;
			}
			
			//if ( EndX > DrawArea_BottomRightX )
			//{
			//	EndX = DrawArea_BottomRightX + 1;
			//}
		}
		
		

	//}	// end if ( !local_id )
	
	

	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );

		oR = iR;
		oG = iG;
		oB = iB;

		// can optimize this some other time
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
	
		// draw the line vertically
		//for ( iy = StartY; iy != EndY; iy += incdec )
		for ( iy = StartY + yid; iy < EndY; iy += group_yinc )
		{
			//Line = ix >> 16;
			Line = ix + (( iy - StartY ) * dx);
			Line >>= 16;

			iR = oR + (( iy - StartY ) * dr);
			iG = oG + (( iy - StartY ) * dg);
			iB = oB + (( iy - StartY ) * db);
			
			// can optimize this some other time
			xid = ( ( ( cxid << group_xshift ) + group_x ) - Line ) & group_xmask;
			//yid = ( ( ( cyid << group_yshift ) + group_y ) - iy ) & group_ymask;

			if ( xid == 0 )
			{

			if ( ( Line >= DrawArea_TopLeftX ) && ( Line <= DrawArea_BottomRightX ) )
			{
				if ( GPU_CTRL_Read_DTD != 0 )
				{
					//bgr = ( _Round( iR ) >> 32 ) | ( ( _Round( iG ) >> 32 ) << 8 ) | ( ( _Round( iB ) >> 32 ) << 16 );
					//bgr = ( _Round( iR ) >> 35 ) | ( ( _Round( iG ) >> 35 ) << 5 ) | ( ( _Round( iB ) >> 35 ) << 10 );
					//DitherValue = DitherLine [ x_across & 0x3 ];
					DitherValue = c_iDitherValues16 [ ( Line & 3 ) + ( ( iy & 3 ) << 2 ) ];
					
					// perform dither
					//Red = iR + DitherValue;
					//Green = iG + DitherValue;
					//Blue = iB + DitherValue;
					Red = iR + DitherValue;
					Green = iG + DitherValue;
					Blue = iB + DitherValue;
					
					//Red = Clamp5 ( ( iR + DitherValue ) >> 27 );
					//Green = Clamp5 ( ( iG + DitherValue ) >> 27 );
					//Blue = Clamp5 ( ( iB + DitherValue ) >> 27 );
					
					// perform shift
					Red >>= ( 16 + 3 );
					Green >>= ( 16 + 3 );
					Blue >>= ( 16 + 3 );
					
					Red = clamp ( Red, 0, 31 );
					Green = clamp ( Green, 0, 31 );
					Blue = clamp ( Blue, 0, 31 );
				}
				else
				{
					Red = iR >> ( 16 + 3 );
					Green = iG >> ( 16 + 3 );
					Blue = iB >> ( 16 + 3 );
				}
					
					
				bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
				
				
				//ptr = & ( _GPU->VRAM [ Line + ( iy << 10 ) ] );
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				iPtr = Line + ( iy << 10 );
				DestPixel = VRAM [ iPtr ];
				
				//bgr_temp = bgr;
	
				// semi-transparency
				if ( Command_ABE != 0 )
				{
					bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				}
				
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = ( bgr_temp | SetPixelMask );
				if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
			}

			}	// end if ( xid == 0 )
			
			//ix += dx;
			
			//iR += dr;
			//iG += dg;
			//iB += db;
		}


	}
	
	
	return;
}







#ifdef ENABLE_PRIMITIVE_LOOP
uint Draw_Pixel_68 ( uint uIndex )
#else
void Draw_Pixel_68 ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;

	

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7:GetBGR24 ( Buffer [ 0 ] );
//8:GetXY ( Buffer [ 1 ] );


	
	
	uint DestPixel;

	int iPtr;

uint bgr16;
uint bgr32;

int w, h, xmax, ymax, ymax2;
int x, y;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;

uint PixelMask, SetPixelMask;

	ivec4 vxid;
	const ivec4 vZero = ivec4(0);

	uint Comm;
	int bDraw;

	uint uIdx;

	uIndex <<= 4;

	//do
	//{

	// set local variables
	//if ( (xid + yid) == 0 )
	//{

		/*
		// set bgr64
		bgr32 = inputdata [ uIndex + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		
		
		x = int( inputdata [ uIndex + 8 ] );
		y = x >> 16;
		
		
		// x and y are actually 11 bits
		x = ( x << ( 5 + 16 ) ) >> ( 5 + 16 );
		y = ( y << ( 5 + 16 ) ) >> ( 5 + 16 );
		
		
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;

		
		
		// get top left corner of sprite and bottom right corner of sprite
		x += DrawArea_OffsetX;
		y += DrawArea_OffsetY;

		
		// ME is bit 12
		//if ( GPU_CTRL_Read.ME ) PixelMask = 0x8000;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		//if ( GPU_CTRL_Read.MD ) SetPixelMask = 0x8000;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;


		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;

		bDraw = 1;
		
	//}

	//barrier();

	// check for some important conditions
	if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
	{
		//return;
		bDraw = 0;
	}
	
	if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
	{
		//return;
		bDraw = 0;
	}

	if ( x < DrawArea_TopLeftX || y < DrawArea_TopLeftY || x > DrawArea_BottomRightX || y > DrawArea_BottomRightY )
	{
		//return;
		bDraw = 0;
	}
	*/
	
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );
		//StartX = data [ uIdx + 8 ];
		//EndX = data [ uIdx + 9 ];
		//StartY = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		x = data [ uIdx + 25 ];
		y = data [ uIdx + 26 ];
	
	// align the compute units with pixels
	//xid = ( ( ( cxid << group_xshift ) + group_x ) - x ) & group_xmask;
	yid = ( ( ( cyid << group_yshift ) + group_y ) - y ) & group_ymask;

	//yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( x & group_vxmask );

	//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

	//if ( xid + yid == 0 )
	if ( any( equal( vxid, vZero ) ) )
	{
		/////////////////////////////////////////
		// Draw the pixel

		// make sure we are putting pixel within draw area
		//if ( x >= DrawArea_TopLeftX && y >= DrawArea_TopLeftY && x <= DrawArea_BottomRightX && y <= DrawArea_BottomRightY )
		//{
			//ptr16 = & ( VRAM [ x + ( y << 10 ) ] );
			iPtr = x + ( y << 10 );
			
			// read pixel from frame buffer if we need to check mask bit
			DestPixel = VRAM [ iPtr ];
			
			// semi-transparency
			if ( Command_ABE != 0 )
			{
				bgr16 = SemiTransparency16 ( DestPixel, bgr16, GPU_CTRL_Read_ABR );
			}
			
			// check if we should set mask bit when drawing
			bgr16 |= SetPixelMask;

			// draw pixel if we can draw to mask pixels or mask bit not set
			DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr16 : DestPixel;
			VRAM [ iPtr ] = DestPixel;
		//}
	}	// end if ( xid + yid == 0 )

	}	// end if ( bDraw == 1 )
	
		//uIndex += 16;
		//Comm = inputdata [ uIndex + 7 ] >> 24;
	//} while ( ( Comm >= 0x68 && Comm <= 0x6b ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );

#ifdef ENABLE_PRIMITIVE_LOOP
	return uIndex;
#else
	return;
#endif
}



#ifdef ENABLE_PRIMITIVE_LOOP
uint vDraw_Rectangle_60 ( uint uIndex )
#else
void vDraw_Rectangle_60 ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	

	int iPtr;
	
	
	
	uint DestPixel;
	uint bgr_temp;
	int x_across;
	int Line;

	uint bgr16;
	int x, y, w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	int x0;
	int y0;
	int x1;
	int y1;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	uint Comm;
	int bDraw;

	uint uIdx;

		uIndex <<= 4;

	
#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		// should be 64 per element instead of 128
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;

		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		uvbgr16 = uvec4( uint( data [ uIdx + 7 ] ) );

		StartX = data [ uIdx + 9 ];
		EndX = data [ uIdx + 10 ];

		//StartY = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		StartY = data [ uIdx + 30 ];
		EndY = data [ uIdx + 31 ];

		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//u0 = data [ uIdx + 16 ];
		//v0 = data [ uIdx + 17 ];
		//TWYTWH = data [ uIdx + 18 ];
		//TWXTWW = data [ uIdx + 19 ];
		//Not_TWH = data [ uIdx + 20 ];
		//Not_TWW = data [ uIdx + 21 ];
		//TextureOffset = data [ uIdx + 22 ];
		//ClutOffset = data [ uIdx + 23 ];
		//clut_xoffset = data [ uIdx + 24 ];


		ivRedF = ivec4( uvbgr16 >> 0 ) & 0x1f;
		ivGreenF = ivec4( uvbgr16 >> 5 ) & 0x1f;
		ivBlueF = ivec4( uvbgr16 >> 10 ) & 0x1f;

		uvbgr_temp = uvec4( bgr16 );
		uvbgr_temp |= SetPixelMask;

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


	// align the compute units with pixels
#ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE

	yid = ( xxid - StartY ) & xxmask;

	vxid =  ivec4( 0, 1, 2, 3 );

#else
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( StartX & group_vxmask );

	vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
#endif



	w = EndX - StartX + 1;



	for ( Line = StartY + yid; Line <= EndY; Line += group_vyinc )
	{
		//iPtr = ( StartX & ~3 ) + (xid << 2) + ( Line << 10 );
		ivPtr = ( StartX + vxid ) + ( Line << 10 );

#ifdef USE_NATIVE_PIXELS
		// 2 pixels per 32-bit word
		ivPtr >>= 1;
#endif
		
		// draw horizontal line
		for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
		{
			// check what pixels are enabled
			bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

			// read pixel from frame buffer if we need to check mask bit
			//DestPixel = *ptr;
#ifdef USE_VECTOR_LOADSTORE
			uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
			uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
#endif


#ifdef USE_NATIVE_PIXELS
			uvDestPixel = uvDest;
			uvDestPixel.yw >>= 16;
			uvDestPixel &= 0xffff;
#endif
			
			//bgr_temp = bgr16;
			//vbgr_temp = uvbgr16;

			// semi-transparency //

#ifdef USE_MORE_JUMPS
			if ( Command_ABE != 0 )
#endif
			{
			// semi-transparency
			//if ( Command_ABE != 0 )
			//{
			//	//bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
			//	vbgr_temp = vSemiTransparency16 ( vDestPixel, vbgr_temp, GPU_CTRL_Read_ABR );
			//}

			//ivRedF = ( vbgr16 >> 0 ) & 0x1f;
			//ivBlueF = ( vbgr16 >> 5 ) & 0x1f;
			//ivGreenF = ( vbgr16 >> 10 ) & 0x1f;

			ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
			ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
			ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

			//ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
			//ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
			//ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );
			ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
			ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
			ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

			ivRedB = clamp( ivRedB, 0, 31 );
			ivGreenB = clamp( ivGreenB, 0, 31 );
			ivBlueB = clamp( ivBlueB, 0, 31 );

			uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

			// just set bshift to 16/31 and fsign to if alpha not enabled
			//uvbgr_temp = ( Command_ABE != 0 ) ? uvbgr_temp : uvbgr16;

			
			// check if we should set mask bit when drawing
			//bgr_temp |= SetPixelMask;
			uvbgr_temp |= SetPixelMask;

			}

			// draw pixel if we can draw to mask pixels or mask bit not set
			//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
			uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

			// only enabled pixels should be active
			uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


#ifdef USE_NATIVE_PIXELS
			// mask vram //
			uvDest [ 0 ] &= 0x0000ffff;
			uvDest [ 1 ] &= 0xffff0000;
			uvDest [ 2 ] &= 0x0000ffff;
			uvDest [ 3 ] &= 0xffff0000;

			uvDestPixel.yw <<= 16;
			uvDest |= uvDestPixel;
#endif
			
			// store pixels //
#ifdef USE_VECTOR_LOADSTORE
			VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
			//VRAM [ iPtr ] = DestPixel;
			VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
			VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
			VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
			VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif

			// update pointer for pixel out
			ivPtr += group_vxinc;
		}
		
	}	// end for ( Line = StartY + group_yoffset + yid; Line <= EndY; Line += yinc )

	}	// end if ( bDraw == 1 )

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x60 && Comm <= 0x63 ) || ( Comm >= 0x70 && Comm <= 0x73 ) || ( Comm >= 0x78 && Comm <= 0x7b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif



#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}






#ifdef ENABLE_PRIMITIVE_LOOP
uint vDraw_Sprite_64 ( uint uIndex )
#else
void vDraw_Sprite_64 ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	int iPtr;


	// notes: looks like sprite size is same as specified by w/h

	
	int TexelIndex;
	
	
	
	int Temp;
	
	// new local variables
	uint bgr, bgr_temp;
	int iU, iV;
	int x_across;
	int Line;
	
	uint DestPixel;
	int TexCoordX, TexCoordY;

	
	uint bgr16;
	int x, y, w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	int x0;
	int y0;
	int x1;
	int y1;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	int u;
	int v;
	
	// bits 0-5 in upper halfword
	int clut_x;
	int clut_y;

	int TWY;
	int TWX;
	int TWH;
	int TWW;
		
	int tpage_tx;
	int tpage_ty;
	int tpage_tp;
	int Shift1;
	int Shift2;
	int And1;
	int And2;
	int TWYTWH;
	int TWXTWW;
	int Not_TWH;
	int Not_TWW;
	int TextureOffset;
	int ClutOffset;
	int clut_xoffset;

	int u0, v0;
	uint color_add;
	uint Command_TGE;


	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 vEndX;

	const ivec4 vZero = ivec4( 0 );

	uvec4 uvbgr, uvbgr2;
	uvec4 uvDest;

	ivec4 ivTexCoordX;
	ivec4 ivU;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivIndex;
	
	uint Comm;
	int bDraw;

	uint uIdx;


	// set local variables
	//if ( xxid == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		// should be 64 per element instead of 128
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;

		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		color_add = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );

		StartX = data [ uIdx + 9 ];
		EndX = data [ uIdx + 10 ];

		//StartY = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];

		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];

		//u0 = data [ uIdx + 16 ];
		//v0 = data [ uIdx + 17 ];

		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];
		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];

		StartY = data [ uIdx + 30 ];
		EndY = data [ uIdx + 31 ];

		u0 = data [ uIdx + 42 ] >> 16;
		v0 = data [ uIdx + 43 ] >> 16;
	

	if ( Command_TGE != 0 )
	{
		color_add = 0x00808080;
	}





	// setup color_add value
	//ivRedC = ivec4( uvcolor_add >> 16 ) & 0xff;
	//ivGreenC = ivec4( uvcolor_add >> 8 ) & 0xff;
	//ivBlueC = ivec4( uvcolor_add >> 0 ) & 0xff;
	ivRedC = ivec4( ( int( color_add ) >> 0 ) & 0xff );
	ivGreenC = ivec4( ( int( color_add ) >> 8 ) & 0xff );
	ivBlueC = ivec4( ( int( color_add ) >> 16 ) & 0xff );

	//ivRedF = ivec4( uvbgr16 >> 10 ) & 0x1f;
	//ivGreenF = ivec4( uvbgr16 >> 5 ) & 0x1f;
	//ivBlueF = ivec4( uvbgr16 >> 0 ) & 0x1f;

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


#ifdef USE_NEW_SCANLINE_DRAW_SPRITE

	yid = ( xxid - StartY ) & xxmask;
	vxid =  ivec4( 0, 1, 2, 3 );
	
#else
	// align the compute units with pixels
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( StartX & group_vxmask );

	vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
#endif

	//iV = v0;
	iV = v0 + yid;


	w = EndX - StartX + 1;


	//barrier ();


	//for ( Line = StartY; Line <= EndY; Line++ )
	for ( Line = StartY + yid; Line <= EndY; Line += group_vyinc )
	{
		
			// need to start texture coord from left again
			//iU = u0;
			//iU = u0 + xid;
			ivU = u0 + vxid;

			TexCoordY = ( ( iV & Not_TWH ) | ( TWYTWH ) ) & 0xff;
			TexCoordY <<= 10;

			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = StartX + xid + ( Line << 10 );
			ivPtr = ( StartX + vxid ) + ( Line << 10 );

#ifdef USE_NATIVE_PIXELS
			// 2 pixels per 32-bit word
			//ivPtr >>= 1;
#endif


			// draw horizontal line

			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );



				//TexCoordX = ( ( iU & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				ivTexCoordX = ( ( ivU & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				// x-component should be shifted right 1 again since 2 pixels per?
				//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + TexCoordY;
				uvbgr[ 0 ] = VRAM [ ivIndex [ 0 ] ];
				uvbgr[ 1 ] = VRAM [ ivIndex [ 1 ] ];
				uvbgr[ 2 ] = VRAM [ ivIndex [ 2 ] ];
				uvbgr[ 3 ] = VRAM [ ivIndex [ 3 ] ];
				
				
				//if ( Shift1 != 0 )
				//{
				//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( int( bgr ) >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				//}
				ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );
				uvbgr2[0] = VRAM [ ivIndex [ 0 ] ];
				uvbgr2[1] = VRAM [ ivIndex [ 1 ] ];
				uvbgr2[2] = VRAM [ ivIndex [ 2 ] ];
				uvbgr2[3] = VRAM [ ivIndex [ 3 ] ];

				uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;
				
				//if ( bgr != 0 )
				//{
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					//uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
					//uvDestPixel = uvec4( VRAM [ ivPtr [ 3 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 0 ] ] );
					uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
					uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
					uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
					uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif

#ifdef USE_NATIVE_PIXELS
					uvDestPixel = uvDest;
					uvDestPixel.yw >>= 16;
					uvDestPixel &= 0xffff;
#endif

					
					//bgr_temp = bgr;
					
//#ifdef ENABLE_COLOR_MULTIPLY
					// color multiply //

					//if ( Command_TGE == 0 )
					//{
					//	// brightness calculation
					//	bgr_temp = ColorMultiply1624 ( bgr_temp, color_add );
					//}

					//ivRedC = ivec4( uvcolor_add >> 16 ) & 0xff;
					//ivGreenC = ivec4( uvcolor_add >> 8 ) & 0xff;
					//ivBlueC = ivec4( uvcolor_add >> 0 ) & 0xff;

					ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
					ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
					ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;

#ifdef USE_MORE_JUMPS
					if ( Command_TGE == 0 )
#endif
					{
					ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
					ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
					ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );
					
					//uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

					// no need for selection, because can color multiply with 0x80
					//uvbgr_temp = ( Command_TGE == 0 ) ? uvbgr_temp : uvbgr;
					}
//#endif


//#ifdef ENABLE_SEMI_TRANSPARENCY
					// semi-transparency //

#ifdef USE_MORE_JUMPS
					if ( Command_ABE != 0 )
#endif
					{
					// semi-transparency
					//if ( Command_ABE != 0 && ( bgr & 0x8000 ) != 0 )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					//}
					
					//ivRedF = ivec4( uvbgr_temp >> 0 ) & 0x1f;
					//ivBlueF = ivec4( uvbgr_temp >> 5 ) & 0x1f;
					//ivGreenF = ivec4( uvbgr_temp >> 10 ) & 0x1f;

					ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 0x1f );
					ivGreenF = clamp( ivGreenB, 0, 0x1f );
					ivBlueF = clamp( ivBlueB, 0, 0x1f );
					}

					uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

					// no need to select based on command_abe since can just set shift to 16 and sign to zero
					uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
//#endif
					
					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
					uvbgr_temp |= SetPixelMask | ( uvbgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;

					// only draw pixel if not key color (zero)
					uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );
					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


#ifdef USE_NATIVE_PIXELS
					// mask vram //
					uvDest [ 0 ] &= 0x0000ffff;
					uvDest [ 1 ] &= 0xffff0000;
					uvDest [ 2 ] &= 0x0000ffff;
					uvDest [ 3 ] &= 0xffff0000;
					uvDestPixel.yw <<= 16;
					uvDest |= uvDestPixel;
#endif

					
					// store pixels //
#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif
				//}
				
					
				/////////////////////////////////////////////////////////
				// interpolate texture coords across
				//iU += xinc;
				ivU += group_vxinc;
				
				// update pointer for pixel out
				ivPtr += group_vxinc;
					
			}
		
		iV += group_vyinc;
		
	}

	}	// end if ( bDraw == 1 )
	
#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x64 && Comm <= 0x67 ) || ( Comm >= 0x74 && Comm <= 0x77 ) || ( Comm >= 0x7c && Comm <= 0x7f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	//barrier ();

#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}






#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Mono ( uint uIndex )
#else
void vDrawTriangle_Mono ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;


	
	int Temp;
	int iStartX, iEndX;
	int x_across;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;

	int DitherValue;
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	int Red, Green, Blue;



	uint bgr16;
	//uint bgr32;

	//int w, h, xmax, ymax, ymax2;
	//int x, y;

	int group_yoffset;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	//uint Command_TGE;

	//uint color_add;
	//int clut_xoffset, clut_yoffset;
	//int clut_x, clut_y, tpage_tx, tpage_ty;
	//uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;

	uint PixelMask, SetPixelMask;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	int Coord0, Coord1, Coord2;


	int gx [ 3 ], gy [ 3 ];
	uint gbgr [ 3 ];

	uint bgr32;

	int x_left, x_right;
	int LeftMostX, RightMostX;

	int dR_left, dG_left, dB_left;
	int dR_across, dG_across, dB_across;
	int R_left, G_left, B_left;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	//int Shift1, Shift2, And1, And2;
	//int TextureOffset;
	//int ClutOffset;

	//int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	//int TWX, TWY, TWW, TWH;

	//int u0, v0, u1, v1, u2, v2;
	//int u, v;

	//int dU_left, dV_left;
	//int dU_across, dV_across;
	//int U_left, V_left;
	//int gu [ 3 ], gv [ 3 ];

	int dRx_across;
	int dGx_across;
	int dBx_across;

	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;


	uint Comm;
	uint bDraw;

	uint uIdx;
	uint uLoop;


	// setup local vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];


	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );
		//GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		
		//EndY = data [ uIdx + 11 ];
		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//TWYTWH = data [ uIdx + 16 ];
		//TWXTWW = data [ uIdx + 17 ];
		//Not_TWH = data [ uIdx + 18 ];
		//Not_TWW = data [ uIdx + 19 ];
		//TextureOffset = data [ uIdx + 20 ];
		//ClutOffset = data [ uIdx + 21 ];
		//clut_xoffset = data [ uIdx + 22 ];
		//tpage_abr = data [ uIdx + 23 ];
		//dR_across = data [ uIdx + 24 ];
		//dG_across = data [ uIdx + 25 ];
		//dB_across = data [ uIdx + 26 ];
		//dU_across = data [ uIdx + 27 ];
		//dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;
		

		//dRx_across = dR_across * group_vxinc;
		//dGx_across = dG_across * group_vxinc;
		//dBx_across = dB_across * group_vxinc;

		//dUx_across = dU_across * xinc;
		//dVx_across = dV_across * xinc;

	ivRedF = ivec4( ( bgr32 >> 3 ) & 0x1f );
	ivGreenF = ivec4( ( bgr32 >> 11 ) & 0x1f );
	ivBlueF = ivec4( ( bgr32 >> 19 ) & 0x1f );

	uvbgr_temp = uvec4( bgr16 );
	uvbgr_temp |= SetPixelMask;

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


	// align the compute units with pixels

	//barrier ();

		StartY = data [ uIdx + 30 + 0 ];
		EndY = data [ uIdx + 31 + 0 ];

#ifdef USE_NEW_SCANLINE_DRAW_TRIANGLE
		yid = ( xxid - StartY ) & xxmask;
#else
		// align the compute units with pixels
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
#endif

		//for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		for ( uLoop = ((yid + StartY) < EndY) ? 0 : 16; uLoop < 32; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];


		yid = ( xxid - StartY ) & xxmask;



		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		//R_left = data [ uIdx + 36 + uLoop ];
		//G_left = data [ uIdx + 37 + uLoop ];
		//B_left = data [ uIdx + 38 + uLoop ];
		//dR_left = data [ uIdx + 39 + uLoop ];
		//dG_left = data [ uIdx + 40 + uLoop ];
		//dB_left = data [ uIdx + 41 + uLoop ];
		//U_left = data [ uIdx + 42 ];
		//V_left = data [ uIdx + 43 ];
		//dU_left = data [ uIdx + 44 ];
		//dV_left = data [ uIdx + 45 ];
		

		




	
	/////////////////////////////////////////////
	// init x on the left and right
	
	

	//if ( EndY > StartY )
	//{
	


	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	//Roff_left = R_left + ( dR_left * (yid) );
	//Goff_left = G_left + ( dG_left * (yid) );
	//Boff_left = B_left + ( dB_left * (yid) );
	
	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			
			//iR = Roff_left;
			//iG = Goff_left;
			//iB = Boff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
			}
			
			//iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			//iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			//iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
#ifdef USE_NEW_SCANLINE_DRAW_TRIANGLE
			vxid =  ivec4( 0, 1, 2, 3 );
#else
			// align the compute units with pixels
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( iStartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
#endif

			w = iEndX - iStartX + 1;


			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = iStartX + xid + ( Line << 10 );
			ivPtr = ( iStartX + vxid ) + ( Line << 10 );

			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );
			//ivR = iR + ( dR_across * vxid );
			//ivG = iG + ( dG_across * vxid );
			//ivB = iB + ( dB_across * vxid );



			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

					
					//bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
					
					// shade pixel color
				
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
#endif
					
//#ifdef ENABLE_SEMI_TRANSPARENCY

#ifdef USE_MORE_JUMPS
				if ( Command_ABE != 0 )
#endif
				{
					// semi-transparency
					//if ( Command_ABE != 0 )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					//}

				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 0x1f );
				ivGreenB = clamp( ivGreenB, 0, 0x1f );
				ivBlueB = clamp( ivBlueB, 0, 0x1f );
//#endif

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );


					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask;
					uvbgr_temp |= SetPixelMask;
				}
					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					// *ptr = DestPixel;
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif
						
//#ifdef INC_ACROSS
					//iR += ( dRx_across );
					//iG += ( dGx_across );
					//iB += ( dBx_across );
					//ivR += dRx_across;
					//ivG += dGx_across;
					//ivB += dBx_across;
//#endif
				
				//ptr += xinc;
				ivPtr += group_vxinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * group_vyinc );
		xoff_right += ( dx_right * group_vyinc );
		
	}

	//} // end if ( EndY > StartY )
	

	}	// end for ( uLoop = 0; uLoop < 32; uLoop += 16 )
	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier();

	
	}	// end if ( bDraw == 1 )

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x30 && Comm <= 0x33 ) || ( Comm >= 0x38 && Comm <= 0x3b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}





#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Gradient ( uint uIndex )
#else
void vDrawTriangle_Gradient ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;

	int iLoopMax;

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_BottomRightX
//2: DrawArea_TopLeftX
//3: DrawArea_BottomRightY
//4: DrawArea_TopLeftY
//5: DrawArea_OffsetX
//6: DrawArea_OffsetY
//7: GetBGR0_8 ( Buffer [ 0 ] );
//8: GetXY0 ( Buffer [ 1 ] );
//9: GetBGR1_8 ( Buffer [ 2 ] );
//10: GetXY1 ( Buffer [ 3 ] );
//11: GetBGR2_8 ( Buffer [ 4 ] );
//12: GetXY2 ( Buffer [ 5 ] );

	
	int Temp;
	int iStartX, iEndX;
	int x_across;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;

	int DitherValue;
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	int Red, Green, Blue;



	//uint bgr16;
	//uint bgr32;

	//int w, h, xmax, ymax, ymax2;
	//int x, y;

	int group_yoffset;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	//uint Command_TGE;

	//uint color_add;
	//int clut_xoffset, clut_yoffset;
	//int clut_x, clut_y, tpage_tx, tpage_ty;
	//uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;

	uint PixelMask, SetPixelMask;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	int Coord0, Coord1, Coord2;


	int gx [ 3 ], gy [ 3 ];
	uint gbgr [ 3 ];

	int x_left, x_right;
	int LeftMostX, RightMostX;

	int dR_left, dG_left, dB_left;
	int dR_across, dG_across, dB_across;
	int R_left, G_left, B_left;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	//int Shift1, Shift2, And1, And2;
	//int TextureOffset;
	//int ClutOffset;

	//int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	//int TWX, TWY, TWW, TWH;

	//int u0, v0, u1, v1, u2, v2;
	//int u, v;

	//int dU_left, dV_left;
	//int dU_across, dV_across;
	//int U_left, V_left;
	//int gu [ 3 ], gv [ 3 ];

	int dRx_across;
	int dGx_across;
	int dBx_across;

	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 vEndX;
	ivec4 ivIndex;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;


	uint Comm;
	uint bDraw;

	uint uIdx;
	uint uLoop;


	// setup local vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		// this one needs to be 64 per element instead of 128
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;


		bDraw = data [ uIdx + 0 ];


	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		
		//EndY = data [ uIdx + 11 ];
		//Shift1 = data [ uIdx + 12 ];
		//Shift2 = data [ uIdx + 13 ];
		//And1 = data [ uIdx + 14 ];
		//And2 = data [ uIdx + 15 ];
		//TWYTWH = data [ uIdx + 16 ];
		//TWXTWW = data [ uIdx + 17 ];
		//Not_TWH = data [ uIdx + 18 ];
		//Not_TWW = data [ uIdx + 19 ];
		//TextureOffset = data [ uIdx + 20 ];
		//ClutOffset = data [ uIdx + 21 ];
		//clut_xoffset = data [ uIdx + 22 ];
		//tpage_abr = data [ uIdx + 23 ];
		dR_across = data [ uIdx + 24 ];
		dG_across = data [ uIdx + 25 ];
		dB_across = data [ uIdx + 26 ];
		//dU_across = data [ uIdx + 27 ];
		//dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;

		iLoopMax = data [ uIdx + 63 ];
		

		dRx_across = dR_across * group_vxinc;
		dGx_across = dG_across * group_vxinc;
		dBx_across = dB_across * group_vxinc;

		//dUx_across = dU_across * xinc;
		//dVx_across = dV_across * xinc;


	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( GPU_CTRL_Read_ABR )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


	// align the compute units with pixels

	//barrier ();


		StartY = data [ uIdx + 30 + 0 ];
		EndY = data [ uIdx + 31 + 0 ];

#ifdef USE_NEW_SCANLINE_DRAW_TRIANGLE
		yid = ( xxid - StartY ) & xxmask;
#else
		// align the compute units with pixels
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
#endif

		//for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		//for ( uLoop = ((yid + StartY) < EndY) ? 0 : 16; uLoop < 32; uLoop += 16 )
		for ( uLoop = ((yid + StartY) < EndY) ? 0 : 16; uLoop < iLoopMax; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];


		yid = ( xxid - StartY ) & xxmask;

		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		R_left = data [ uIdx + 36 + uLoop ];
		G_left = data [ uIdx + 37 + uLoop ];
		B_left = data [ uIdx + 38 + uLoop ];
		dR_left = data [ uIdx + 39 + uLoop ];
		dG_left = data [ uIdx + 40 + uLoop ];
		dB_left = data [ uIdx + 41 + uLoop ];
		//U_left = data [ uIdx + 42 ];
		//V_left = data [ uIdx + 43 ];
		//dU_left = data [ uIdx + 44 ];
		//dV_left = data [ uIdx + 45 ];
		

		




	
	/////////////////////////////////////////////
	// init x on the left and right
	
	

	//if ( EndY > StartY )
	//{
	



	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	Roff_left = R_left + ( dR_left * (yid) );
	Goff_left = G_left + ( dG_left * (yid) );
	Boff_left = B_left + ( dB_left * (yid) );
	
	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )
	{
		
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			
			iR = Roff_left;
			iG = Goff_left;
			iB = Boff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
			}
			
			iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
#ifdef USE_NEW_SCANLINE_DRAW_TRIANGLE
			vxid =  ivec4( 0, 1, 2, 3 );
#else
			// align the compute units with pixels
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( iStartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
#endif

			w = iEndX - iStartX + 1;


			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = iStartX + xid + ( Line << 10 );
			ivPtr = ( iStartX + vxid ) + ( Line << 10 );

			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );
			ivR = iR + ( dR_across * vxid );
			ivG = iG + ( dG_across * vxid );
			ivB = iB + ( dB_across * vxid );



			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

					
#ifdef USE_MORE_JUMPS
				if ( GPU_CTRL_Read_DTD != 0 )
#endif
				{
				ivIndex = ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 );
				ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );
				ivDitherValue[0] = c_iDitherValues16 [ ivIndex[0] ];
				ivDitherValue[1] = c_iDitherValues16 [ ivIndex[1] ];
				ivDitherValue[2] = c_iDitherValues16 [ ivIndex[2] ];
				ivDitherValue[3] = c_iDitherValues16 [ ivIndex[3] ];

				// perform dither
				ivRedF = ivR + ivDitherValue;
				ivGreenF = ivG + ivDitherValue;
				ivBlueF = ivB + ivDitherValue;
				
				// perform shift
				ivRedF >>= ( 16 + 3 );
				ivGreenF >>= ( 16 + 3 );
				ivBlueF >>= ( 16 + 3 );
				
				ivRedF = clamp ( ivRedF, 0, 31 );
				ivGreenF = clamp ( ivGreenF, 0, 31 );
				ivBlueF = clamp ( ivBlueF, 0, 31 );
				}
#ifdef USE_MORE_JUMPS
				else
				{
				ivRedF = ivR >> (16+3);
				ivGreenF = ivG >> (16+3);
				ivBlueF = ivB >> (16+3);
				}
#endif
					
					//bgr_temp = ( Blue << 10 ) | ( Green << 5 ) | Red;
					
					// shade pixel color
				
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
#endif
					
					
//#ifdef ENABLE_SEMI_TRANSPARENCY
					// semi-transparency
					//if ( Command_ABE != 0 )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
					//}

#ifdef USE_MORE_JUMPS
				if ( Command_ABE != 0 )
#endif
				{
				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedF = clamp( ivRedB, 0, 0x1f );
				ivGreenF = clamp( ivGreenB, 0, 0x1f );
				ivBlueF = clamp( ivBlueB, 0, 0x1f );
				}


				uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );


					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask;
					uvbgr_temp |= SetPixelMask;

					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );


					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					// *ptr = DestPixel;
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif
					
					//iR += ( dRx_across );
					//iG += ( dGx_across );
					//iB += ( dBx_across );
					ivR += dRx_across;
					ivG += dGx_across;
					ivB += dBx_across;
				
				//ptr += xinc;
				//iPtr += xinc;
				ivPtr += group_vxinc;
			}
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * group_vyinc );
		xoff_right += ( dx_right * group_vyinc );
		
		Roff_left += ( dR_left * group_vyinc );
		Goff_left += ( dG_left * group_vyinc );
		Boff_left += ( dB_left * group_vyinc );
	}

	//} // end if ( EndY > StartY )
	

	}	// end for ( uLoop = 0; uLoop < 32; uLoop += 16 )
	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right

	// synchronize local variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier();

	
	}	// end if ( bDraw == 1 )

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x30 && Comm <= 0x33 ) || ( Comm >= 0x38 && Comm <= 0x3b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}







#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
uint vDrawTriangle_TextureGradient ( uint uIndex )
#else
void vDrawTriangle_TextureGradient ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;

	int iLoopMax;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	int Line;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;

	ivec4 Coff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;

	ivec4 Toff_left;
	
	
	int xoff_left, xoff_right;
	ivec4 xoff;

	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	//global u16* local ptr_texture;
	//global u16* local ptr_clut;
	
	int TexCoordX, TexCoordY;



//uint bgr16;
//uint bgr32;

//int w, h, xmax, ymax, ymax2;
//int x, y;

//int group_yoffset;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;
uint GPU_CTRL_Read_DTD;
uint Command_TGE;

//uint color_add;
int clut_xoffset, clut_yoffset;
int clut_x, clut_y, tpage_tx, tpage_ty;
uint tpage_abr, tpage_tp, command_abr;

int StartX, EndX, StartY, EndY;

uint PixelMask, SetPixelMask;

int x0, x1, x2, y0, y1, y2;

int dx_left, dx_right;
int t0, t1, denominator;

int Coord0, Coord1, Coord2;


int gx [ 3 ], gy [ 3 ];
uint gbgr [ 3 ];

int x_left, x_right;
int LeftMostX, RightMostX;

ivec4 x, dx;

int dR_left, dG_left, dB_left;
int dR_across, dG_across, dB_across;
int R_left, G_left, B_left;
int r0, r1, r2, g0, g1, g2, b0, b1, b2;

ivec4 iC, dC_left, dC_across, C_left, dCx_across;


int Shift1, Shift2, And1, And2;
int TextureOffset;
int ClutOffset;

	int bTexture;

int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
int TWX, TWY, TWW, TWH;

int u0, v0, u1, v1, u2, v2;
int u, v;

int dU_left, dV_left;
int dU_across, dV_across;
int U_left, V_left;
int gu [ 3 ], gv [ 3 ];

ivec4 iT, dT_left, dT_across, T_left, dTx_across;

int dUx_across;
int dVx_across;

int dRx_across;
int dGx_across;
int dBx_across;


	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	uvec4 uvbgr, uvbgr2;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivTexCoordY;
	ivec4 ivTexCoordX;
	ivec4 ivU;
	ivec4 ivV;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;


	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;


	//barrier ();

	// setup vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
	do
	{
#endif
		

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		// this one needs to be 64 per element instead of 128 per element
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;


		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];
		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];
		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];

		iLoopMax = data [ uIdx + 63 ];


		//dR_across = data [ uIdx + 24 ];
		//dG_across = data [ uIdx + 25 ];
		//dB_across = data [ uIdx + 26 ];
		dC_across.r = data [ uIdx + 24 ];
		dC_across.g = data [ uIdx + 25 ];
		dC_across.b = data [ uIdx + 26 ];


		//dU_across = data [ uIdx + 27 ];
		//dV_across = data [ uIdx + 28 ];
		dT_across.s = data [ uIdx + 27 ];
		dT_across.t = data [ uIdx + 28 ];


		bTexture = data [ uIdx + 29 ];


		//dRx_across = dR_across * group_vxinc;
		//dGx_across = dG_across * group_vxinc;
		//dBx_across = dB_across * group_vxinc;
		dCx_across.rgb = dC_across.rgb * group_vxinc;

		//dUx_across = dU_across * group_vxinc;
		//dVx_across = dV_across * group_vxinc;
		dTx_across.st = dT_across.st * group_vxinc;

	//if ( Command_TGE != 0 )
	//{
	//	color_add = 0x00808080;
	//}

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( tpage_abr )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


		StartY = data [ uIdx + 30 + 0 ];
		EndY = data [ uIdx + 31 + 0 ];

#ifdef USE_NEW_SCANLINE_DRAW_TRIANGLE
		yid = ( xxid - StartY ) & xxmask;
#else
		// align the compute units with pixels
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
#endif

		//for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		//for ( uLoop = ((yid + StartY) < EndY) ? 0 : 16; uLoop < 32; uLoop += 16 )
		for ( uLoop = ((yid + StartY) < EndY) ? 0 : 16; uLoop < iLoopMax; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];


		yid = ( xxid - StartY ) & xxmask;

		//x_left = data [ uIdx + 32 + uLoop ];
		//x_right = data [ uIdx + 33 + uLoop ];
		//dx_left = data [ uIdx + 34 + uLoop ];
		//dx_right = data [ uIdx + 35 + uLoop ];
		x.x = data [ uIdx + 32 + uLoop ];
		x.y = data [ uIdx + 33 + uLoop ];
		dx.x = data [ uIdx + 34 + uLoop ];
		dx.y = data [ uIdx + 35 + uLoop ];

		//R_left = data [ uIdx + 36 + uLoop ];
		//G_left = data [ uIdx + 37 + uLoop ];
		//B_left = data [ uIdx + 38 + uLoop ];
		C_left.r = data [ uIdx + 36 + uLoop ];
		C_left.g = data [ uIdx + 37 + uLoop ];
		C_left.b = data [ uIdx + 38 + uLoop ];

		//dR_left = data [ uIdx + 39 + uLoop ];
		//dG_left = data [ uIdx + 40 + uLoop ];
		//dB_left = data [ uIdx + 41 + uLoop ];
		dC_left.r = data [ uIdx + 39 + uLoop ];
		dC_left.g = data [ uIdx + 40 + uLoop ];
		dC_left.b = data [ uIdx + 41 + uLoop ];

		//U_left = data [ uIdx + 42 + uLoop ];
		//V_left = data [ uIdx + 43 + uLoop ];
		//dU_left = data [ uIdx + 44 + uLoop ];
		//dV_left = data [ uIdx + 45 + uLoop ];
		T_left.s = data [ uIdx + 42 + uLoop ];
		T_left.t = data [ uIdx + 43 + uLoop ];
		dT_left.s = data [ uIdx + 44 + uLoop ];
		dT_left.t = data [ uIdx + 45 + uLoop ];
		

		
		
	

	//if ( EndY > StartY )
	//{
	

	// in opencl, each worker could be on a different line
	//xoff_left = x_left + ( dx_left * (yid) );
	//xoff_right = x_right + ( dx_right * (yid) );
	xoff.xy = x.xy + ( dx.xy * (yid) );
	
	//Roff_left = R_left + ( dR_left * (yid) );
	//Goff_left = G_left + ( dG_left * (yid) );
	//Boff_left = B_left + ( dB_left * (yid) );
	Coff_left.rgb = C_left.rgb + ( dC_left.rgb * (yid) );
	
	//Uoff_left = U_left + ( dU_left * (yid) );
	//Voff_left = V_left + ( dV_left * (yid) );
	Toff_left.st = T_left.st + ( dT_left.st * (yid) );
	

	//////////////////////////////////////////////
	// draw down to y1
	//for ( Line = StartY; Line < EndY; Line++ )
	for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )
	{
		// left point is included if points are equal
		//iStartX = ( xoff_left + 0xffff ) >> 16;
		//iEndX = ( xoff_right - 1 ) >> 16;
		iStartX = ( xoff.x + 0xffff ) >> 16;
		iEndX = ( xoff.y - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			//iR = Roff_left;
			//iG = Goff_left;
			//iB = Boff_left;
			iC.rgb = Coff_left.rgb;
			
			//iU = Uoff_left;
			//iV = Voff_left;
			iT.st = Toff_left.st;
			
			// get the difference between x_left and StartX
			//Temp = ( iStartX << 16 ) - xoff_left;
			Temp = ( iStartX << 16 ) - xoff.x;
			
			//if ( iStartX < DrawArea_TopLeftX )
			//{
			//	Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
			//	iStartX = DrawArea_TopLeftX;
			//}
			Temp += ( DrawArea_TopLeftX - min( iStartX, DrawArea_TopLeftX ) ) << 16;
			iStartX = max( iStartX, DrawArea_TopLeftX );
			
			//iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			//iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			//iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			iC.rgb += ( dC_across.rgb >> 8 ) * ( Temp >> 8 );
			
			//iU += ( dU_across >> 8 ) * ( Temp >> 8 );
			//iV += ( dV_across >> 8 ) * ( Temp >> 8 );
			iT.st += ( dT_across.st >> 8 ) * ( Temp >> 8 );
			
			//if ( iEndX > DrawArea_BottomRightX )
			//{
			//	//EndX = DrawArea_BottomRightX + 1;
			//	iEndX = DrawArea_BottomRightX;
			//}
			iEndX = min( iEndX, DrawArea_BottomRightX );
			
			// align the compute units with pixels
#ifdef USE_NEW_SCANLINE_DRAW_TRIANGLE
			vxid =  ivec4( 0, 1, 2, 3 );
#else
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( iStartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
#endif

			w = iEndX - iStartX + 1;


			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = iStartX + xid + ( Line << 10 );
			ivPtr = ( iStartX + vxid ) + ( Line << 10 );


			//DitherLine = & ( DitherArray [ ( Line & 0x3 ) << 2 ] );
			
			
			//ivR = iR + ( dR_across * vxid );
			//ivG = iG + ( dG_across * vxid );
			//ivB = iB + ( dB_across * vxid );
			ivR = iC.r + ( dC_across.r * vxid );
			ivG = iC.g + ( dC_across.g * vxid );
			ivB = iC.b + ( dC_across.b * vxid );

			//ivU = iU + ( dU_across * vxid );
			//ivV = iV + ( dV_across * vxid );
			ivU = iT.s + ( dT_across.s * vxid );
			ivV = iT.t + ( dT_across.t * vxid );
			
			// set bgr in case not a texture
			uvbgr = uvec4( 0xffff );
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );


				// dest pixels //

				// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
				uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
				//DestPixel = *ptr;
				//DestPixel = VRAM [ iPtr ];
				uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
				uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
				uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
				uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif

				ivRedF = ivec4( 0x10 );
				ivGreenF = ivec4( 0x10 );
				ivBlueF = ivec4( 0x10 );

				// texture mapping //

				if ( bTexture != 0 )
				{
				//TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				//TexCoordY <<= 10;
				//TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				ivTexCoordY = ( ( ( ivV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				ivTexCoordY <<= 10;
				ivTexCoordX = ( ( ( ivU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				// x-component should be shifted right 1 again since 2 pixels per?
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + ivTexCoordY;
				uvbgr[ 0 ] = VRAM [ ivIndex [ 0 ] ];
				uvbgr[ 1 ] = VRAM [ ivIndex [ 1 ] ];
				uvbgr[ 2 ] = VRAM [ ivIndex [ 2 ] ];
				uvbgr[ 3 ] = VRAM [ ivIndex [ 3 ] ];
				


#ifdef USE_MORE_JUMPS
				if ( Shift1 != 0 )
#endif
				{
					//if ( Shift1 != 0 )
					//{
					//	//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
					//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
					//}
					ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );
					uvbgr2[0] = VRAM [ ivIndex [ 0 ] ];
					uvbgr2[1] = VRAM [ ivIndex [ 1 ] ];
					uvbgr2[2] = VRAM [ ivIndex [ 2 ] ];
					uvbgr2[3] = VRAM [ ivIndex [ 3 ] ];

					uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;
				}
				
				ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
				ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
				ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;

				}	// end if ( bTexture )


				// color gradient //

				// shade pixel color
					
					
				//bgr_temp = bgr;


#ifdef USE_MORE_JUMPS
				if ( Command_TGE == 0 )
#endif
				{


#ifdef USE_MORE_JUMPS
					if ( GPU_CTRL_Read_DTD != 0 )
#endif
					{

						ivIndex = ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 );
						ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );
						ivDitherValue[0] = c_iDitherValues16 [ ivIndex[0] ];
						ivDitherValue[1] = c_iDitherValues16 [ ivIndex[1] ];
						ivDitherValue[2] = c_iDitherValues16 [ ivIndex[2] ];
						ivDitherValue[3] = c_iDitherValues16 [ ivIndex[3] ];

						// perform dither
						ivRedC = ivR + ivDitherValue;
						ivGreenC = ivG + ivDitherValue;
						ivBlueC = ivB + ivDitherValue;
				
						ivRedC = clamp ( ivRedC, 0, 255 << 16 );
						ivGreenC = clamp ( ivGreenC, 0, 255 << 16 );
						ivBlueC = clamp ( ivBlueC, 0, 255 << 16 );

					}	// end if ( GPU_CTRL_Read_DTD != 0 )

					// perform shift
					ivRedC >>= ( 16 );
					ivGreenC >>= ( 16 );
					ivBlueC >>= ( 16 );

					ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
					ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
					ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );

				}	// end if ( Command_TGE == 0 )


				// blending //

#ifdef USE_MORE_JUMPS
				if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )
#endif
				{

					// semi-transparency
					//if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					//}
					ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 0x1f );
					ivGreenF = clamp( ivGreenB, 0, 0x1f );
					ivBlueF = clamp( ivBlueB, 0, 0x1f );

				}	// end if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )


				uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );


				if ( bTexture != 0 )
				{

				// no need to select based on command_abe since can just set shift to 16 and sign to zero
				uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
					
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
				uvbgr_temp |= ( uvbgr & 0x8000 );

				}	// end if ( bTexture )


				uvbgr_temp |= SetPixelMask;


				// select pixels to draw //

				// only draw pixel if not key color (zero)
				uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;
				// draw pixel if we can draw to mask pixels or mask bit not set
				//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


				// draw/store pixels //

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );

				// store pixels //
#ifdef USE_VECTOR_LOADSTORE
				VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
				//VRAM [ iPtr ] = DestPixel;
				VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
				VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
				VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
				VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif

						
				//ivR += ( dRx_across );
				//ivG += ( dGx_across );
				//ivB += ( dBx_across );
				ivR += ( dCx_across.r );
				ivG += ( dCx_across.g );
				ivB += ( dCx_across.b );
			
				//ivU += ( dUx_across );
				//ivV += ( dVx_across );
				ivU += ( dTx_across.s );
				ivV += ( dTx_across.t );
					
				//ptr += xinc;
				//iPtr += xinc;
				ivPtr += group_vxinc;
				
				
			}	// end for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )

			
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		//xoff_left += ( dx_left * group_vyinc );
		//xoff_right += ( dx_right * group_vyinc );
		xoff.xy += ( dx.xy * group_vyinc );
		
		//Roff_left += ( dR_left * group_vyinc );
		//Goff_left += ( dG_left * group_vyinc );
		//Boff_left += ( dB_left * group_vyinc );
		Coff_left.rgb += ( dC_left.rgb * group_vyinc );
		
		//Uoff_left += ( dU_left * group_vyinc );
		//Voff_left += ( dV_left * group_vyinc );
		Toff_left.st += ( dT_left.st * group_vyinc );

	}	// end for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )

	//} // end if ( EndY > StartY )

	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	

	}	// end if ( bDraw == 1 )


#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;

	} while ( ( ( Comm >= 0x03 && Comm <= 0x39 ) || ( Comm >= 0x60 && Comm <= 0x79 ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
	//} while ( ( ( Comm >= 0x34 && Comm <= 0x37 ) || ( Comm >= 0x3c && Comm <= 0x3f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	//barrier ();

#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
		
}







#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Texture ( uint uIndex )
#else
void vDrawTriangle_Texture ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	int iPtr;


	
	//global u16* private ptr;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	int Line;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;
	

	
	int xoff_left, xoff_right;
	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	//global u16* local ptr_texture;
	//global u16* local ptr_clut;
	
	int TexCoordX, TexCoordY;



//uint bgr16;
//uint bgr32;

//int w, h, xmax, ymax, ymax2;
//int x, y;

//int group_yoffset;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;
uint GPU_CTRL_Read_DTD;
uint Command_TGE;

//uint color_add;
int clut_xoffset, clut_yoffset;
int clut_x, clut_y, tpage_tx, tpage_ty;
uint tpage_abr, tpage_tp, command_abr;

int StartX, EndX, StartY, EndY;

uint PixelMask, SetPixelMask;

int x0, x1, x2, y0, y1, y2;

int dx_left, dx_right;
int t0, t1, denominator;

int Coord0, Coord1, Coord2;


int gx [ 3 ], gy [ 3 ];
uint gbgr [ 3 ];

uint bgr32;

int x_left, x_right;
int LeftMostX, RightMostX;

int dR_left, dG_left, dB_left;
int dR_across, dG_across, dB_across;
int R_left, G_left, B_left;
int r0, r1, r2, g0, g1, g2, b0, b1, b2;

int Shift1, Shift2, And1, And2;
int TextureOffset;
int ClutOffset;

int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
int TWX, TWY, TWW, TWH;

int u0, v0, u1, v1, u2, v2;
int u, v;

int dU_left, dV_left;
int dU_across, dV_across;
int U_left, V_left;
int gu [ 3 ], gv [ 3 ];

int dUx_across;
int dVx_across;

int dRx_across;
int dGx_across;
int dBx_across;


	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	uvec4 uvbgr, uvbgr2;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivTexCoordY;
	ivec4 ivTexCoordX;
	ivec4 ivU;
	ivec4 ivV;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;


	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;


	//barrier ();

	// setup vars
	//if ( ( xid + yid ) == 0 )
	//{
		uIndex <<= 4;
		
#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		
		uIdx = uIndex << 3;
		bDraw = data [ uIdx + 0 ];

	if ( bDraw == 1 )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );
		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );
		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];
		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];
		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];
		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];
		//dR_across = data [ uIdx + 24 ];
		//dG_across = data [ uIdx + 25 ];
		//dB_across = data [ uIdx + 26 ];
		dU_across = data [ uIdx + 27 ];
		dV_across = data [ uIdx + 28 ];
		//data [ uIdx + 29 ] = v0;

		//dRx_across = dR_across * group_vxinc;
		//dGx_across = dG_across * group_vxinc;
		//dBx_across = dB_across * group_vxinc;

		dUx_across = dU_across * group_vxinc;
		dVx_across = dV_across * group_vxinc;

	if ( Command_TGE != 0 )
	{
		bgr32 = 0x00808080;
	}

	ivRedC = ivec4( ( bgr32 >> 0 ) & 0xff );
	ivGreenC = ivec4( ( bgr32 >> 8 ) & 0xff );
	ivBlueC = ivec4( ( bgr32 >> 16 ) & 0xff );

	iBShift = 31;
	iFShift = 0;
	iFSign = 0;
	if( Command_ABE != 0 )
	{
		switch( tpage_abr )
		{
			//0.5B + 0.5F
			case 0:
				iBShift = 1;
				iFShift = 1;
				break;
			//1.0B + 1.0F
			case 1:
				iBShift = 0;
				iFShift = 0;
				break;
			//1.0B - 1.0F
			case 2:
				iBShift = 0;
				iFShift = 0;
				iFSign = -1;
				break;
			//1.0B + 0.25F
			case 3:
				iBShift = 0;
				iFShift = 2;
				break;
		}
	}


		StartY = data [ uIdx + 30 + 0 ];
		EndY = data [ uIdx + 31 + 0 ];

#ifdef USE_NEW_SCANLINE_DRAW_TRIANGLE
		yid = ( xxid - StartY ) & xxmask;
#else
		// align the compute units with pixels
		yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;
#endif

		//for ( uLoop = 0; uLoop < 32; uLoop += 16 )
		for ( uLoop = ((yid + StartY) < EndY) ? 0 : 16; uLoop < 32; uLoop += 16 )
		{

		StartY = data [ uIdx + 30 + uLoop ];
		EndY = data [ uIdx + 31 + uLoop ];


		yid = ( xxid - StartY ) & xxmask;

		x_left = data [ uIdx + 32 + uLoop ];
		x_right = data [ uIdx + 33 + uLoop ];
		dx_left = data [ uIdx + 34 + uLoop ];
		dx_right = data [ uIdx + 35 + uLoop ];
		//R_left = data [ uIdx + 36 + uLoop ];
		//G_left = data [ uIdx + 37 + uLoop ];
		//B_left = data [ uIdx + 38 + uLoop ];
		//dR_left = data [ uIdx + 39 + uLoop ];
		//dG_left = data [ uIdx + 40 + uLoop ];
		//dB_left = data [ uIdx + 41 + uLoop ];
		U_left = data [ uIdx + 42 + uLoop ];
		V_left = data [ uIdx + 43 + uLoop ];
		dU_left = data [ uIdx + 44 + uLoop ];
		dV_left = data [ uIdx + 45 + uLoop ];
		

		
		
	

	//if ( EndY > StartY )
	//{
	

	// in opencl, each worker could be on a different line
	xoff_left = x_left + ( dx_left * (yid) );
	xoff_right = x_right + ( dx_right * (yid) );
	
	//Roff_left = R_left + ( dR_left * (yid) );
	//Goff_left = G_left + ( dG_left * (yid) );
	//Boff_left = B_left + ( dB_left * (yid) );
	
	Uoff_left = U_left + ( dU_left * (yid) );
	Voff_left = V_left + ( dV_left * (yid) );
	

	//////////////////////////////////////////////
	// draw down to y1
	//for ( Line = StartY; Line < EndY; Line++ )
	for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )
	{
		// left point is included if points are equal
		iStartX = ( xoff_left + 0xffff ) >> 16;
		iEndX = ( xoff_right - 1 ) >> 16;
		
		
		if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			//iR = Roff_left;
			//iG = Goff_left;
			//iB = Boff_left;
			
			iU = Uoff_left;
			iV = Voff_left;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff_left;
			
			if ( iStartX < DrawArea_TopLeftX )
			{
				Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
				iStartX = DrawArea_TopLeftX;
				
			}
			
			//iR += ( dR_across >> 8 ) * ( Temp >> 8 );
			//iG += ( dG_across >> 8 ) * ( Temp >> 8 );
			//iB += ( dB_across >> 8 ) * ( Temp >> 8 );
			
			iU += ( dU_across >> 8 ) * ( Temp >> 8 );
			iV += ( dV_across >> 8 ) * ( Temp >> 8 );
			
			if ( iEndX > DrawArea_BottomRightX )
			{
				//EndX = DrawArea_BottomRightX + 1;
				iEndX = DrawArea_BottomRightX;
			}
			
			// align the compute units with pixels
#ifdef USE_NEW_SCANLINE_DRAW_TRIANGLE
			vxid =  ivec4( 0, 1, 2, 3 );
#else
			//xid = ( ( ( cxid << group_xshift ) + group_x ) - iStartX ) & group_xmask;

			xid = ( ( cxid << group_xshift ) + group_x );
			vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
			vxid = ( vxid ) - ( iStartX & group_vxmask );

			vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
#endif

			w = iEndX - iStartX + 1;


			//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
			//iPtr = iStartX + xid + ( Line << 10 );
			ivPtr = ( iStartX + vxid ) + ( Line << 10 );


			//DitherLine = & ( DitherArray [ ( Line & 0x3 ) << 2 ] );
			
			
			//iR += ( dR_across * xid );
			//iG += ( dG_across * xid );
			//iB += ( dB_across * xid );
			//ivR = iR + ( dR_across * vxid );
			//ivG = iG + ( dG_across * vxid );
			//ivB = iB + ( dB_across * vxid );

			//iU += ( dU_across * xid );
			//iV += ( dV_across * xid );
			ivU = iU + ( dU_across * vxid );
			ivV = iV + ( dV_across * vxid );
			
			
			// draw horizontal line
			// x_left and x_right need to be rounded off
			//for ( x_across = iStartX + xid; x_across <= iEndX; x_across += xinc )
			for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
			{
				// check what pixels are enabled
				bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );
				
				//TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				//TexCoordY <<= 10;
				//TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				ivTexCoordY = ( ( ( ivV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				ivTexCoordY <<= 10;
				ivTexCoordX = ( ( ( ivU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				// x-component should be shifted right 1 again since 2 pixels per?
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + ivTexCoordY;
				uvbgr[ 0 ] = VRAM [ ivIndex [ 0 ] ];
				uvbgr[ 1 ] = VRAM [ ivIndex [ 1 ] ];
				uvbgr[ 2 ] = VRAM [ ivIndex [ 2 ] ];
				uvbgr[ 3 ] = VRAM [ ivIndex [ 3 ] ];
				
#ifdef USE_MORE_JUMPS
				if ( Shift1 != 0 )
#endif
				{

				//if ( Shift1 != 0 )
				//{
				//	//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
				//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
				//}
				ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );
				uvbgr2[0] = VRAM [ ivIndex [ 0 ] ];
				uvbgr2[1] = VRAM [ ivIndex [ 1 ] ];
				uvbgr2[2] = VRAM [ ivIndex [ 2 ] ];
				uvbgr2[3] = VRAM [ ivIndex [ 3 ] ];

				uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;
				}
				
				//if ( bgr != 0 )
				//{
					
					// shade pixel color
					
					// read pixel from frame buffer if we need to check mask bit
#ifdef USE_VECTOR_LOADSTORE
					uvDestPixel = VRAM4 [ ivPtr [ 0 ] >> 2 ];
#else
					//DestPixel = *ptr;
					//DestPixel = VRAM [ iPtr ];
					uvDestPixel [ 0 ] = VRAM [ ivPtr [ 0 ] ];
					uvDestPixel [ 1 ] = VRAM [ ivPtr [ 1 ] ];
					uvDestPixel [ 2 ] = VRAM [ ivPtr [ 2 ] ];
					uvDestPixel [ 3 ] = VRAM [ ivPtr [ 3 ] ];
#endif
					
					//bgr_temp = bgr;
		



				ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
				ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
				ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;

#ifdef USE_MORE_JUMPS
				if ( Command_TGE == 0 )
#endif
				{
				ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
				ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
				ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );
				}

#ifdef USE_MORE_JUMPS
					if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )
#endif
					{
					// semi-transparency
					//if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					//}
					ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 0x1f );
					ivGreenF = clamp( ivGreenB, 0, 0x1f );
					ivBlueF = clamp( ivBlueB, 0, 0x1f );
					}

					uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

					// no need to select based on command_abe since can just set shift to 16 and sign to zero
					uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
					
					// check if we should set mask bit when drawing
					//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
					uvbgr_temp |= SetPixelMask | ( uvbgr & 0x8000 );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;

					// only draw pixel if not key color (zero)
					uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );
					
					// draw pixel if we can draw to mask pixels or mask bit not set
					//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
					uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

					// only enabled pixels should be active
					uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );

					// draw pixel if we can draw to mask pixels or mask bit not set
					//if ( ! ( DestPixel & PixelMask ) ) *ptr = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
					//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );

					// store pixels //
#ifdef USE_VECTOR_LOADSTORE
					VRAM4 [ ivPtr [ 0 ] >> 2 ] = uvDestPixel;
#else
					//VRAM [ iPtr ] = DestPixel;
					VRAM [ ivPtr [ 0 ] ] = uvDestPixel[ 0 ];
					VRAM [ ivPtr [ 1 ] ] = uvDestPixel[ 1 ];
					VRAM [ ivPtr [ 2 ] ] = uvDestPixel[ 2 ];
					VRAM [ ivPtr [ 3 ] ] = uvDestPixel[ 3 ];
#endif

				//}
						
				//ivR += ( dRx_across );
				//ivG += ( dGx_across );
				//ivB += ( dBx_across );
			
				ivU += ( dUx_across );
				ivV += ( dVx_across );
					
				//ptr += xinc;
				//iPtr += xinc;
				ivPtr += group_vxinc;
				
				
			}

			
			
		}
		
		
		/////////////////////////////////////
		// update x on left and right
		xoff_left += ( dx_left * group_vyinc );
		xoff_right += ( dx_right * group_vyinc );
		
		//Roff_left += ( dR_left * group_vyinc );
		//Goff_left += ( dG_left * group_vyinc );
		//Boff_left += ( dB_left * group_vyinc );
		
		Uoff_left += ( dU_left * group_vyinc );
		Voff_left += ( dV_left * group_vyinc );
	}

	//} // end if ( EndY > StartY )

	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	

	}	// end if ( bDraw == 1 )
	
#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x34 && Comm <= 0x37 ) || ( Comm >= 0x3c && Comm <= 0x3f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	//barrier ();


#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}






#ifdef ENABLE_PRIMITIVE_LOOP
uint Transfer_MoveImage_80 ( uint uIndex )
#else
void Transfer_MoveImage_80 ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	int xid = int( gl_GlobalInvocationID.x );
	int yid = int( gl_GlobalInvocationID.y );
	

	uint SrcPixel, DstPixel;
	uint DestPixel;
	
	int CurX, CurY;
	//global u16* private SrcPtr;
	//global u16* private DstPtr;
	//global u16* private SrcLinePtr;
	//global u16* private DstLinePtr;
	int iSrcPtr;
	int iDstPtr;
	int iSrcLinePtr;
	int iDstLinePtr;


	uint GPU_CTRL_Read;
	int w;
	int h;
	int Width;
	int Height;
	int sX;
	int sY;
	int dX;
	int dY;

	int bOverlap;

	uint PixelMask;
	uint SetPixelMask;
	int SrcStartX;
	int DstStartX;
	int SrcStartY;
	int DstStartY;

	int SrcEndX;
	int SrcEndY;
	int DstEndX;
	int DstEndY;

	uint Comm;
	
	//if ( (xid + yid) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		w = int( inputdata [ uIndex + 10 ] );
		h = w >> 16;

		// Xsiz=((Xsiz-1) AND 3FFh)+1
		Width = ( ( w - 1 ) & 0x3ff ) + 1;
		
		// Ysiz=((Ysiz-1) AND 1FFh)+1
		Height = ( ( h - 1 ) & 0x1ff ) + 1;

		
		sX = int( inputdata [ uIndex + 8 ] );
		sY = sX >> 16;
		dX = int( inputdata [ uIndex + 9 ] );
		dY = dX >> 16;

		// nocash psx specifications: transfer/move vram-to-vram use masking
		// ME is bit 12
		//if ( GPU_CTRL_Read.ME ) PixelMask = 0x8000;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		//if ( GPU_CTRL_Read.MD ) SetPixelMask = 0x8000;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;
		
		// xpos & 0x3ff
		//sX &= 0x3ff;
		SrcStartX = sX & 0x3ff;
		//dX &= 0x3ff;
		DstStartX = dX & 0x3ff;
		
		// ypos & 0x1ff
		//sY &= 0x1ff;
		SrcStartY = sY & 0x1ff;
		//dY &= 0x1ff;
		DstStartY = dY & 0x1ff;
		
		
		// *** NOTE: coordinates wrap *** //
		
		//SrcXRun = c_lFrameBuffer_Width - SrcStartX;
		//SrcXRun = ( Width <= SrcXRun ) ? Width : SrcXRun;
		
		//DstXRun = c_lFrameBuffer_Width - DstStartX;
		//DstXRun = ( Width <= DstXRun ) ? Width : DstXRun;
		
		//Width1 = ( SrcXRun < DstXRun ) ? SrcXRun : DstXRun;
		//Width2 = ( SrcXRun > DstXRun ) ? SrcXRun : DstXRun;

		// check for over lap
		SrcEndX = SrcStartX + Width;
		SrcEndY = SrcStartY + Height;
		DstEndX = DstStartX + Width;
		DstEndY = DstStartY + Height;

		bOverlap = 1;
		if ( DstStartX >= SrcEndX || DstEndX <= SrcStartX || DstStartY >= SrcEndY || DstEndY <= DstStartY )
		{
			bOverlap = 0;
		}
	
	//}

	
#ifdef SYNC_BEFORE_MOVE

	barrier ();

#endif


#ifdef USE_NEW_SCANLINE_DRAW_MOVE

	yid = ( xxid - DstStartY ) & xxmask;
	xid = 0;

	// check if source and destination boxes overlap or not
	if ( bOverlap == 0 )
	{
		//for ( CurY = yid; CurY < Height; CurY += yinc )
		for ( CurY = yid; CurY < Height; CurY += xxinc )
		{
			// start Src/Dst pointers for line
			//SrcLinePtr = & ( VRAM [ ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10 ] );
			//DstLinePtr = & ( VRAM [ ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10 ] );
			iSrcLinePtr = ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
			iDstLinePtr = ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		
			//for ( CurX = xid; CurX < Width; CurX += xinc )
			for ( CurX = xid; CurX < Width; CurX += 1 )
			{
				iSrcPtr = iSrcLinePtr + ( ( SrcStartX + CurX ) & c_lFrameBuffer_Width_Mask );
				iDstPtr = iDstLinePtr + ( ( DstStartX + CurX ) & c_lFrameBuffer_Width_Mask );

				//SrcPixel = VRAM [ iSrcPtr ];
				//DstPixel = VRAM [ iDstPtr ];
				SrcPixel = VRAM [ iSrcPtr ];
				DstPixel = VRAM [ iDstPtr ];
				SrcPixel |= SetPixelMask;

				//if ( ( DstPixel & PixelMask ) == 0 ) sVRAM [ iDstPtr ] = ( SrcPixel | SetPixelMask );
				VRAM [ iDstPtr ] = ( ( ( DstPixel & PixelMask ) == 0 ) ? SrcPixel : DstPixel );
			}

		}
	}
	else
	{
		//for ( CurY = yid; CurY < Height; CurY += yinc )
		for ( CurY = yid; CurY < Height; CurY += xxinc )
		{
			// start Src/Dst pointers for line
			//SrcLinePtr = & ( VRAM [ ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10 ] );
			//DstLinePtr = & ( VRAM [ ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10 ] );
			iSrcLinePtr = ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
			iDstLinePtr = ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		
			//for ( CurX = xid; CurX < Width; CurX += xinc )
			for ( CurX = xid; CurX < Width; CurX += 1 )
			{
				iSrcPtr = iSrcLinePtr + ( ( SrcStartX + CurX ) & c_lFrameBuffer_Width_Mask );
				iDstPtr = iDstLinePtr + ( ( DstStartX + CurX ) & c_lFrameBuffer_Width_Mask );

				//SrcPixel = VRAM [ iSrcPtr ];
				//DstPixel = VRAM [ iDstPtr ];

				//if ( ( DstPixel & PixelMask ) == 0 ) sVRAM [ iDstPtr ] = ( SrcPixel | SetPixelMask );
				sVRAM [ iDstPtr ] = VRAM [ iSrcPtr ];
			}

		}

		barrier ();

		//for ( CurY = yid; CurY < Height; CurY += yinc )
		for ( CurY = yid; CurY < Height; CurY += xxinc )
		{
			// start Src/Dst pointers for line
			//iSrcLinePtr = ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
			iDstLinePtr = ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		
			//for ( CurX = xid; CurX < Width; CurX += xinc )
			for ( CurX = xid; CurX < Width; CurX += 1 )
			{
				//iSrcPtr = iSrcLinePtr + ( ( SrcStartX + CurX ) & c_lFrameBuffer_Width_Mask );
				iDstPtr = iDstLinePtr + ( ( DstStartX + CurX ) & c_lFrameBuffer_Width_Mask );

				SrcPixel = sVRAM [ iDstPtr ];
				DstPixel = VRAM [ iDstPtr ];
				SrcPixel |= SetPixelMask;

				//if ( ( DstPixel & PixelMask ) == 0 ) VRAM [ iDstPtr ] = ( SrcPixel | SetPixelMask );
				VRAM [ iDstPtr ] = ( ( ( DstPixel & PixelMask ) == 0 ) ? SrcPixel : DstPixel );
			}

		}

	}	// end if ( !bOverlap )

#else

	for ( CurY = yid; CurY < Height; CurY += yinc )
	{
		// start Src/Dst pointers for line
		//SrcLinePtr = & ( VRAM [ ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10 ] );
		//DstLinePtr = & ( VRAM [ ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10 ] );
		iSrcLinePtr = ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		iDstLinePtr = ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		
		for ( CurX = xid; CurX < Width; CurX += xinc )
		{
			iSrcPtr = iSrcLinePtr + ( ( SrcStartX + CurX ) & c_lFrameBuffer_Width_Mask );
			iDstPtr = iDstLinePtr + ( ( DstStartX + CurX ) & c_lFrameBuffer_Width_Mask );

			//SrcPixel = VRAM [ iSrcPtr ];
			//DstPixel = VRAM [ iDstPtr ];

			//if ( ( DstPixel & PixelMask ) == 0 ) sVRAM [ iDstPtr ] = ( SrcPixel | SetPixelMask );
			sVRAM [ iDstPtr ] = VRAM [ iSrcPtr ];
		}

	}

	barrier ();

	for ( CurY = yid; CurY < Height; CurY += yinc )
	{
		// start Src/Dst pointers for line
		//iSrcLinePtr = ( ( SrcStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		iDstLinePtr = ( ( DstStartY + CurY ) & c_lFrameBuffer_Height_Mask ) << 10;
		
		for ( CurX = xid; CurX < Width; CurX += xinc )
		{
			//iSrcPtr = iSrcLinePtr + ( ( SrcStartX + CurX ) & c_lFrameBuffer_Width_Mask );
			iDstPtr = iDstLinePtr + ( ( DstStartX + CurX ) & c_lFrameBuffer_Width_Mask );

			SrcPixel = sVRAM [ iDstPtr ];
			DstPixel = VRAM [ iDstPtr ];
			SrcPixel |= SetPixelMask;

			//if ( ( DstPixel & PixelMask ) == 0 ) VRAM [ iDstPtr ] = ( SrcPixel | SetPixelMask );

			VRAM [ iDstPtr ] = ( ( ( DstPixel & PixelMask ) == 0 ) ? SrcPixel : DstPixel );
		}

	}

#endif

	//}	// end if local_id

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( Comm == 0x80 ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef SYNC_AFTER_MOVE

	// this need to be complete first before proceeding
	barrier ();

#endif

#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}







void TransferPixelPacketIn ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	//int xid = int( gl_GlobalInvocationID.x );
	//int yid = int( gl_GlobalInvocationID.y );
	

	int yid;

	uint bgr2;
	uint pix0, pix1;
	uint DestPixel;
	uint Data;

	
	//int iX, iY;
	int CurX, CurY;

	int iPtr;
	int iCount;
	
	int xxpixel;
	int xximagepixel;


	uint GPU_CTRL_Read;
	int dX;
	int dY;
	int w;
	int h;
	int sX;
	int sY;
	
	int BS;

	uint uStartIndex;

	int xximagepixelstart;
	uint PixelMask;
	uint SetPixelMask;
	uint Comm;



	uIndex <<= 4;

	
	//if ( xxid == 0 )
	//{

		//Count = 0;

		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		dX = int( inputdata [ uIndex + 1 ] );
		dY = int( inputdata [ uIndex + 2 ] );
		w = int( inputdata [ uIndex + 3 ] );
		h = int( inputdata [ uIndex + 4 ] );
		//iX = int( inputdata [ uIndex + 5 ] );
		//iY = int( inputdata [ uIndex + 6 ] );
		sX = int( inputdata [ uIndex + 5 ] );
		sY = int( inputdata [ uIndex + 6 ] );
		
		BS = int( inputdata [ uIndex + 7 ] & 0xf );

		// count is per 2 pixels
		BS <<= 1;
		
		xximagepixelstart = sX + sY * w;

		// nocash psx specifications: transfer/move vram-to-vram use masking
		// ME is bit 12
		//if ( GPU_CTRL_Read.ME ) PixelMask = 0x8000;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		//if ( GPU_CTRL_Read.MD ) SetPixelMask = 0x8000;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;


		uStartIndex = inputdata [ uIndex + 9 ];

		BS = int( inputdata [ uIndex + 10 ] );

		// count is per 2 pixels
		BS <<= 1;



#ifdef SYNC_BEFORE_TRANSFER

	barrier ();

#endif


#ifdef USE_NEW_SCANLINE_DRAW_TRANSFER

	yid = ( xxid - dY ) & xxmask;

	for ( CurY = yid; CurY < h && CurY >= sY; CurY += xxinc )
	{
		for ( CurX = ( ( CurY == sY ) ? sX : 0 ); CurX < w; CurX++ )
		{
			iCount = CurX + ( CurY * w );
			iCount -= xximagepixelstart;

			pix0 = PixelInput32 [ uStartIndex + ( iCount >> 1 ) ];

			pix0 = ( pix0 >> ( ( iCount & 1 ) << 4 ) ) & 0xffff;
			pix0 |= SetPixelMask;

			// need the pixel count in the image ( sX + sY * w )
			//xximagepixel = iCount + xximagepixelstart;

			//CurX = xximagepixel % w;
			//CurY = xximagepixel / w;

			iPtr = ( (dX + CurX) & 0x3ff ) + ( ( (dY + CurY) & 0x1ff ) << 10 );

			// read pixel from frame buffer if we need to check mask bit
			DestPixel = VRAM [ iPtr ];

			//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( pix0 | SetPixelMask );

			VRAM [ iPtr ] = ( ( ( DestPixel & PixelMask ) == 0 ) ? pix0 : DestPixel );
		}
	}


#else

	for ( iCount = xxid; iCount < BS; iCount += xxinc )
	{

		//pix0 = inputdata [ uIndex + ( iCount & ~0xf ) + 8 + ( ( iCount & 0xf ) >> 1 ) ];
		pix0 = PixelInput32 [ uStartIndex + ( iCount >> 1 ) ];

		pix0 = ( pix0 >> ( ( iCount & 1 ) << 4 ) ) & 0xffff;
		pix0 |= SetPixelMask;

		// need the pixel count in the image ( sX + sY * w )
		xximagepixel = iCount + xximagepixelstart;

		CurX = xximagepixel % w;
		CurY = xximagepixel / w;

		iPtr = ( (dX + CurX) & 0x3ff ) + ( ( (dY + CurY) & 0x1ff ) << 10 );

		// read pixel from frame buffer if we need to check mask bit
		DestPixel = VRAM [ iPtr ];

		//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( pix0 | SetPixelMask );

		VRAM [ iPtr ] = ( ( ( DestPixel & PixelMask ) == 0 ) ? pix0 : DestPixel );
	}

#endif


#ifdef SYNC_AFTER_TRANSFER

	// this needs to be complete before proceeding
	barrier ();

#endif

	
	return;
}



uint TestFunction ( uint uIdx )
{
	barrier ();

	return uIdx;
}


void main ()
{
	uint uIdx;
	uint uIdx2;
	uint uCommand;
	uint uIndex;
	//uint uTargetIndex;
	//uint iInputMask;

	int iSync;

	const uint uOffset = ( 1 << 16 ) * 64;

	// sometimes want to arrange things in the x direction only
	uint xxid = gl_LocalInvocationIndex;


	uint xid = gl_GlobalInvocationID.x;
	uint yid = gl_GlobalInvocationID.y;


	group_x = int( gl_WorkGroupID.x );
	group_y = int( gl_WorkGroupID.y );
	group_xcount = int( gl_NumWorkGroups.x );
	group_ycount = int( gl_NumWorkGroups.y );


	group_xshift = findLSB( group_xcount );
	group_yshift = findLSB( group_ycount );

	// get the increments
	//if ( xid + yid == 0 )
	//{

		xxinc = int( gl_WorkGroupSize.x ) * int( gl_WorkGroupSize.y );
	//}

	xxmask = xxinc - 1;

	xinc = int( gl_WorkGroupSize.x );
	yinc = int( gl_WorkGroupSize.y );

	group_xinc = ( xinc << group_xshift );
	group_yinc = ( yinc << group_yshift );

#ifdef USE_NEW_SCANLINE_DRAW_VARS

	group_vxinc = 4;
	group_vyinc = xxinc;
#else


	// for vector operations -> vector will be going in x-direction
	// 4 components per vector
	group_vxinc = group_xinc << 2;
	group_vyinc = group_yinc;
#endif

	group_xmask = group_xinc - 1;
	group_ymask = group_yinc - 1;

	group_vxmask = group_vxinc - 1;

	//barrier ();


	// copy over dither array
	//c_iDitherValues16 [ xxid & 0xf ] = c_iDitherValues16_2 [ xxid & 0xf ];


	precompute_data ();


	// for now, set next index to zero
	//uIndex = 0;



	//while ( uIndex < ( 1 << 16 ) )
#ifdef USE_SHORTER_OBJECT_LIST
	for ( uIdx = 0; uIdx < ( 1 << 16 ); uIdx++ )
#else
	for ( uIndex = 0; uIndex < ( 1 << 16 ); uIndex++ )
#endif
	{
#ifdef USE_SHORTER_OBJECT_LIST
		// get next index and command from shorter list
		uIndex = data [ uOffset + ( xxid << 12 ) + uIdx ];
		uCommand = inputdata [ ( uIndex << 4 ) + 7 ] >> 24;
#else
		// get the next command
		uCommand = inputdata [ ( uIndex << 4 ) + 7 ] >> 24;
#endif

		if ( uCommand == 0x02 )
		{
			//Draw_FrameBufferRectangle_02 ( uIndex );
			vDraw_FrameBufferRectangle_02 ( uIndex );
		}
		else if ( uCommand < 0x40 )
		{
			// triangle //
			
			vDrawTriangle_TextureGradient ( uIndex );
			//uIndex = vDrawTriangle_TextureGradient ( uIndex );

			/*
			//if ( ( uCommand & 0x10 ) == 0 )
			if ( ( uCommand & 0x04 ) == 0 )
			{
				//vDrawTriangle_Gradient ( uIndex );
				vDrawTriangle_TextureGradient ( uIndex );

				// mono //
				if ( ( uCommand & 0x04 ) == 0 )
				{
					// color //

					//vDrawTriangle_Mono ( uIndex );
					vDrawTriangle_Gradient ( uIndex );
					//vDrawTriangle_TextureGradient ( uIndex );
				}
				else
				{
					// texture //

					//vDrawTriangle_Texture ( uIndex );
					vDrawTriangle_TextureGradient ( uIndex );
				}
			}
			else
			{
				vDrawTriangle_TextureGradient ( uIndex );

				// gradient //
				if ( ( uCommand & 0x04 ) == 0 )
				{
					// color //

					vDrawTriangle_Gradient ( uIndex );
					//vDrawTriangle_TextureGradient ( uIndex );
				}
				else
				{
					// texture //

					vDrawTriangle_TextureGradient ( uIndex );
				}
			}
			*/
		}
		else if ( uCommand < 0x60 )
		{
			// line //
			if ( ( uCommand & 0x10 ) == 0 )
			{
				// mono //

				//Draw_Line ( uIndex );
				vDraw_Line ( uIndex );
			}
			else
			{
				// gradient //

				//Draw_Line_Gradient ( uIndex );
				vDraw_Line_Gradient ( uIndex );
			}
		}
		else if ( uCommand < 0x80 )
		{
			vDrawTriangle_TextureGradient ( uIndex );
			//uIndex = vDrawTriangle_TextureGradient ( uIndex );

			// rectangle/sprite //
			/*
			if ( ( uCommand & 0x04 ) == 0 )
			{
				// rectangle //
				
				//vDraw_Rectangle_60 ( uIndex );
				vDrawTriangle_Gradient ( uIndex );
			}
			else
			{
				// sprite //

				//vDraw_Sprite_64 ( uIndex );
				vDrawTriangle_TextureGradient ( uIndex );
			}
			*/
		}
		else if ( uCommand < 0xa0 )
		{
			// move //

			Transfer_MoveImage_80 ( uIndex );
		}
		else if ( uCommand < 0xf0 )
		{
			// import //
			TransferPixelPacketIn ( uIndex );

		}
		else
		{
			// done //
			break;

		}
		



		//uIndex++;
	}


	if ( uCommand == 0xfe )
	{
		// command 0xfe
		draw_screen ( uIndex );
	}


	barrier ();	

	// invalidate all the entries
	for ( uIdx2 = xxid; uIdx2 < uIndex; uIdx2 += xxinc )
	{
		inputdata [ ( uIdx2 << 4 ) + 7 ] = -1;
	}

	return;

}

