#version 450


//***TODO***
// 1. could combine x and uv coords when doing precalc for triangles
// 2. EndY is inclusive on the 2d drawing, so precalc check against bottom of window probably shouldn't do the +1 at all, should just do a min with the border value
// 3. vDraw_Line_X functions never gets the endpoint of line
// 4. draw line functions should also update endpoint to draw area

#extension GL_KHR_shader_subgroup_basic: enable
#extension GL_KHR_shader_subgroup_vote: enable
#extension GL_KHR_shader_subgroup_ballot: enable
//#extension GL_KHR_shader_subgroup_arithmetic: enable
//#extension GL_KHR_shader_subgroup_shuffle: enable
//#extension GL_KHR_shader_subgroup_shuffle_relative: enable
//#extension GL_KHR_shader_subgroup_clustered: enable

// adds: int8_t  i8vec2  i8vec3  i8vec4  uint8_t  u8vec2  u8vec3  u8vec4
#extension GL_EXT_shader_8bit_storage: enable

// adds: float16_t  f16vec2  f16vec3  f16vec4  int16_t  i16vec2  i16vec3  i16vec4  uint16_t  u16vec2  u16vec3  u16vec4
#extension GL_EXT_shader_16bit_storage: enable

// adds: int64_t  i64vec2  i64vec3  i64vec4  uint64_t  u64vec2  u64vec3  u64vec4
#extension GL_ARB_gpu_shader_int64: enable

// adds: pack8, unpack8, pack16, unpack16, pack32, unpack32, etc
#extension GL_EXT_shader_explicit_arithmetic_types : enable


// enable report of device details
#define ENABLE_WRITE_BACK_DEVICE_DATA


// draw by range instead of by scanline, but copies/transfers are still by scanline
#define ENABLE_RANGE_DRAW
//#define ENABLE_RANGE_DRAW_SKIPS


// use mix or not to use mix ?? that is the question ??
#define ENABLE_USE_MIX


//#define ENABLE_PRIMITIVE_LOOP
//#define USE_MORE_JUMPS
//#define USE_VECTOR_LOADSTORE


// possible precalc optimizations
//#define ENABLE_PRECALC_JUMPS_DRAW
//#define ENABLE_PRECALC_JUMPS_SPRITE
//#define ENABLE_PRECALC_JUMPS_TRIANGLE
//#define ENABLE_PRECALC_JUMPS_LINE


// uses maximum number of workgroups if enabled, otherwise forced to only one workgroup
//#define ENABLE_MULTIPLE_WORKGROUPS
#define USE_MEMORY_BARRIER_BUFFER
//#define ENABLE_LOCAL_SYNC_ALL
//#define ENABLE_GLOBAL_SYNC_ALL

// use 16-bit pixels instead of 32-bit pixels in VRAM
#define USE_LOAD_STORE_VRAM16


// use local memory to cache clut data
//#define USE_LOCAL_CLUT

// use local memory for dither data
//#define USE_LOCAL_DITHER
#define USE_PRIVATE_DITHER


// if subgroup does not draw the object at all, then skip it for subgroup
//#define ENABLE_TRANSFER_SUBGROUP_SKIP
//#define ENABLE_MOVE_SUBGROUP_SKIP
//#define ENABLE_LINE_SUBGROUP_SKIP
#define ENABLE_RECTANGLE_SUBGROUP_SKIP
#define ENABLE_SPRITE_SUBGROUP_SKIP
#define ENABLE_TRIANGLE_SUBGROUP_SKIP

// will allow skipping sync point if it thinks there is no overlap with move
//#define ENABLE_MOVE_OVERLAP_SKIP


// call draw functions or inline
#define CALL_DRAW_RECTANGLE
#define CALL_DRAW_SPRITE


// allow drawing of primitive
#define ENABLE_PRECOMPUTE_DATA
#define ENABLE_DRAW_RECTANGLE
#define ENABLE_DRAW_SPRITE
#define ENABLE_DRAW_TRIANGLE_MONO_COLOR
#define ENABLE_DRAW_TRIANGLE_MONO_TEXTURE
#define ENABLE_DRAW_TRIANGLE_GRADIENT_COLOR
#define ENABLE_DRAW_TRIANGLE_GRADIENT_TEXTURE
#define ENABLE_DRAW_LINE
#define ENABLE_DRAW_SCREEN
#define ENABLE_DRAW_IMAGE


// enable pre-calc for object type
#define USE_PRECALC_LINE


// read/write alignment
//#define ALIGN_READ_WRITE_RECTANGLE
//#define ALIGN_READ_WRITE_SPRITE


// for troubleshooting
#define ENABLE_BUFFER_READ
#define ENABLE_BUFFER_WRITE


// draw screen to buffer instead of image
#define DRAW_SCREEN_TO_BUFFER


// draw with each shader unit on its own scanline
#define USE_NEW_SCANLINE_DRAW_TRANSFER
#define USE_NEW_SCANLINE_DRAW_MOVE
#define USE_NEW_SCANLINE_DRAW_CLEAR
//#define USE_NEW_SCANLINE_DRAW_VARS
#define USE_NEW_SCANLINE_DRAW_RECTANGLE
#define USE_NEW_SCANLINE_DRAW_SPRITE
//#define USE_NEW_SCANLINE_DRAW_TRIANGLE
#define USE_NEW_SCANLINE_DRAW_LINE


#define USE_NEW_SYNC_BEFORE_RUN
#define USE_NEW_SYNC_BEFORE_SETUP
#define USE_NEW_SYNC_AFTER_WINDOWCHANGE
#define USE_NEW_SYNC_BEFORE_DRAW
#define USE_NEW_SYNC_AFTER_DRAW
//#define USE_NEW_SYNC_BEFORE_TRANSFER
//#define USE_NEW_SYNC_BEFORE_MOVE
//#define USE_NEW_SYNC_AFTER_MOVE

//#define USE_SHORTER_OBJECT_LIST

//#define ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT


#define USE_NEW_MOVE4
#define USE_NEW_TRANSFER4


// testing quicker loading of data
//#define QUICK_LOAD_SPRITE


// use alternate selective write
//#define USE_SELECTIVE_WRITE



// might not need these if just using a single workgroup
//#define SYNC_BEFORE_TRANSFER
//#define SYNC_AFTER_TRANSFER
//#define SYNC_BEFORE_MOVE
//#define SYNC_AFTER_MOVE


// size of screen
#define SCREEN_X_SIZE 640
#define SCREEN_Y_SIZE 480


// shader arrangement for drawing triangles for now
#define SHADER_Y_SHIFT	5
#define SHADER_X_MASK	( ( 1 << SHADER_Y_SHIFT ) - 1 )

#define PIXEL_INPUT_COUNT32		( 1 << 20 )
#define PIXEL_INPUT_MASK32		( PIXEL_INPUT_COUNT32 - 1 )


//layout (local_size_x = 16, local_size_y = 16) in;
//layout (local_size_x = 4, local_size_y = 16) in;
//layout (local_size_x = 8, local_size_y = 32) in;
layout (local_size_x = 256) in;



// set the sizes for the global memory areas here
#define GLOBAL_MEM_SCRATCH_SIZE_BYTES			(16384)
#define GLOBAL_MEM_VRAM_SIZE_BYTES				(1024*512*2)
#define GLOBAL_MEM_SVRAM_SIZE_BYTES				(1024*512*2)
#define GLOBAL_MEM_INPUT_COMM_SIZE_BYTES		(16 * ( 1 << 16 ) * 4)
#define GLOBAL_MEM_INPUT_PIX_SIZE_BYTES			(( 1 << 20 ) * 4)
#define GLOBAL_MEM_PIXELBUF_SIZE_BYTES			(1024*512*4)
#define GLOBAL_MEM_WORK_AREA_SIZE_BYTES			(64 * ( 1 << 16 ) * 4)
#define GLOBAL_MEM_STAGING_SIZE_BYTES			(SCREEN_X_SIZE * SCREEN_Y_SIZE * 4)


layout (std430, binding = 0) restrict buffer TheSpace {

// 16384 but in bytes
uint uScatchSpace [];

};


// *** edge of host accessible buffer ?? *** //
// *TODO* this needs to be a separate block accessible from CPU side
layout (std430, binding = 0) restrict buffer TheCounter {

// the start index of data in input command buffer
uint guStartIndex;

// the end index of data in input command buffer
uint guEndIndex;

// workgroup synchronization counter (important note: MUST initialize to ZERO from CPU side!)
uint auCounter;

// 0- do nothing, 1- update frame buffer from input, 2- update frame buffer from output, 3- update frame buffer both at input and output
// probably not needed since this would be part of the command buffer
uint guUpdateFrameBuffer;

// offset#4
uint guSubgroupSize;
// offset#5
uint guNumSubgroups;
// offset#6
uint guWorkgroupSize;
// offset#7
uint guNumWorkgroups;

};






// *** ps1 gpu ram *** //


layout (std430, binding = 1) buffer FrameBuf {

// the shader representation of vram
uint VRAM [];

};

layout (std430, binding = 1) buffer FrameBuf4 {

// the shader representation of vram
uvec4 VRAM4 [];

};

layout (std430, binding = 1) buffer FrameBuf64 {

// the shader representation of vram
uint64_t VRAM64 [];

};

layout (std430, binding = 1) buffer FrameBuf16 {

// the shader representation of vram
uint16_t VRAM16 [];

};

layout (std430, binding = 1) buffer FrameBuf8 {

// the shader representation of vram
uint8_t VRAM8 [];

};

layout (std430, binding = 1) buffer FrameBuf64_4 {

// the shader representation of vram
u64vec4 VRAM64_4 [];

};

layout (std430, binding = 1) buffer FrameBuf16_4 {

// the shader representation of vram
u16vec4 VRAM16_4 [];

};

layout (std430, binding = 1) buffer FrameBuf8_4 {

// the shader representation of vram
u8vec4 VRAM8_4 [];

};



// ** additional shadow frame buffer/screen buffer output *** //

layout (std430, binding = 2) buffer ShadowFrameBuf16 {

// the shader representation of vram
uint16_t sVRAM16 [];

};

layout (std430, binding = 2) buffer ShadowFrameBuf {

// the shader representation of vram
uint sVRAM [];

};





// *** input draw commands *** //

layout (std430, binding = 3) readonly buffer Cmd {
	// the input commands to draw
	uint inputdata [];
};

layout (std430, binding = 3) readonly buffer Cmd32_4 {
	// the input commands to draw
	uvec4 inputdata32_4 [];
};

// *** input gfx data *** //

layout (std430, binding = 4) readonly restrict buffer InputPixels {
// the display window
uint PixelInput32 [];
};


// screen buffer //

layout (std430, binding = 5) buffer ScreenBuf {
// the display window
uint pixelbuffer32 [];
};

// *** INTERNAL VARS *** //

// *** compute shader work memory *** //

layout (std430, binding = 6) buffer sCmd {
	// the shader work area
	int data [];
};

layout (std430, binding = 6) buffer sCmd8_4 {
	// the shader work area
	i8vec4 data8_4 [];
};

layout (std430, binding = 6) buffer sCmd32_4 {
	// the shader work area
	ivec4 data32_4 [];
};




// *** final screen image *** //


layout (std430, binding = 7) restrict writeonly buffer sstaging_buffer {
	// the shader work area
	uvec4 staging_buffer32_4 [];
};







// global constants //

const int c_iDitherValues16 [] = { -4 << 16, 0 << 16, -3 << 16, 1 << 16,
								2 << 16, -2 << 16, 3 << 16, -1 << 16,
								-3 << 16, 1 << 16, -4 << 16, 0 << 16,
								3 << 16, -1 << 16, 2 << 16, -2 << 16 };


									

//shared int c_iDitherValues16 [ 16 ];



#ifdef USE_LOCAL_DITHER

shared int iDitherValues16 [ 16 ];

#endif





//const int c_MaxPolygonWidth = 1023;
//const int c_MaxPolygonHeight = 511;

//const int c_lFrameBuffer_Width = 1024;
//const int c_lFrameBuffer_Height = 512;
//const int c_lFrameBuffer_Width_Mask = 1023;
//const int c_lFrameBuffer_Height_Mask = 511;


#define c_MaxPolygonWidth	1023
#define c_MaxPolygonHeight	511

#define c_lFrameBuffer_Width	1024
#define c_lFrameBuffer_Height	512
#define c_lFrameBuffer_Width_Mask	1023
#define c_lFrameBuffer_Height_Mask	511


// shared global variables //

shared int xinc;
shared int yinc;

// local count of shader invocations
shared int xxinc;

// global count of shader invocations
shared int gxxinc;

// workgroup synchronization
shared uint NextBarrierSync;


shared int xxmask;

shared int group_x, group_y;
shared int group_xcount, group_ycount;
shared int group_xinc, group_yinc;
shared int group_xshift, group_yshift;
shared int group_xmask, group_ymask;

shared int group_vxinc;
shared int group_vxmask;

shared int group_vyinc;

shared int group_yoffset;


// shared subgroup vars //
shared uint subgroup_local_count;
shared uint subgroup_global_count;
shared uint subgroup_count;
shared uint subgroup_shift;
shared uint subgroup_mask;
shared uint subgroup_size;

// shared workgroup vars //
shared uint workgroup_count;

#define MAX_LOCAL_SUBGROUPS		(8)


#ifdef USE_LOCAL_CLUT

shared uint ulocal_data32 [ 2048 ];

#endif



// draw ranges for local subgroups
// draw start line (inclusive), draw end line (not inclusive)
shared ivec2 ivDrawRange [ MAX_LOCAL_SUBGROUPS ];


// ABE(2)/ABR(4)
const ivec4 c_ivLUT_iBFShiftSign [ 2 ] [ 4 ] = { { ivec4( 31, 0, 0, 0 ), ivec4( 31, 0, 0, 0 ), ivec4( 31, 0, 0, 0 ), ivec4( 31, 0, 0, 0 ) },
												{ ivec4( 1, 1, 0, 0 ), ivec4( 0, 0, 0, 0 ), ivec4( 0, 0, -1, -1 ), ivec4( 0, 2, 0, 0 ) }
												};



#define intdivf(op1, op2, fp1, fp2, fpout) (int(( ( float( (op1) ) / float( 1 << (fp1) ) ) / ( float( (op2) ) / float( 1 << (fp2) ) ) ) * float(1 << (fpout))))
#define intdivd(op1, op2, fp1, fp2, fpout) (int(( ( double( (op1) ) / double( 1 << (fp1) ) ) / ( double( (op2) ) / double( 1 << (fp2) ) ) ) * double(1 << (fpout))))

#define intdivfv2(op1, op2, fp1, fp2, fpout) (ivec2( ( vec2( (op1) ) / vec2( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivfv3(op1, op2, fp1, fp2, fpout) (ivec3( ( vec3( (op1) ) / float( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivfv4(op1, op2, fp1, fp2, fpout) (ivec4( ( vec4( (op1) ) / float( (op2) ) ) * float( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))

#define intdivdv2(op1, op2, fp1, fp2, fpout) (ivec2( ( dvec2( (op1) ) / double( (op2) ) ) * double( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivdv3(op1, op2, fp1, fp2, fpout) (ivec3( ( dvec3( (op1) ) / double( (op2) ) ) * double( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))
#define intdivdv4(op1, op2, fp1, fp2, fpout) (ivec4( ( dvec4( (op1) ) / double( (op2) ) ) * double( 1 << ( (fpout)-((fp1)-(fp2)) ) ) ))


// 64-bit integer divides (on a gpu probably not really 64-bit, maybe 52-bit ??)
#define uint64div(op1, op2, fp1, fp2, fpout) uint( ( uint64_t(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / uint64_t(op2) )
#define int64div(op1, op2, fp1, fp2, fpout) int( ( int64_t(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / int64_t(op2) )

#define uint64sdiv(op1, op2, fp1, fp2, fpout) uint( int64_t( uint64_t(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / int64_t(op2) )

#define uint64div2(op1, op2, fp1, fp2, fpout) uvec2( ( u64vec2(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / u64vec2(op2) )
#define int64div2(op1, op2, fp1, fp2, fpout) ivec2( ( i64vec2(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / i64vec2(op2) )
#define uint64div3(op1, op2, fp1, fp2, fpout) uvec3( ( u64vec3(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / u64vec3(op2) )
#define int64div3(op1, op2, fp1, fp2, fpout) ivec3( ( i64vec3(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / i64vec3(op2) )
#define uint64div4(op1, op2, fp1, fp2, fpout) uvec4( ( u64vec4(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / u64vec4(op2) )
#define int64div4(op1, op2, fp1, fp2, fpout) ivec4( ( i64vec4(op1) << ( (fpout)-((fp1)-(fp2)) ) ) / i64vec4(op2) )




void precompute_data ()
{
	//const int iDataCount = ( 1 << 16 );
	//const int iDataElementSize = 128;
	//const int iDataShift = 7;

	int xxid = int( gl_LocalInvocationIndex );

	// global invocation index
	int gxxid = int( gl_LocalInvocationIndex + ( gl_WorkGroupID.x * xxinc ) );

	uint uIdx;
	uint uIndex;

	uint Comm;
	uint CommPrev, CommNext;

	uint bgr32;
	uint bgr16;
	//int x0, x1, x2;
	//int y0, y1, y2;
	int w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	//int u0;
	//int v0;
	
	// bits 0-5 in upper halfword
	int clut_x;
	int clut_y;

	int TWY;
	int TWX;
	int TWH;
	int TWW;
		
	int tpage_tx;
	int tpage_ty;
	int tpage_tp;
	int Shift1;
	int Shift2;
	int And1;
	int And2;
	int TWYTWH;
	int TWXTWW;
	int Not_TWH;
	int Not_TWW;
	int TextureOffset;
	int ClutOffset;
	int clut_xoffset;

	uint Command_TGE;

	int Temp;
	uint GPU_CTRL_Read_DTD;

	int tpage_abr;

	int x0, x1, x2, y0, y1, y2;

	int dx_left, dx_right;
	int t0, t1, denominator;

	ivec4 x, dx, gt;

	int Coord0, Coord1, Coord2;

	ivec4 Coord;

	//int gx [ 3 ], gy [ 3 ];
	//uint gbgr [ 3 ];
	ivec4 gx, gy;
	uvec4 gbgr;

	int x_left, x_right;
	int LeftMostX, RightMostX;

	int dR_left, dG_left, dB_left;
	int dR_across, dG_across, dB_across;
	int R_left, G_left, B_left;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;

	ivec4 C_left, dC_left;
	ivec4 grgb0, grgb1, grgb2;
	ivec4 gr, gg, gb;
	ivec4 dC_across;

	int u0, v0, u1, v1, u2, v2;
	int dU_left, dV_left;
	int dU_across, dV_across;
	int U_left, V_left;
	//int gu [ 3 ], gv [ 3 ];
	ivec4 gu, gv;

	ivec4 T_left, dT_left;
	ivec4 guv0, guv1, guv2;
	ivec4 dT_across;

	uvec4 uvData0, uvData1;

	int bDraw;

	// need to know if object is textured or not
	int bTexture;

	int iEndpointX, iEndpointY;
	int x_distance, y_distance;
	int TopMostY, BottomMostY;
	int iR, iG, iB;
	int iBShift, iFShift, iFSign;
	int line_length;
	int ix, iy;
	int dy;
	int dr, dg, db;

	ivec4 c0, c1, iC, dc;

	uint uStartIdx, uEndIdx;
	uint uCount;
	uint uIndex4;

	uint WindowPrev0, WindowPrev1, WindowCur0, WindowCur1;
	ivec4 ivBFShiftSign;

	//uStartIdx = uScatchSpace [ 0 ];
	//uEndIdx = uScatchSpace [ 1 ];
	uStartIdx = guStartIndex;
	uEndIdx = guEndIndex;

	// loop through data
	//uIndex = xxid << 4;

	// need to make this first list 64 per element instead of 128
	//uIdx = xxid << 7;
	//uIdx = xxid << 6;


	//for ( uCount = xxid; uCount < uEndIdx; uCount += xxinc )
	for ( uCount = gxxid; uCount < uEndIdx; uCount += gxxinc )
	{
		uIndex = uCount << 4;
		uIdx = uIndex << 2;

		uIndex4 = uIndex >> 2;

		uvData0 = inputdata32_4 [ uIndex4 + 0 ];
		uvData1 = inputdata32_4 [ uIndex4 + 1 ];

		//Comm = inputdata [ uIndex + 7 ] >> 24;
		Comm = uvData1.w >> 24;

#ifdef USE_NEW_SYNC_BEFORE_SETUP

		// init to not synchrhonize
		data [ uIdx + 31 ] = 0;

		CommPrev = 0;
		if ( uIndex != 0 )
		{
			CommPrev = inputdata [ uIndex + 7 - 16 ] >> 24;

			// make sure that both are draw commands
			if ( ( Comm > 0x02 ) && ( Comm < 0x80 ) )
			{
				// current command is DRAW command //

				if ( ( CommPrev > 0x02 ) && ( CommPrev < 0x80 ) )
				{
					// previous command and current command is DRAW command //

#ifdef USE_NEW_SYNC_AFTER_WINDOWCHANGE
					// get previous window settings
					WindowPrev0 = inputdata [ uIndex + 1 - 16 ];
					WindowPrev1 = inputdata [ uIndex + 2 - 16 ];

					// get current window settings
					//WindowCur0 = inputdata [ uIndex + 1 ];
					//WindowCur1 = inputdata [ uIndex + 2 ];
					WindowCur0 = uvData0.y;
					WindowCur1 = uvData0.z;

					// if the draw window changes between draw commands, then may need to wait for the rendering to finish in the previous window
					if ( ( WindowPrev0 != WindowCur0 ) || ( WindowPrev1 != WindowCur1 ) )
					{
						// need to synchronize before the window change //
						data [ uIdx + 31 ] = 1;
					}
#endif
				}
				else
				{
					// previous command is NOT draw command, but current one is //

#ifdef USE_NEW_SYNC_BEFORE_DRAW
					// need to synchronize before draw command //
					data [ uIdx + 31 ] = 1;
#endif
				}
			}
			else
			{
				// current command is NOT draw command //

				if ( ( CommPrev > 0x02 ) && ( CommPrev < 0x80 ) )
				{
					// previous command is DRAW command, current one is NOT //

#ifdef USE_NEW_SYNC_AFTER_DRAW
					// need to synchronize after draw command before going to NON-DRAW command //
					data [ uIdx + 31 ] = 1;
#endif
				}
			}



#ifdef USE_NEW_SYNC_BEFORE_TRANSFER
			// current is transfer-in and previous was something different, then sync before
			if ( ( Comm == 0x02 ) || ( Comm >= 0xa0 && Comm < 0xf0 ) )
			{
				if ( ( CommPrev > 0x02 && CommPrev < 0xa0 ) || ( CommPrev >= 0xf0 ) )
				{
					// need to synchronize before //
					data [ uIdx + 31 ] = 1;
				}
			}
#endif

#ifdef USE_NEW_SYNC_BEFORE_MOVE
			// all moves for now should sync before
			if ( Comm >= 0x80 && Comm < 0xa0 )
			{
				// need to synchronize before //
				data [ uIdx + 31 ] = 1;
			}
#endif

		}	// end if ( uIndex != 0 )

#endif	// end USE_NEW_SYNC_BEFORE_SETUP


#ifdef ENABLE_PRECALC_JUMPS_DRAW
		// check if none of the commands are draw commands
		if ( subgroupAll( ( Comm == 0x02 ) || ( Comm >= 0x80 ) ) )
		{
			continue;
		}
#endif


		// pre compute common data //
		//GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		GPU_CTRL_Read = uvData0.x;

		GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;

		//DrawArea_TopLeftX = int( inputdata [ uIndex + 1 ] ) & 0x3ff;
		//DrawArea_TopLeftY = int( inputdata [ uIndex + 1 ] >> 10 ) & 0x3ff;
		//DrawArea_BottomRightX = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		//DrawArea_BottomRightY = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x3ff;
		DrawArea_TopLeftX = int( uvData0.y ) & 0x3ff;
		DrawArea_TopLeftY = int( uvData0.y >> 10 ) & 0x3ff;
		DrawArea_BottomRightX = int( uvData0.z ) & 0x3ff;
		DrawArea_BottomRightY = int( uvData0.z >> 10 ) & 0x3ff;

		//DrawArea_OffsetX = ( int( inputdata [ uIndex + 3 ] ) << 21 ) >> 21;
		//DrawArea_OffsetY = ( int( inputdata [ uIndex + 3 ] ) << 10 ) >> 21;
		DrawArea_OffsetX = ( int( uvData0.w ) << 21 ) >> 21;
		DrawArea_OffsetY = ( int( uvData0.w ) << 10 ) >> 21;

		//bgr32 = inputdata [ uIndex + 7 ] & 0x00ffffff;
		bgr32 = uvData1.w & 0x00ffffff;
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );

		bDraw = 1;
		
		// check for some important conditions
		if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
		{
			//return;
			bDraw = 0;
		}
		
		if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
		{
			//return;
			bDraw = 0;
		}


		//Command_ABE = ( inputdata [ uIndex + 7 ] >> 24 ) & 2;
		Command_ABE = ( uvData1.w >> 25 ) & 1;

		//Command_TGE = ( inputdata [ uIndex + 7 ] >> 24 ) & 1;
		Command_TGE = ( uvData1.w >> 24 ) & 1;

		// bits 0-5 in upper halfword
		clut_x = int ( inputdata [ uIndex + 9 ] >> ( 16 + 0 ) ) & 0x3f;
		clut_y = int ( inputdata [ uIndex + 9 ] >> ( 16 + 6 ) ) & 0x1ff;

		//////////////////////////////////////////////////////
		// Get offset into color lookup table
		ClutOffset = clut_y << 10;
		clut_xoffset = clut_x << 4;

		//TWY = int ( inputdata [ uIndex + 4 ] >> 15 ) & 0x1f;
		//TWX = int ( inputdata [ uIndex + 4 ] >> 10 ) & 0x1f;
		//TWH = int ( inputdata [ uIndex + 4 ] >> 5 ) & 0x1f;
		//TWW = int ( inputdata [ uIndex + 4 ] ) & 0x1f;
		TWY = int ( uvData1.x >> 15 ) & 0x1f;
		TWX = int ( uvData1.x >> 10 ) & 0x1f;
		TWH = int ( uvData1.x >> 5 ) & 0x1f;
		TWW = int ( uvData1.x ) & 0x1f;

		TWYTWH = ( ( TWY & TWH ) << 3 );
		TWXTWW = ( ( TWX & TWW ) << 3 );
		
		Not_TWH = ~( TWH << 3 );
		Not_TWW = ~( TWW << 3 );

		Shift1 = 0;
		Shift2 = 0;
		And1 = 0;
		And2 = 0;

		// whether object is textured or not
		bTexture = int( Comm & 0x4 );



#ifdef ENABLE_PRECALC_JUMPS_SPRITE
		if ( subgroupAny(( Comm >= 0x60 ) && ( Comm <= 0x7f )) )
#endif
		{

		if ( ( Comm >= 0x60 ) && ( Comm <= 0x7f ) )
		{

		// strictly for 2d objects //

		// bits 0-3
		tpage_tx = int( GPU_CTRL_Read ) & 0xf;
		
		// bit 4
		tpage_ty = int( GPU_CTRL_Read >> 4 ) & 1;
		
		// bits 7-8
		tpage_tp = int( GPU_CTRL_Read >> 7 ) & 3;
		

		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		
		if ( tpage_tp == 0 )
		{
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}



		x0 = int( inputdata [ uIndex + 8 ] );
		y0 = x0 >> 16;
		
		// x and y are actually 11 bits
		x0 = ( x0 << ( 5 + 16 ) ) >> ( 5 + 16 );
		y0 = ( y0 << ( 5 + 16 ) ) >> ( 5 + 16 );

		// pixel/rectangle/sprite only //

		
		
		w = int( inputdata [ uIndex + 10 ] );
		h = w >> 16;

		//w &= 0xffff;
		//h &= 0xffff;
		w &= 0x3ff;
		h &= 0x1ff;
		
		// get top left corner of sprite and bottom right corner of sprite
		x0 = x0 + DrawArea_OffsetX;
		y0 = y0 + DrawArea_OffsetY;

		// when using combined renderer, don't subtract one for 2d
		//x1 = x0 + w - 1;
		//y1 = y0 + h - 1;
		x1 = x0 + w;
		y1 = y0 + h;


		StartX = x0;
		EndX = x1;
		StartY = y0;
		EndY = y1;

		
		// check if sprite is within draw area
		if ( x1 < DrawArea_TopLeftX || x0 > DrawArea_BottomRightX || y1 < DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;


		u0 = int ( inputdata [ uIndex + 9 ] );
		v0 = u0 >> 8;

		// get rid of any junk data
		u0 &= 0xff;
		v0 &= 0xff;

		//if ( StartY < DrawArea_TopLeftY )
		//{
		//	v0 += ( DrawArea_TopLeftY - StartY );
		//	StartY = DrawArea_TopLeftY;
		//}
		v0 += ( DrawArea_TopLeftY - min( StartY, DrawArea_TopLeftY ) );
		StartY = max( StartY, DrawArea_TopLeftY );

		
		//if ( EndY > DrawArea_BottomRightY )
		//{
		//	// when using combined renderer, need to add 1
		//	//EndY = DrawArea_BottomRightY;
		//	EndY = DrawArea_BottomRightY + 1;
		//}
		EndY = min( EndY, DrawArea_BottomRightY + 1 );

		
		//if ( StartX < DrawArea_TopLeftX )
		//{
		//	u0 += ( DrawArea_TopLeftX - StartX );
		//	StartX = DrawArea_TopLeftX;
		//}
		u0 += ( DrawArea_TopLeftX - min( StartX, DrawArea_TopLeftX ) );
		StartX = max( StartX, DrawArea_TopLeftX );

		
		//if ( EndX > DrawArea_BottomRightX )
		//{
		//	//EndX = DrawArea_BottomRightX;
		//	EndX = DrawArea_BottomRightX + 1;
		//}
		EndX = min( EndX, DrawArea_BottomRightX + 1 );


		if ( ( bgr32 & 0x00ffffff ) == 0x00808080 ) Command_TGE = 1;

		
		// if textured and tge==1, then bgr32 = 0x00808080
		if ( ( ( Comm & 0x4 ) != 0 ) && ( Command_TGE == 1 ) )
		{
			bgr32 = 0x00808080;
		}

		/*
		iBShift = 31;
		iFShift = 0;
		iFSign = 0;
		if( Command_ABE != 0 )
		{
			switch( GPU_CTRL_Read_ABR )
			{
				//0.5B + 0.5F
				case 0:
					iBShift = 1;
					iFShift = 1;
					break;
				//1.0B + 1.0F
				case 1:
					iBShift = 0;
					iFShift = 0;
					break;
				//1.0B - 1.0F
				case 2:
					iBShift = 0;
					iFShift = 0;
					iFSign = -1;
					break;
				//1.0B + 0.25F
				case 3:
					iBShift = 0;
					iFShift = 2;
					break;
			}
		}
		*/

		ivBFShiftSign = c_ivLUT_iBFShiftSign [ Command_ABE ] [ GPU_CTRL_Read_ABR ];


		// bDraw
		// GPU_CTRL_Read_ABR,Command_ABE,Command_TGE,PixelMask,SetPixelMask
		// bgr32,bgr16
		// StartX,EndX,StartY,EndY
		// Shift1,Shift2,And1,And2
		// u0,v0
		// TWYTWH,TWXTWW,Not_TWH,Not_TWW
		// TextureOffset,ClutOffset,clut_xoffset
		data [ uIdx + 0 ] = bDraw;
		data [ uIdx + 1 ] = int( PixelMask );
		data [ uIdx + 2 ] = int( SetPixelMask );
		data [ uIdx + 3 ] = int( GPU_CTRL_Read_ABR );

		data [ uIdx + 4 ] = int( Command_ABE );
		data [ uIdx + 5 ] = int( Command_TGE );
		data [ uIdx + 6 ] = int( bgr32 );
		data [ uIdx + 7 ] = int( bgr16 );

		// not needed for rectangle or sprite
		//data [ uIdx + 8 ] = int( GPU_CTRL_Read_DTD );

		data [ uIdx + 8 ] = StartX;
		data [ uIdx + 9 ] = StartY;
		data [ uIdx + 10 ] = EndX;
		data [ uIdx + 11 ] = EndY;

		data [ uIdx + 12 ] = Shift1;
		data [ uIdx + 13 ] = Shift2;
		data [ uIdx + 14 ] = And1;
		data [ uIdx + 15 ] = And2;

		data [ uIdx + 16 ] = TWYTWH;
		data [ uIdx + 17 ] = TWXTWW;
		data [ uIdx + 18 ] = Not_TWH;
		data [ uIdx + 19 ] = Not_TWW;

		data [ uIdx + 20 ] = TextureOffset;
		data [ uIdx + 21 ] = ClutOffset;
		data [ uIdx + 22 ] = clut_xoffset;

		// for 2d use gpu ctrl abr instead of tpage abr
		data [ uIdx + 23 ] = int( GPU_CTRL_Read_ABR );	//tpage_abr;


		//data [ uIdx + 24 ] = iBShift;	//dR_across;
		//data [ uIdx + 25 ] = iFShift;	//dG_across;
		//data [ uIdx + 26 ] = iFSign;	//dB_across;
		data32_4 [ uIndex + 6 ] = ivBFShiftSign;

		data [ uIdx + 28 ] = u0;	//dU_across;
		data [ uIdx + 29 ] = v0;	//dV_across;

		// also put StartY at 39 and EndY at 59
		data [ uIdx + 39 ] = StartY;
		data [ uIdx + 59 ] = EndY;



		}	// end if ( ( Comm >= 0x60 ) && ( Comm <= 0x7f ) )

		}	// end if ( subgroupAny(( Comm >= 0x60 ) && ( Comm <= 0x7f )) )


#ifdef ENABLE_PRECALC_JUMPS_TRIANGLE
		if ( subgroupAny(( Comm >= 0x20 ) && ( Comm <= 0x3f )) )
#endif
		{

		if ( ( Comm >= 0x20 ) && ( Comm <= 0x3f ) )
		{

		// strictly for 3d objects //
	// -----------------------------------------------

		gx.x = int( inputdata [ uIndex + 8 ] );
		gx.y = int( inputdata [ uIndex + 11 ] );
		gx.z = int( inputdata [ uIndex + 14 ] );
		gy = ( gx << 5 ) >> 21;
		//gx = ( gx << 21 ) >> 21;

		//Coord0 = 0;
		//Coord1 = 1;
		//Coord2 = 2;
		Coord.xyz = ivec3( 0, 1, 2 );

		///////////////////////////////////
		// put top coordinates in x0,y0
		Coord.xyz = ( gy [ Coord.y ] < gy [ Coord.x ] ) ? Coord.yxz : Coord.xyz;
		Coord.xyz = ( gy [ Coord.z ] < gy [ Coord.x ] ) ? Coord.zyx : Coord.xyz;
		Coord.xyz = ( gy [ Coord.z ] < gy [ Coord.y ] ) ? Coord.xzy : Coord.xyz;
		Coord.xyz *= 3;

		//gbgr [ 0 ] = inputdata [ uIndex + 7 ] & 0x00ffffff;
		//gbgr [ 1 ] = inputdata [ uIndex + 10 ] & 0x00ffffff;
		//gbgr [ 2 ] = inputdata [ uIndex + 13 ] & 0x00ffffff;
		gbgr.x = inputdata [ uIndex + 7 + Coord.x ];
		gbgr.y = inputdata [ uIndex + 7 + Coord.y ];
		gbgr.z = inputdata [ uIndex + 7 + Coord.z ];
		gbgr &= 0x00ffffff;

		gx.x = int( inputdata [ uIndex + 8 + Coord.x ] );
		gx.y = int( inputdata [ uIndex + 8 + Coord.y ] );
		gx.z = int( inputdata [ uIndex + 8 + Coord.z ] );
		gy = ( gx << 5 ) >> 21;
		gx = ( gx << 21 ) >> 21;

		//gu [ 0 ] = int( inputdata [ uIndex + 9 ] ) & 0xff;
		//gu [ 1 ] = int( inputdata [ uIndex + 12 ] ) & 0xff;
		//gu [ 2 ] = int( inputdata [ uIndex + 15 ] ) & 0xff;
		//gv [ 0 ] = int( inputdata [ uIndex + 9 ] >> 8 ) & 0xff;
		//gv [ 1 ] = int( inputdata [ uIndex + 12 ] >> 8 ) & 0xff;
		//gv [ 2 ] = int( inputdata [ uIndex + 15 ] >> 8 ) & 0xff;
		gu.x = int( inputdata [ uIndex + 9 + Coord.x ] );
		gu.y = int( inputdata [ uIndex + 9 + Coord.y ] );
		gu.z = int( inputdata [ uIndex + 9 + Coord.z ] );



		
		//GPU_CTRL_Read_ABR = ( GPU_CTRL_Read >> 5 ) & 3;
		
		// DTD is bit 9 in GPU_CTRL_Read
		GPU_CTRL_Read_DTD = ( GPU_CTRL_Read >> 9 ) & 1;
		
		// if not gradient, then all colors the same as first color
		if ( ( Comm & 0x10 ) == 0 )
		{
			//gbgr[1] = gbgr[0];
			//gbgr[2] = gbgr[0];
			gbgr = uvec4( bgr32 );
		}

		// if textured and tge==1, then bgr32 = 0x00808080
		if ( ( ( Comm & 0x4 ) != 0 ) && ( Command_TGE == 1 ) )
		{
			//gbgr[0] = 0x00808080;
			//gbgr[1] = 0x00808080;
			//gbgr[2] = 0x00808080;
			gbgr = uvec4( 0x00808080 );

			// also means no dithering on the texture
			GPU_CTRL_Read_DTD = 0;
		}


		
		//////////////////////////////////////////
		// get coordinates on screen
		gx += DrawArea_OffsetX;
		gy += DrawArea_OffsetY;
		
		
		// get the left/right most x
		LeftMostX = min( min( gx.x, gx.y ), gx.z );
		RightMostX = max( max( gx.x, gx.y ), gx.z );


		tpage_tx = int( inputdata [ uIndex + 12 ] >> ( 16 + 0 ) ) & 0xf;
		tpage_ty = int( inputdata [ uIndex + 12 ] >> ( 16 + 4 ) ) & 1;
		tpage_abr = int( inputdata [ uIndex + 12 ] >> ( 16 + 5 ) ) & 3;
		tpage_tp = int( inputdata [ uIndex + 12 ] >> ( 16 + 7 ) ) & 3;


		// if not textured, then tpage abr is instead GPU_CTRL_Read_ABR
		if ( ( ( Comm & 0x4 ) == 0 ) )
		{
			tpage_abr = int( GPU_CTRL_Read_ABR );
		}



		/////////////////////////////////////////////////////////
		// Get offset into texture page
		TextureOffset = ( tpage_tx << 6 ) + ( ( tpage_ty << 8 ) << 10 );
		
		
		if ( tpage_tp == 0 )
		{
			Shift1 = 2; Shift2 = 2;
			And1 = 3; And2 = 0xf;
		}
		else if ( tpage_tp == 1 )
		{
			Shift1 = 1; Shift2 = 3;
			And1 = 1; And2 = 0xff;
		}

		/*
		iBShift = 31;
		iFShift = 0;
		iFSign = 0;
		if( Command_ABE != 0 )
		{
			switch( tpage_abr )
			{
				//0.5B + 0.5F
				case 0:
					iBShift = 1;
					iFShift = 1;
					break;
				//1.0B + 1.0F
				case 1:
					iBShift = 0;
					iFShift = 0;
					break;
				//1.0B - 1.0F
				case 2:
					iBShift = 0;
					iFShift = 0;
					iFSign = -1;
					break;
				//1.0B + 0.25F
				case 3:
					iBShift = 0;
					iFShift = 2;
					break;
			}
		}
		*/

		ivBFShiftSign = c_ivLUT_iBFShiftSign [ Command_ABE ] [ tpage_abr ];

		
		// get rgb values
		//gr = ivec4( gbgr ) & 0xff;
		//gg = ivec4( gbgr >> 8 ) & 0xff;
		//gb = ivec4( gbgr >> 16 ) & 0xff;
		//grgb0.rgb = ivec3( gr.x, gg.x, gb.x );
		//grgb1.rgb = ivec3( gr.y, gg.y, gb.y );
		//grgb2.rgb = ivec3( gr.z, gg.z, gb.z );
		grgb0 = ivec4( uvec4( unpack8( uint( gbgr.x ) ) ) );
		grgb1 = ivec4( uvec4( unpack8( uint( gbgr.y ) ) ) );
		grgb2 = ivec4( uvec4( unpack8( uint( gbgr.z ) ) ) );

		//gu &= 0xffff;
		guv0 = ivec4( uvec4( unpack8( uint( gu.x ) ) ) );
		guv1 = ivec4( uvec4( unpack8( uint( gu.y ) ) ) );
		guv2 = ivec4( uvec4( unpack8( uint( gu.z ) ) ) );

		//gv = ( gu >> 8 ) & 0xff;
		//gu &= 0xff;

		// transpose values
		//grgb0.rgb = ivec3( gr.x, gg.x, gb.x );
		//grgb1.rgb = ivec3( gr.y, gg.y, gb.y );
		//grgb2.rgb = ivec3( gr.z, gg.z, gb.z );

		//guv0.xy = ivec2( gu.x, gv.x );
		//guv1.xy = ivec2( gu.y, gv.y );
		//guv2.xy = ivec2( gu.z, gv.z );

		
		/////////////////////////////////////////////////
		// draw top part of triangle
		
		// denominator is negative when x1 is on the left, positive when x1 is on the right
		//t0 = y1 - y2;
		//t1 = y0 - y2;
		//denominator = ( ( x0 - x2 ) * t0 ) - ( ( x1 - x2 ) * t1 );
		gt.xy = gy.yx - gy.zz;
		denominator = ( ( gx.x - gx.z ) * gt.x ) - ( ( gx.y - gx.z ) * gt.y );
		if ( denominator != 0 )
		{
			//dC_across.rgb = intdivdv3( ( ( grgb0.rgb - grgb2.rgb ) * gt.x ) - ( ( grgb1.rgb - grgb2.rgb ) * gt.y ) , denominator, 0, 0, 16 );
			dC_across.rgb = int64div3( ( ( grgb0.rgb - grgb2.rgb ) * gt.x ) - ( ( grgb1.rgb - grgb2.rgb ) * gt.y ) , denominator, 0, 0, 16 );
			
			//dT_across.xy = intdivdv2( ( ( guv0.xy - guv2.xy ) * gt.x ) - ( ( guv1.xy - guv2.xy ) * gt.y ), denominator, 0, 0, 16 );
			dT_across.xy = int64div2( ( ( guv0.xy - guv2.xy ) * gt.x ) - ( ( guv1.xy - guv2.xy ) * gt.y ), denominator, 0, 0, 16 );
		}
		
		
		
		
		//if ( denominator < 0 )
		//{
			// x1 is on the left and x0 is on the right //
			
			////////////////////////////////////
			// get slopes
			
			//if ( ( y1 - y0 ) != 0 )
			if ( ( gy.y - gy.x ) != 0 )
			{
				/////////////////////////////////////////////
				// init x on the left and right
				//x_left = ( x0 << 16 );
				//x_right = x_left;
				x.xy = gx.xx << 16;
				
				//R_left = ( r0 << 16 );
				//G_left = ( g0 << 16 );
				//B_left = ( b0 << 16 );
				C_left.rgb = grgb0.rgb << 16;

				//U_left = ( u0 << 16 );
				//V_left = ( v0 << 16 );
				T_left.xy = guv0.xy << 16;
				
				if ( denominator < 0 )
				{
					//dx_left = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					//dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					dx.xy = ivec2( ( i64vec2( gx.yz - gx.xx ) << 16 ) / i64vec2( gy.yz - gy.xx ) );
					
					//dC_left.rgb = ( ( grgb1.rgb - grgb0.rgb ) << 16 ) / ( gy.y - gy.x );
					dC_left.rgb = int64div3( grgb1.rgb - grgb0.rgb, gy.y - gy.x, 0, 0, 16 );
					
					//dU_left = ( (( u1 - u0 ) << 16 ) ) / ( y1 - y0 );
					//dV_left = ( (( v1 - v0 ) << 16 ) ) / ( y1 - y0 );
					//dT_left.xy = ( ( guv1.xy - guv0.xy ) << 16 ) / ( gy.y - gy.x );
					dT_left.xy = int64div2( guv1.xy - guv0.xy, gy.y - gy.x, 0, 0, 16 );
				}
				else
				{
					//dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
					//dx_right = ( ( x1 - x0 ) << 16 ) / ( y1 - y0 );
					dx.xy = ivec2( ( i64vec2( gx.zy - gx.xx ) << 16 ) / i64vec2( gy.zy - gy.xx ) );
					
					//dC_left.rgb = ( ( grgb2.rgb - grgb0.rgb ) << 16 ) / ( gy.z - gy.x );
					dC_left.rgb = int64div3( grgb2.rgb - grgb0.rgb, gy.z - gy.x, 0, 0, 16 );
					
					//dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
					//dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
					//dT_left.xy = ( ( guv2.xy - guv0.xy ) << 16 ) / ( gy.z - gy.x );
					dT_left.xy = int64div2( guv2.xy - guv0.xy, gy.z - gy.x, 0, 0, 16 );
				}
			}
			else
			{
				if ( denominator < 0 )
				{
					// change x_left and x_right where y1 is on left
					//x_left = ( x1 << 16 );
					//x_right = ( x0 << 16 );
					x.xy = gx.yx << 16;
					
					//R_left = ( r1 << 16 );
					//G_left = ( g1 << 16 );
					//B_left = ( b1 << 16 );
					C_left.rgb = grgb1.rgb << 16;

					//U_left = ( u1 << 16 );
					//V_left = ( v1 << 16 );
					T_left.xy = guv1.xy << 16;
					
					//if ( ( y2 - y1 ) != 0 )
					if ( ( gy.z - gy.y ) != 0 )
					{
						//dx_left = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						//dx_right = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						dx.xy = ivec2( ( i64vec2( gx.zz - gx.yx ) << 16 ) / i64vec2( gy.zz - gy.yx ) );
						
						//dC_left.rgb = ( ( grgb2.rgb - grgb1.rgb ) << 16 ) / ( gy.z - gy.y );
						dC_left.rgb = int64div3( grgb2.rgb - grgb1.rgb, gy.z - gy.y, 0, 0, 16 );
						
						//dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
						//dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
						//dT_left.xy = ( ( guv2.xy - guv1.xy ) << 16 ) / ( gy.z - gy.y );
						dT_left.xy = int64div2( guv2.xy - guv1.xy, gy.z - gy.y, 0, 0, 16 );
					}
				}
				else
				{
					//x_left = ( x0 << 16 );
					//x_right = ( x1 << 16 );
					x.xy = gx.xy << 16;
				
					//R_left = ( r0 << 16 );
					//G_left = ( g0 << 16 );
					//B_left = ( b0 << 16 );
					C_left.rgb = grgb0.rgb << 16;
					
					//U_left = ( u0 << 16 );
					//V_left = ( v0 << 16 );
					T_left.xy = guv0.xy << 16;
					
					//if ( ( y2 - y1 ) != 0 )
					if ( ( gy.z - gy.y ) != 0 )
					{
						//dx_left = ( ( x2 - x0 ) << 16 ) / ( y2 - y0 );
						//dx_right = ( ( x2 - x1 ) << 16 ) / ( y2 - y1 );
						dx.xy = ivec2( ( i64vec2( gx.zz - gx.xy ) << 16 ) / i64vec2( gy.zz - gy.xy ) );
						
						//dC_left.rgb = ( ( grgb2.rgb - grgb0.rgb ) << 16 ) / ( gy.z - gy.x );
						dC_left.rgb = int64div3( grgb2.rgb - grgb0.rgb, gy.z - gy.x, 0, 0, 16 );
						
						//dU_left = ( (( u2 - u0 ) << 16 ) ) / ( y2 - y0 );
						//dV_left = ( (( v2 - v0 ) << 16 ) ) / ( y2 - y0 );
						//dT_left.xy = ( ( guv2.xy - guv0.xy ) << 16 ) / ( gy.z - gy.x );
						dT_left.xy = int64div2( guv2.xy - guv0.xy, gy.z - gy.x, 0, 0, 16 );
					}
				}
			}
		//}
		

		
		
		// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
		//R_left |= ( 1 << 15 );
		//G_left |= ( 1 << 15 );
		//B_left |= ( 1 << 15 );
		C_left.rgb |= ( 1 << 15 );

		//U_left |= ( 1 << 15 );
		//V_left |= ( 1 << 15 );
		T_left.xy |= ( 1 << 15 );

		//x_left += 0xffff;
		//x_right -= 1;
		
		//StartY = y0;
		//EndY = y1;
		StartY = gy.x;
		EndY = gy.y;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				//StartY = EndY;
				StartY = DrawArea_TopLeftY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			//x_left += dx_left * Temp;
			//x_right += dx_right * Temp;
			x.xy += dx.xy * Temp;
			
			//R_left += dR_left * Temp;
			//G_left += dG_left * Temp;
			//B_left += dB_left * Temp;
			C_left += dC_left * Temp;
			
			//U_left += dU_left * Temp;
			//V_left += dV_left * Temp;
			T_left += dT_left * Temp;
		}
		
		//if ( EndY > DrawArea_BottomRightY )
		//{
		//	EndY = DrawArea_BottomRightY + 1;
		//}
		EndY = min( EndY, DrawArea_BottomRightY + 1 );


		// check if sprite is within draw area
		//if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || y2 <= DrawArea_TopLeftY || y0 > DrawArea_BottomRightY ) bDraw = 0;	//return;
		if ( RightMostX <= DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || gy.z <= DrawArea_TopLeftY || gy.x > DrawArea_BottomRightY ) bDraw = 0;	//return;
		
		// skip drawing if distance between vertices is greater than max allowed by GPU
		//if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( x2 - x1 ) > c_MaxPolygonWidth ) || ( y1 - y0 > c_MaxPolygonHeight ) || ( y2 - y1 > c_MaxPolygonHeight ) )
		//if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( y2- y0 ) > c_MaxPolygonHeight ) )
		if ( ( ( RightMostX - LeftMostX ) > c_MaxPolygonWidth ) || ( ( gy.z - gy.x ) > c_MaxPolygonHeight ) )
		{
			// skip drawing polygon
			//return;
			bDraw = 0;
		}


		data [ uIdx + 0 ] = bDraw;
		data [ uIdx + 1 ] = int( PixelMask );
		data [ uIdx + 2 ] = int( SetPixelMask );
		data [ uIdx + 3 ] = int( GPU_CTRL_Read_ABR );

		data [ uIdx + 4 ] = int( Command_ABE );
		data [ uIdx + 5 ] = int( Command_TGE );
		data [ uIdx + 6 ] = int( bgr32 );
		data [ uIdx + 7 ] = int( bgr16 );

		data [ uIdx + 8 ] = int( GPU_CTRL_Read_DTD );
		data [ uIdx + 9 ] = int( DrawArea_TopLeftX );
		data [ uIdx + 10 ] = int( DrawArea_BottomRightX );
		data [ uIdx + 11 ] = EndY;

		data [ uIdx + 12 ] = Shift1;
		data [ uIdx + 13 ] = Shift2;
		data [ uIdx + 14 ] = And1;
		data [ uIdx + 15 ] = And2;

		data [ uIdx + 16 ] = TWYTWH;
		data [ uIdx + 17 ] = TWXTWW;
		data [ uIdx + 18 ] = Not_TWH;
		data [ uIdx + 19 ] = Not_TWW;

		data [ uIdx + 20 ] = TextureOffset;
		data [ uIdx + 21 ] = ClutOffset;
		data [ uIdx + 22 ] = clut_xoffset;
		data [ uIdx + 23 ] = tpage_abr;

		//data [ uIdx + 24 ] = dC_across.r;	//dR_across;
		//data [ uIdx + 25 ] = dC_across.g;	//dG_across;
		//data [ uIdx + 26 ] = dC_across.b;	//dB_across;
		//data [ uIdx + 27 ] = bTexture;
		dC_across.w = bTexture;
		data32_4 [ uIndex + 6 ] = dC_across;

		// IMPORTANT NOTE: index #31 is being used for synchronization
		data [ uIdx + 28 ] = dT_across.x;	//dU_across;
		data [ uIdx + 29 ] = dT_across.y;	//dV_across;

		data8_4 [ uIdx + 30 ] = i8vec4( ivBFShiftSign );
		//data [ uIdx + 30 ] = iBShift | ( iFShift << 8 ) | ( iFSign << 16 );	//iBShift/iFShift/iFSign;
		//data [ uIdx + 31 ] = sync;
		//data32_4 [ uIndex + 7 ] = dT_across;


		//data [ uIdx + 32 ] = x.x;	//x_left;
		//data [ uIdx + 33 ] = x.y;	//x_right;
		//data [ uIdx + 34 ] = dx.x;	//dx_left;
		//data [ uIdx + 35 ] = dx.y;	//dx_right;
		x.zw = dx.xy;
		data32_4 [ uIndex + 8 ] = x;

		//data [ uIdx + 36 ] = C_left.r;	//R_left;
		//data [ uIdx + 37 ] = C_left.g;	//G_left;
		//data [ uIdx + 38 ] = C_left.b;	//B_left;
		//data [ uIdx + 39 ] = StartY;
		C_left.w = StartY;
		data32_4 [ uIndex + 9 ] = C_left;

		//data [ uIdx + 40 ] = dC_left.r;	//dR_left;
		//data [ uIdx + 41 ] = dC_left.g;	//dG_left;
		//data [ uIdx + 42 ] = dC_left.b;	//dB_left;
		//data [ uIdx + 43 ] = EndY;
		dC_left.w = EndY;
		data32_4 [ uIndex + 10 ] = dC_left;

		//data [ uIdx + 44 ] = T_left.x;	//U_left;
		//data [ uIdx + 45 ] = T_left.y;	//V_left;
		//data [ uIdx + 46 ] = dT_left.x;	//dU_left;
		//data [ uIdx + 47 ] = dT_left.y;	//dV_left;
		T_left.zw = dT_left.xy;
		data32_4 [ uIndex + 11 ] = T_left;


	// -------------------------------------------


		//////////////////////////////////////////////////////
		// check if y1 is on the left or on the right
		if ( denominator < 0 )
		{
			//x_left = ( x1 << 16 );
			//x_right = ( x0 << 16 ) + ( dx_right * ( y1 - y0 ) );
			x.xy = gx.yx << 16;
			x.y += dx.y * ( gy.y - gy.x );
			
			///R_left = ( r1 << 16 );
			//G_left = ( g1 << 16 );
			//B_left = ( b1 << 16 );
			C_left = ( grgb1 << 16 );
			
			// r,g,b values are not specified with a fractional part, so there must be an initial fractional part
			//R_left |= ( 1 << 15 );
			//G_left |= ( 1 << 15 );
			//B_left |= ( 1 << 15 );
			C_left |= ( 1 << 15 );

			//U_left = ( u1 << 16 );
			//V_left = ( v1 << 16 );
			T_left = guv1 << 16;
			
			//if ( ( y2 - y1 ) != 0 )
			if ( ( gy.z - gy.y ) != 0 )
			{
				//dx_left = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				dx.x = int( ( int64_t( gx.z - gx.y ) << 16 ) / int64_t( gy.z - gy.y ) );
				
				//dC_left.rgb = ( ( grgb2.rgb - grgb1.rgb ) << 16 ) / ( gy.z - gy.y );
				dC_left.rgb = int64div3( grgb2.rgb - grgb1.rgb, gy.z - gy.y, 0, 0, 16 );
				
				//dU_left = ( (( u2 - u1 ) << 16 ) ) / ( y2 - y1 );
				//dV_left = ( (( v2 - v1 ) << 16 ) ) / ( y2 - y1 );
				//dT_left.xy = ( ( guv2.xy - guv1.xy ) << 16 ) / ( gy.z - gy.y );
				dT_left.xy = int64div2( guv2.xy - guv1.xy, gy.z - gy.y, 0, 0, 16 );
			}
		}
		else
		{
			//x_left = ( x0 << 16 ) + ( dx_left * ( y1 - y0 ) );
			//x_right = ( x1 << 16 );
			x.xy = gx.xy << 16;
			x.x += ( dx.x * ( gy.y - gy.x ) );
			
			//R_left = ( ( r0 << 16 ) | 0x8000 ) + ( dR_left * ( y1 - y0 ) );
			//G_left = ( ( g0 << 16 ) | 0x8000 ) + ( dG_left * ( y1 - y0 ) );
			//B_left = ( ( b0 << 16 ) | 0x8000 ) + ( dB_left * ( y1 - y0 ) );
			C_left.rgb = ( ( grgb0.rgb << 16 ) | 0x8000 ) + ( dC_left.rgb * ( gy.y - gy.x ) );
			
			//U_left = ( u0 << 16 ) + ( dU_left * ( y1 - y0 ) );
			//V_left = ( v0 << 16 ) + ( dV_left * ( y1 - y0 ) );
			T_left.xy = ( guv0.xy << 16 ) + ( dT_left.xy * ( gy.y - gy.x ) );
			
			//if ( ( y2 - y1 ) != 0 )
			if ( ( gy.z - gy.y ) != 0 )
			{
				//dx_right = (( x2 - x1 ) << 16 ) / ( y2 - y1 );
				dx.y = int( ( int64_t( gx.z - gx.y ) << 16 ) / int64_t( gy.z - gy.y ) );
			}
		}


		//R_left += ( 1 << 15 );
		//G_left += ( 1 << 15 );
		//B_left += ( 1 << 15 );

		//U_left += ( 1 << 15 );
		//V_left += ( 1 << 15 );
		T_left.xy += ( 1 << 15 );

		
		//StartY = y1;
		//EndY = y2;
		StartY = gy.y;
		EndY = gy.z;

		if ( StartY < DrawArea_TopLeftY )
		{
			
			if ( EndY < DrawArea_TopLeftY )
			{
				Temp = EndY - StartY;
				//StartY = EndY;
				StartY = DrawArea_TopLeftY;
			}
			else
			{
				Temp = DrawArea_TopLeftY - StartY;
				StartY = DrawArea_TopLeftY;
			}
			
			//x_left += dx_left * Temp;
			//x_right += dx_right * Temp;
			x.xy += dx.xy * Temp;
			
			//R_left += dR_left * Temp;
			//G_left += dG_left * Temp;
			//B_left += dB_left * Temp;
			C_left.rgb += dC_left.rgb * Temp;
			
			//U_left += dU_left * Temp;
			//V_left += dV_left * Temp;
			T_left.xy += dT_left.xy * Temp;
		}
		
		//if ( EndY > DrawArea_BottomRightY )
		//{
		//	EndY = DrawArea_BottomRightY + 1;
		//}
		EndY = min( EndY, DrawArea_BottomRightY + 1 );


	// ---------------------------------------------

		

		//data [ uIdx + 48 ] = x.x;	//x_left;
		//data [ uIdx + 49 ] = x.y;	//x_right;
		//data [ uIdx + 50 ] = dx.x;	//dx_left;
		//data [ uIdx + 51 ] = dx.y;	//dx_right;
		x.zw = dx.xy;
		data32_4 [ uIndex + 12 ] = x;

		//data [ uIdx + 52 ] = C_left.r;	//R_left;
		//data [ uIdx + 53 ] = C_left.g;	//G_left;
		//data [ uIdx + 54 ] = C_left.b;	//B_left;
		//data [ uIdx + 55 ] = StartY;
		C_left.w = StartY;
		data32_4 [ uIndex + 13 ] = C_left;

		//data [ uIdx + 56 ] = dC_left.r;	//dR_left;
		//data [ uIdx + 57 ] = dC_left.g;	//dG_left;
		//data [ uIdx + 58 ] = dC_left.b;	//dB_left;
		//data [ uIdx + 59 ] = EndY;
		dC_left.w = EndY;
		data32_4 [ uIndex + 14 ] = dC_left;

		//data [ uIdx + 60 ] = T_left.x;	//U_left;
		//data [ uIdx + 61 ] = T_left.y;	//V_left;
		//data [ uIdx + 62 ] = dT_left.x;	//dU_left;
		//data [ uIdx + 63 ] = dT_left.y;	//dV_left;
		T_left.zw = dT_left.xy;
		data32_4 [ uIndex + 15 ] = T_left;
		

		}	// end if ( ( Comm >= 0x20 ) && ( Comm <= 0x3f ) )

		}	// end if ( subgroupAny(( Comm >= 0x20 ) && ( Comm <= 0x3f )) )

#ifdef ENABLE_PRECALC_JUMPS_LINE
		if ( subgroupAny(( Comm >= 0x40 ) && ( Comm < 0x60 )) )
#endif
		{

		// check for line //
		if ( ( Comm >= 0x40 ) && ( Comm < 0x60 ) )
		{
			// command is to draw line //

			//gx [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 21 ) >> 21 );
			//gy [ 0 ] = ( ( int( inputdata [ uIndex + 8 ] ) << 5 ) >> 21 );
			//gx [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 21 ) >> 21 );
			//gy [ 1 ] = ( ( int( inputdata [ uIndex + 10 ] ) << 5 ) >> 21 );
			gx.x = int( inputdata [ uIndex + 8 ] );
			gx.y = int( inputdata [ uIndex + 10 ] );
			gy.xy = ( gx.xy << 5 ) >> 21;
			gx.xy = ( gx.xy << 21 ) >> 21;

			gbgr.x = int( inputdata [ uIndex + 7 ] ) & 0x00ffffff;
			gbgr.y = int( inputdata [ uIndex + 9 ] ) & 0x00ffffff;

			//////////////////////////////////////////
			// get coordinates on screen
			gx += DrawArea_OffsetX;
			gy += DrawArea_OffsetY;

			// get the endpoint, since it shouldn't be drawn
			iEndpointX = gx.y;
			iEndpointY = gy.y;
		
			//x_distance = abs( gx[0] - gx[1] );
			//y_distance = abs( gy[0] - gy[1] );
			x_distance = abs( gx.x - gx.y );
			y_distance = abs( gy.x - gy.y );

			//Coord0 = 0;
			//Coord1 = 1;
		
			if ( x_distance > y_distance )
			{
				// sort coords from left to right if line is horizontal
				if ( gx.y < gx.x )
				{
					gx.xy = gx.yx;
					gy.xy = gy.yx;
					gbgr.xy = gbgr.yx;
					//Temp = Coord0;
					//Coord0 = Coord1;
					//Coord1 = Temp;
				}

			}
			else
			{
				// sort coords from top to bottom if line is vertical
				if ( gy.y < gy.x )
				{
					gx.xy = gx.yx;
					gy.xy = gy.yx;
					gbgr.xy = gbgr.yx;
					//Temp = Coord0;
					//Coord0 = Coord1;
					//Coord1 = Temp;
				}

			}
		
				
		
			// get the left/right most x
			LeftMostX = min( gx.x, gx.y );
			RightMostX = max( gx.x, gx.y );
			TopMostY = min( gy.x, gy.y );
			BottomMostY = max( gy.x, gy.y );

		

			// check for some important conditions
			if ( DrawArea_BottomRightX < DrawArea_TopLeftX )
			{
				//return;
				bDraw = 0;
			}
		
			if ( DrawArea_BottomRightY < DrawArea_TopLeftY )
			{
				//return;
				bDraw = 0;
			}

			// check if sprite is within draw area
			if ( RightMostX < DrawArea_TopLeftX || LeftMostX > DrawArea_BottomRightX || BottomMostY < DrawArea_TopLeftY || TopMostY > DrawArea_BottomRightY )
			{
				//return;
				bDraw = 0;
			}
		
			// skip drawing if distance between vertices is greater than max allowed by GPU
			//if ( ( abs( x1 - x0 ) > c_MaxPolygonWidth ) || ( abs( y1 - y0 ) > c_MaxPolygonHeight ) )
			if ( ( x_distance > c_MaxPolygonWidth ) || ( y_distance > c_MaxPolygonHeight ) )
			{
				// skip drawing polygon
				//return;
				bDraw = 0;
			}
		
		
		

			// get rgb-values
			//c0.r = int( gbgr.x ) & 0xff;
			//c1.r = int( gbgr.y ) & 0xff;
			//c0.g = ( int( gbgr.x ) >> 8 ) & 0xff;
			//c1.g = ( int( gbgr.y ) >> 8 ) & 0xff;
			//c0.b = ( int( gbgr.x ) >> 16 ) & 0xff;
			//c1.b = ( int( gbgr.y ) >> 16 ) & 0xff;

			c0 = ivec4( uvec4( unpack8( uint( gbgr.x ) ) ) );
			c1 = ivec4( uvec4( unpack8( uint( gbgr.y ) ) ) );
	
			//iR = ( r0 << 16 ) + 0x8000;
			//iG = ( g0 << 16 ) + 0x8000;
			//iB = ( b0 << 16 ) + 0x8000;
	
			//StartX = x0;
			//EndX = x1;
			//StartY = y0;
			//EndY = y1;
			StartX = gx.x;
			EndX = gx.y;
			StartY = gy.x;
			EndY = gy.y;

			/*
			iBShift = 31;
			iFShift = 0;
			iFSign = 0;
			if( Command_ABE != 0 )
			{
				switch( GPU_CTRL_Read_ABR )
				{
					//0.5B + 0.5F
					case 0:
						iBShift = 1;
						iFShift = 1;
						break;
					//1.0B + 1.0F
					case 1:
						iBShift = 0;
						iFShift = 0;
						break;
					//1.0B - 1.0F
					case 2:
						iBShift = 0;
						iFShift = 0;
						iFSign = -1;
						break;
					//1.0B + 0.25F
					case 3:
						iBShift = 0;
						iFShift = 2;
						break;
				}
			}
			*/

			ivBFShiftSign = c_ivLUT_iBFShiftSign [ Command_ABE ] [ GPU_CTRL_Read_ABR ];



			// check if line is horizontal
			if ( x_distance > y_distance )
			{
		
				// get the largest length
				line_length = x_distance;
		
				c0.a = gy.x;
				c1.a = gy.y;
			
				//ix = x0;
				//iy = ( y0 << 16 ) + 0x8000;
				iC = ( c0 << 16 ) + 0x8000;
		
				if ( line_length != 0 )
				{
					/////////////////////////////////////////////
					// init x on the left and right
			
					//dx_left = ( ( x1 - x0 ) << 16 ) / ( ( y1 - y0 ) + 1 );
					//dx = ( ( x1 - x0 ) << 16 ) / line_length;

					//dy = ( ( y1 - y0 ) << 8 ) / line_length;
					//dr = ( ( r1 - r0 ) << 8 ) / line_length;
					//dg = ( ( g1 - g0 ) << 8 ) / line_length;
					//db = ( ( b1 - b0 ) << 8 ) / line_length;
					dc = ( ( c1 - c0 ) << 8 ) / line_length;

					//dy <<= 8;
					//dr <<= 8;
					//dg <<= 8;
					//db <<= 8;
					dc <<= 8;
				}

		
				// check if line is going left or right
				// clip against edge of screen
				//if ( StartX < DrawArea_TopLeftX )
				//{
				//	Temp = DrawArea_TopLeftX - StartX;
				//	StartX = DrawArea_TopLeftX;
				//
				//	iy += dy * Temp;
				//	iR += dr * Temp;
				//	iG += dg * Temp;
				//	iB += db * Temp;
				//}
				Temp = max( StartX, DrawArea_TopLeftX ) - StartX;
				StartX = max( StartX, DrawArea_TopLeftX );

				iC += dc * Temp;
			
				//if ( EndX > DrawArea_BottomRightX )
				//{
				//	EndX = DrawArea_BottomRightX;
				//}
				EndX = min( EndX, DrawArea_BottomRightX );
		
		
				//if ( dy < 0 )
				if ( dc.a < 0 )
				{
	
					//if ( ( iy >> 16 ) < DrawArea_TopLeftY )
					if ( ( iC.a >> 16 ) < DrawArea_TopLeftY )
					{
						//return;
						bDraw = 0;
					}

				}
		
				//if ( dy > 0 )
				if ( dc.a > 0 )
				{
					//if ( ( iy >> 16 ) > DrawArea_BottomRightY )
					if ( ( iC.a >> 16 ) > DrawArea_BottomRightY )
					{
						// line is veering off screen
						//return;
						bDraw = 0;
					}
			

				}
		
			}
			else
			{
				// line is vertical //

				// get the largest length
				line_length = y_distance;
		
				c0.a = gx.x;
				c1.a = gx.y;
			
				//ix = ( x0 << 16 ) + 0x8000;
				iC = ( c0 << 16 ) + 0x8000;
		
				if ( line_length != 0 )
				{
					/////////////////////////////////////////////
					// init x on the left and right
			
					//dx.x = ( ( x1 - x0 ) << 8 ) / line_length;
					//dr = ( ( r1 - r0 ) << 8 ) / line_length;
					//dg = ( ( g1 - g0 ) << 8 ) / line_length;
					//db = ( ( b1 - b0 ) << 8 ) / line_length;
					dc = ( ( c1 - c0 ) << 8 ) / line_length;

					//dx.x <<= 8;
					//dr <<= 8;
					//dg <<= 8;
					//db <<= 8;
					dc <<= 8;
				}
		
		
			
				// clip against edge of screen
				//if ( StartY < DrawArea_TopLeftY )
				//{
				//	Temp = DrawArea_TopLeftY - StartY;
				//	StartY = DrawArea_TopLeftY;
				//
				//	ix += dx.x * Temp;
				//	iR += dr * Temp;
				//	iG += dg * Temp;
				//	iB += db * Temp;
				//}
				Temp = max( StartY, DrawArea_TopLeftY ) - StartY;
				StartY = max( StartY, DrawArea_TopLeftY );

				iC += dc * Temp;
			
				//if ( EndY > DrawArea_BottomRightY )
				//{
				//	EndY = DrawArea_BottomRightY;
				//}
				EndY = min( EndY, DrawArea_BottomRightY );
	
				//if ( dx.x < 0 )
				if ( dc.a < 0 )
				{
					//if ( ( ix >> 16 ) < DrawArea_TopLeftX )
					if ( ( iC.a >> 16 ) < DrawArea_TopLeftX )
					{
						// line is veering off screen
						//return;
						bDraw = 0;
					}
			
				}
		
				//if ( dx.x > 0 )
				if ( dc.a > 0 )
				{
					//if ( ( ix >> 16 ) > DrawArea_BottomRightX )
					if ( ( iC.a >> 16 ) > DrawArea_BottomRightX )
					{
						// line is veering off screen
						//return;
						bDraw = 0;
					}
			
				}

			}	// end if else if ( x_distance > y_distance )

			data [ uIdx + 0 ] = bDraw;
			data [ uIdx + 1 ] = int( PixelMask );
			data [ uIdx + 2 ] = int( SetPixelMask );
			data [ uIdx + 3 ] = int( GPU_CTRL_Read_ABR );

			data [ uIdx + 4 ] = int( Command_ABE );
			data [ uIdx + 5 ] = int( bgr32 );
			data [ uIdx + 6 ] = int( bgr16 );
			data [ uIdx + 7 ] = int( GPU_CTRL_Read_DTD );

			data [ uIdx + 8 ] = int( DrawArea_TopLeftX );
			data [ uIdx + 9 ] = int( DrawArea_BottomRightX );
			data [ uIdx + 10 ] = int( DrawArea_TopLeftY );
			data [ uIdx + 11 ] = int( DrawArea_BottomRightY );

			data [ uIdx + 12 ] = iC.a;	//ix;
			data [ uIdx + 13 ] = iC.a;	//iy;
			data [ uIdx + 14 ] = dc.a;	//dx.x;
			data [ uIdx + 15 ] = dc.a;	//dy;

			data [ uIdx + 16 ] = x_distance;
			data [ uIdx + 17 ] = y_distance;
			data [ uIdx + 18 ] = line_length;
			//data [ uIdx + 19 ] = ;

			data [ uIdx + 20 ] = StartX;
			data [ uIdx + 21 ] = StartY;
			data [ uIdx + 22 ] = EndX;
			data [ uIdx + 23 ] = EndY;

			//data [ uIdx + 24 ] = iBShift;
			//data [ uIdx + 25 ] = iFShift;
			//data [ uIdx + 26 ] = iFSign;
			//data [ uIdx + 27 ] = ;
			data32_4 [ uIndex + 6 ] = ivBFShiftSign;

			// note: index 31 has sync var
			//data [ uIdx + 28 ] = dc.r;	//dr;
			//data [ uIdx + 29 ] = dc.g;	//dg;
			//data [ uIdx + 30 ] = dc.b;	//db;
			//data [ uIdx + 31 ] = dc.a;
			//data32_4 [ uIndex + 7 ] = dc;

			//data [ uIdx + 32 ] = iR;
			//data [ uIdx + 33 ] = iG;
			//data [ uIdx + 34 ] = iB;
			//data [ uIdx + 35 ] = ;
			data32_4 [ uIndex + 8 ] = iC;

			// don't want to interfere with 39
			//data [ uIdx + 36 ] = dc.r;	//dr;
			//data [ uIdx + 37 ] = dc.g;	//dg;
			//data [ uIdx + 38 ] = dc.b;	//db;
			//data [ uIdx + 39 ] = dc.a;
			//data32_4 [ uIndex + 9 ] = dc;

			// also transfer the endpoints
			data [ uIdx + 36 ] = iEndpointX;
			data [ uIdx + 37 ] = iEndpointY;

			// also put StartY at 39 and EndY at 59
			data [ uIdx + 39 ] = StartY;
			data [ uIdx + 59 ] = EndY;

			//data [ uIdx + 40 ] = dc.r;	//dr;
			//data [ uIdx + 41 ] = dc.g;	//dg;
			//data [ uIdx + 42 ] = dc.b;	//db;
			//data [ uIdx + 43 ] = dc.a;
			data32_4 [ uIndex + 10 ] = dc;

		}	// end if ( ( Comm >= 0x40 ) && ( Comm < 0x60 ) )

		}	// end if ( subgroupAny(( Comm >= 0x40 ) && ( Comm < 0x60 )) )



	}
	//while ( ( Comm != 0xff ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );

	//barrier ();
	//prelist_data ();

	// this barrier is now outside the function after the optional workgroup sync
	//barrier ();
}




void draw_texture ( int xsize, int ysize )
{
	//int xid = int( gl_GlobalInvocationID.x );
	//int yid = int( gl_GlobalInvocationID.y );

	int xxid = int( gl_LocalInvocationIndex );

	// global invocation index
	int gxxid = int( gl_LocalInvocationIndex + ( gl_WorkGroupID.x * xxinc ) );

	uint CurBarrierSync;

	ivec2 pos;
	uvec4 rgba;
	int pixel;
	vec4 frgba;

	int idx;
	vec4 vfr, vfg, vfb, vfa;

	ivec4 ivPtr32;
	ivec4 idx4, dx4, dy4, sx4, sy4;
	int count;
	float fscalex, fscaley;
	uvec4 uvpixel32;

	mat4 fcolor4x4;

	count = SCREEN_X_SIZE * SCREEN_Y_SIZE;

	fscalex = float(xsize) / float(SCREEN_X_SIZE);
	fscaley = float(ysize) / float(SCREEN_Y_SIZE);

#ifdef USE_MEMORY_BARRIER_BUFFER

	memoryBarrierBuffer ();
	memoryBarrierShared ();
	groupMemoryBarrier ();
	memoryBarrier ();

#endif

#ifdef ENABLE_MULTIPLE_WORKGROUPS

	// need to do subgroupElect because all subgroups need to synchronize globally before they synchronize locally
	if ( subgroupElect() )
	{

		// count global subgroups that have completed the work
		CurBarrierSync = atomicAdd( auCounter, 1 );
		//atomicAdd( auCounter, 1 );

		// only need the first shader of the entire workgroup to spin wait though
		if ( xxid == 0 )
		{
			CurBarrierSync++;

			// would probably need to be a less than comparison due to possible race conditions
			//while ( atomicAdd( auCounter, 0 ) < NextBarrierSync )
			while ( CurBarrierSync < NextBarrierSync )
			{
				//CurBarrierSync = atomicAdd( auCounter, 0 );
				CurBarrierSync = atomicCompSwap( auCounter, 0, 0 );
			}
		
			// at the next sync point, need all subgroups
			NextBarrierSync += subgroup_global_count;

		}	// end if ( xxid == 0 )

	}	// end if ( subgroupElect() )

#endif	// end ENABLE_MULTIPLE_WORKGROUPS

	// don't know if all the threads have completed all the other tasks yet
	barrier ();

	
	//for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
	for ( idx = gxxid << 2; idx < count; idx += gxxinc << 2 )
	{
		idx4 = idx + ivec4( 0, 1, 2, 3 );
		dx4 = idx4 % SCREEN_X_SIZE;
		dy4 = idx4 / SCREEN_X_SIZE;

		sx4 = ivec4( vec4( dx4 ) * fscalex );
		sy4 = ivec4( vec4( dy4 ) * fscaley );

		// rotate screen 
		sy4 = ysize - sy4;

		ivPtr32 =  sx4 + ( sy4 * xsize );
		uvpixel32.x = pixelbuffer32 [ ivPtr32.x ];
		uvpixel32.y = pixelbuffer32 [ ivPtr32.y ];
		uvpixel32.z = pixelbuffer32 [ ivPtr32.z ];
		uvpixel32.w = pixelbuffer32 [ ivPtr32.w ];

#ifdef DRAW_SCREEN_TO_BUFFER
		// write to buffer instead of image
		//data32_4 [ idx >> 2 ] = uvpixel32;
		staging_buffer32_4 [ idx >> 2 ] = uvpixel32;
		
		// pixel needs alpha ??
		//uvpixel32 |= 0xff000000;

		//ivPtr32 =  dx4 + ( dy4 * SCREEN_X_SIZE );
		//data [ ivPtr32.x ] = int( uvpixel32.x );
		//data [ ivPtr32.y ] = int( uvpixel32.y );
		//data [ ivPtr32.z ] = int( uvpixel32.z );
		//data [ ivPtr32.w ] = int( uvpixel32.w );

#else
		// write screen to image (appears to be magnitude slower)

		//fcolor4x4[2] = vec4( ( uvpixel32 >> 16 ) & 0xff );
		//fcolor4x4[1] = vec4( ( uvpixel32 >> 8 ) & 0xff );
		//fcolor4x4[0] = vec4( ( uvpixel32 >> 0 ) & 0xff );
		fcolor4x4[2] = vec4( bitfieldExtract( uvpixel32, 16, 8 ) );
		fcolor4x4[1] = vec4( bitfieldExtract( uvpixel32, 8, 8 ) );
		fcolor4x4[0] = vec4( bitfieldExtract( uvpixel32, 0, 8 ) );
		fcolor4x4[3] = vec4( 255.0 );

		fcolor4x4 /= 255.0;

		fcolor4x4 = transpose( fcolor4x4 );
 
		imageStore( destTex, ivec2( dx4.x, dy4.x ), fcolor4x4[0] );
		imageStore( destTex, ivec2( dx4.y, dy4.y ), fcolor4x4[1] );
		imageStore( destTex, ivec2( dx4.z, dy4.z ), fcolor4x4[2] );
		imageStore( destTex, ivec2( dx4.w, dy4.w ), fcolor4x4[3] );
#endif

	}
	
	//imageStore( destTex, ivec2( 0, 0 ), vec4( 0.0, 0.0, 0.0, 0.0 ) );
	//memoryBarrier();

	/*
	for ( pos.y = ( yid << group_yshift ) + group_y; pos.y < ysize; pos.y += group_yinc )
	{
		for ( pos.x = ( xid << group_xshift ) + group_x; pos.x < xsize; pos.x += group_xinc )
		{
			pixel = int( pixelbuffer32 [ pos.x + ( pos.y * xsize ) ] );

			//frgba.b = float( ( pixel >> 16 ) & 0xff ) / 255.0;
			//frgba.g = float( ( pixel >> 8 ) & 0xff ) / 255.0;
			//frgba.r = float( ( pixel >> 0 ) & 0xff ) / 255.0;
			//frgba.a = 1.0;

			frgba.b = float( ( pixel >> 16 ) & 0xff );
			frgba.g = float( ( pixel >> 8 ) & 0xff );
			frgba.r = float( ( pixel >> 0 ) & 0xff );

			frgba = frgba / 255.0;
			frgba.a = 1.0;

			imageStore( destTex, pos, frgba );
		}
	}
	*/
	
}




void draw_screen( uint uIndex )
{

	int xxid = int( gl_LocalInvocationIndex );
	
	// global invocation index
	int gxxid = int( gl_LocalInvocationIndex + ( gl_WorkGroupID.x * xxinc ) );


//inputdata format:
//0: GPU_CTRL_Read
//1: DisplayRange_Horizontal
//2: DisplayRange_Vertical
//3: ScreenArea_TopLeftX
//4: ScreenArea_TopLeftY
//5: bEnableScanline
//6: Y_Pixel
//7: --------
//8: Command

	
	const int c_iVisibleArea_StartX_Cycle = 584;
	const int c_iVisibleArea_EndX_Cycle = 3192;
	const int c_iVisibleArea_StartY_Pixel_NTSC = 15;
	const int c_iVisibleArea_EndY_Pixel_NTSC = 257;
	const int c_iVisibleArea_StartY_Pixel_PAL = 34;
	const int c_iVisibleArea_EndY_Pixel_PAL = 292;

	const int c_iVisibleArea_StartY [] = { c_iVisibleArea_StartY_Pixel_NTSC, c_iVisibleArea_StartY_Pixel_PAL };
	const int c_iVisibleArea_EndY [] = { c_iVisibleArea_EndY_Pixel_NTSC, c_iVisibleArea_EndY_Pixel_PAL };

	const int c_iGPUCyclesPerPixel [] = { 10, 7, 8, 0, 5, 0, 4, 0 };
	


	uint GPU_CTRL_Read;
	int DisplayRange_X1;
	int DisplayRange_X2;
	int DisplayRange_Y1;
	int DisplayRange_Y2;
	int ScreenArea_TopLeftX;
	int ScreenArea_TopLeftY;
	int bEnableScanline;
	int Y_Pixel;

	// need to know visible range of screen for NTSC and for PAL (each should be different)
	// NTSC visible y range is usually from 16-256 (0x10-0x100) (height=240)
	// PAL visible y range is usually from 35-291 (0x23-0x123) (height=256)
	// NTSC visible x range is.. I don't know. start with from about gpu cycle#544 to about gpu cycle#3232 (must use gpu cycles since res changes)
	int VisibleArea_StartX, VisibleArea_EndX, VisibleArea_StartY, VisibleArea_EndY, VisibleArea_Width, VisibleArea_Height;
	// this allows you to calculate horizontal pixels
	int GPU_CyclesPerPixel;
	// need to know where to draw the actual image at
	int Draw_StartX, Draw_StartY, Draw_EndX, Draw_EndY, Draw_Width, Draw_Height;

	int Source_Height;
	int TopBorder_Height, BottomBorder_Height, LeftBorder_Width, RightBorder_Width;
	int current_width, current_height, current_size, current_xmax, current_ymax;

	uint GPU_CTRL_Read_ISINTER;
	uint GPU_CTRL_Read_HEIGHT;
	uint GPU_CTRL_Read_WIDTH;
	uint GPU_CTRL_Read_DEN;
	uint GPU_CTRL_Read_ISRGB24;
	uint GPU_CTRL_Read_VIDEO;


	
	// so the max viewable width for PAL is 3232/4-544/4 = 808-136 = 672
	// so the max viewable height for PAL is 292-34 = 258
	
	// actually, will initially start with a 1 pixel border based on screen width/height and then will shift if something is off screen

	
	// there the frame buffer pixel, and then there's the screen buffer pixel
	uint Pixel16, Pixel32_0, Pixel32_1;
	uint pix0, pix1, pix2;
	
	
	
	//private Pixel_24bit_Format Pixel24;
	
	
	int FramePixel_X, FramePixel_Y;
	
	
	
	//global u16* private ptr_vram16;
	int iptr_vram16;
	//global u32* private ptr_pixelbuffer32;
	int iptr_pixelbuffer32;
	
	int current_x, current_y;
	int current_x2;

	int idx, count;
	ivec4 x4, y4;
	ivec4 idx4;
	ivec4 ivPtr4;
	
	int iSrcShift, iDstShift, iSrcOffset, iDstOffset;
	int screen_width, screen_height;
	int screen_offset;
	uvec4 uvPixel16;
	uvec4 uvPixel16_0, uvPixel16_1, uvPixel16_2;
	uvec4 uvPixel32_0, uvPixel32_1;
	ivec4 sx4, sy4;
	
	
	
	//if ( xxid == 0 )
	{
		uIndex <<= 4;

		
		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		DisplayRange_X1 = int( inputdata [ uIndex + 1 ] ) & 0xfff;
		DisplayRange_X2 = int( inputdata [ uIndex + 1 ] >> 12 ) & 0xfff;
		DisplayRange_Y1 = int( inputdata [ uIndex + 2 ] ) & 0x3ff;
		DisplayRange_Y2 = int( inputdata [ uIndex + 2 ] >> 10 ) & 0x7ff;
		ScreenArea_TopLeftX = int( inputdata [ uIndex + 3 ] ) & 0x3ff;
		ScreenArea_TopLeftY = int( inputdata [ uIndex + 3 ] >> 10 ) & 0x1ff;
		bEnableScanline = int( inputdata [ uIndex + 4 ] );
		Y_Pixel = int( inputdata [ uIndex + 5 ] );


		// ***TODO*** scanline simulation isn't ready yet, so need to fix this - disabled for now
		bEnableScanline = 0;

		
		// bits 16-18
		GPU_CTRL_Read_WIDTH = ( GPU_CTRL_Read >> 16 ) & 7;
		
		// bit 19
		GPU_CTRL_Read_HEIGHT = ( GPU_CTRL_Read >> 19 ) & 1;
		
		// bit 20
		GPU_CTRL_Read_VIDEO = ( GPU_CTRL_Read >> 20 ) & 1;
		
		// bit 21
		GPU_CTRL_Read_ISRGB24 = ( GPU_CTRL_Read >> 21 ) & 1;
		
		// bit 22
		GPU_CTRL_Read_ISINTER = ( GPU_CTRL_Read >> 22 ) & 1;
		
		// bit 23
		GPU_CTRL_Read_DEN = ( GPU_CTRL_Read >> 23 ) & 1;
		
		
		// GPU cycles per pixel depends on width
		GPU_CyclesPerPixel = c_iGPUCyclesPerPixel [ GPU_CTRL_Read_WIDTH ];

		// get the pixel to start and stop drawing at
		Draw_StartX = DisplayRange_X1 / GPU_CyclesPerPixel;
		Draw_EndX = DisplayRange_X2 / GPU_CyclesPerPixel;
		Draw_StartY = DisplayRange_Y1;
		Draw_EndY = DisplayRange_Y2;

		Draw_Width = Draw_EndX - Draw_StartX;
		Draw_Height = Draw_EndY - Draw_StartY;
		// get the pixel to start and stop at for visible area
		VisibleArea_StartX = c_iVisibleArea_StartX_Cycle / GPU_CyclesPerPixel;
		VisibleArea_EndX = c_iVisibleArea_EndX_Cycle / GPU_CyclesPerPixel;

		// visible area start and end y depends on pal/ntsc
		VisibleArea_StartY = c_iVisibleArea_StartY [ GPU_CTRL_Read_VIDEO ];
		VisibleArea_EndY = c_iVisibleArea_EndY [ GPU_CTRL_Read_VIDEO ];

		VisibleArea_Width = VisibleArea_EndX - VisibleArea_StartX;
		VisibleArea_Height = VisibleArea_EndY - VisibleArea_StartY;


		Source_Height = Draw_Height;
		

		
		if ( ( GPU_CTRL_Read_ISINTER != 0 ) && ( GPU_CTRL_Read_HEIGHT != 0 ) )
		{
			// 480i mode //
			
			// if not simulating scanlines, then the draw height should double too
			if ( bEnableScanline == 0 )
			{
				VisibleArea_EndY += Draw_Height;
				VisibleArea_Height += Draw_Height;
				
				Draw_EndY += Draw_Height;
				
				Draw_Height <<= 1;
			}
			
			Source_Height <<= 1;
		}
		

		
		
		if ( GPU_CTRL_Read_DEN == 0 )
		{
			BottomBorder_Height = VisibleArea_EndY - Draw_EndY;
			LeftBorder_Width = Draw_StartX - VisibleArea_StartX;
			TopBorder_Height = Draw_StartY - VisibleArea_StartY;
			RightBorder_Width = VisibleArea_EndX - Draw_EndX;
			
			if ( BottomBorder_Height < 0 ) BottomBorder_Height = 0;
			if ( LeftBorder_Width < 0 ) LeftBorder_Width = 0;
			
			
			
			current_ymax = Draw_Height + BottomBorder_Height;
			current_xmax = Draw_Width + LeftBorder_Width;
			
			// make suree that ymax and xmax are not greater than the size of visible area
			if ( current_xmax > VisibleArea_Width )
			{
				// entire image is not on the screen, so take from left border and recalc xmax //

				LeftBorder_Width -= ( current_xmax - VisibleArea_Width );
				if ( LeftBorder_Width < 0 ) LeftBorder_Width = 0;
				current_xmax = Draw_Width + LeftBorder_Width;
				
				// make sure again we do not draw past the edge of screen
				if ( current_xmax > VisibleArea_Width ) current_xmax = VisibleArea_Width;
			}
			
			if ( current_ymax > VisibleArea_Height )
			{
				BottomBorder_Height -= ( current_ymax - VisibleArea_Height );
				if ( BottomBorder_Height < 0 ) BottomBorder_Height = 0;
				current_ymax = Draw_Height + BottomBorder_Height;
				
				// make sure again we do not draw past the edge of screen
				if ( current_ymax > VisibleArea_Height ) current_ymax = VisibleArea_Height;
			}
			
		}	// end if ( !GPU_CTRL_Read_DEN )
		
		
		
	}	// end if ( !local_id )

	
	// synchronize variables across workers
	//barrier ( CLK_LOCAL_MEM_FENCE );
	//barrier ();
	

	// *** DRAW THE SCREEN *** //

	//FramePixel = 0;
	//ptr_pixelbuffer32 = PixelBuffer;
	iptr_pixelbuffer32 = 0;
	

	if ( subgroupAll( GPU_CTRL_Read_DEN == 0 ) )
	{
		// screen is being shown //

		
		// current_y should start at zero for even field and one for odd
		current_y = 0;
		//current_y = group_yoffset + yid;
		
		
		// put in bottom border //
		
		
		// check if scanlines simulation is enabled
		if ( bEnableScanline != 0 )
		{
			// spread out workers on every other line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * ( group_yoffset + yid ) );
			
			// if this is an odd field, then start writing on the next line
			if ( ( Y_Pixel & 1 ) != 0 )
			{
				// odd field //
				
				iptr_pixelbuffer32 += VisibleArea_Width;
			}
		}
		

		count = BottomBorder_Height * VisibleArea_Width;
		//for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
		for ( idx = gxxid << 2; idx < count; idx += gxxinc << 2 )
		{
			idx4 = idx + ivec4( 0, 1, 2, 3 );

			x4 = idx4 % VisibleArea_Width;
			y4 = idx4 / VisibleArea_Width;

			y4 <<= bEnableScanline;

			ivPtr4 = iptr_pixelbuffer32 + x4 + ( y4 * VisibleArea_Width );
			pixelbuffer32 [ ivPtr4.x ] = 0;
			pixelbuffer32 [ ivPtr4.y ] = 0;
			pixelbuffer32 [ ivPtr4.z ] = 0;
			pixelbuffer32 [ ivPtr4.w ] = 0;
		}
		

		current_y = BottomBorder_Height;
		iptr_pixelbuffer32 = BottomBorder_Height * VisibleArea_Width;

		
		// put in screen //
		
		
		//FramePixel_Y = ScreenArea_TopLeftY + Source_Height - 1;
		//FramePixel_X = ScreenArea_TopLeftX;
		FramePixel_Y = ScreenArea_TopLeftY;
		FramePixel_X = ScreenArea_TopLeftX;

		iSrcShift = 0;
		iSrcOffset = 0;
		iDstShift = 0;
		iDstOffset = 0;

		// check if simulating scanlines
		if ( bEnableScanline != 0 )
		{
			// check if 480i
			if ( ( GPU_CTRL_Read_ISINTER != 0 ) && ( GPU_CTRL_Read_HEIGHT != 0 ) )
			{
				// 480i //
				
				// for opencl, spread interlace mode to every other line
				//FramePixel_Y -= ( current_y - BottomBorder_Height );
				
				// check if in odd field or even field
				if ( ( Y_Pixel & 1 ) != 0 )
				{
					// odd field //
					
					// if the height is even, then it is ok
					// if the height is odd, need to compensate
					if ( ( Source_Height & 1 ) == 0 )
					{
						FramePixel_Y--;
					}
				}
				else
				{
					// even field //
					
					// if the height is odd, then it is ok
					// if the height is even, need to compensate
					if ( ( Source_Height & 1 ) != 0 )
					{
						FramePixel_Y--;
					}
				}
				
			} // end if ( GPU_CTRL_Read.ISINTER && GPU_CTRL_Read.HEIGHT )
		}

		//iptr_vram16 = FramePixel_X + ( ( FramePixel_Y & c_lFrameBuffer_Height_Mask ) << 10 );
		
		screen_height = current_ymax - BottomBorder_Height;

		// put in screeen pixels
		if ( subgroupAll( GPU_CTRL_Read_ISRGB24 == 0 ) )
		{
			screen_width = current_xmax - LeftBorder_Width;
			count = screen_width * screen_height;
			//for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
			for ( idx = gxxid << 2; idx < count; idx += gxxinc << 2 )
			{
				idx4 = idx + ivec4( 0, 1, 2, 3 );

				x4 = idx4 % screen_width;
				y4 = idx4 / screen_width;


				// source coords in frame buffer
				sx4 = ( x4 + FramePixel_X ) & c_lFrameBuffer_Width_Mask;
				sy4 = ( ( y4 << iSrcShift ) + iSrcOffset + FramePixel_Y ) & c_lFrameBuffer_Height_Mask;

				// destination coords offset from line pointer
				y4 = ( y4 << iDstShift ) + iDstOffset;

				// flip upside down
				y4 = screen_height - y4;

				ivPtr4 = sx4 + ( sy4 << 10 );
				//Pixel16 = uint( VRAM16 [ iptr_vram16 + current_x - LeftBorder_Width ] );
				uvPixel16.x = uint( VRAM16 [ ivPtr4.x ] );
				uvPixel16.y = uint( VRAM16 [ ivPtr4.y ] );
				uvPixel16.z = uint( VRAM16 [ ivPtr4.z ] );
				uvPixel16.w = uint( VRAM16 [ ivPtr4.w ] );
					
				// the previous pixel conversion is wrong
				uvPixel32_0 = ( ( uvPixel16 & 0x1f ) << 3 ) | ( ( uvPixel16 & 0x3e0 ) << 6 ) | ( ( uvPixel16 & 0x7c00 ) << 9 );

				ivPtr4 = iptr_pixelbuffer32 + ( LeftBorder_Width + x4 ) + ( y4 * VisibleArea_Width );
				//pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = Pixel32_0;
				pixelbuffer32 [ ivPtr4.x ] = uvPixel32_0.x;
				pixelbuffer32 [ ivPtr4.y ] = uvPixel32_0.y;
				pixelbuffer32 [ ivPtr4.z ] = uvPixel32_0.z;
				pixelbuffer32 [ ivPtr4.w ] = uvPixel32_0.w;
			
			
				//current_x += xxinc;
			}

		}
		else
		{
			screen_width = current_xmax - LeftBorder_Width;

			// half the screen width
			screen_width >>= 1;

			count = screen_width * screen_height;
			//for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
			for ( idx = gxxid << 2; idx < count; idx += gxxinc << 2 )
			{
				idx4 = idx + ivec4( 0, 1, 2, 3 );

				x4 = idx4 % screen_width;
				y4 = idx4 / screen_width;

				// source coords in frame buffer
				sx4 = ( x4 + x4 + x4 + FramePixel_X ) & c_lFrameBuffer_Width_Mask;
				sy4 = ( ( y4 << iSrcShift ) + iSrcOffset + FramePixel_Y ) & c_lFrameBuffer_Height_Mask;

				// destination coords offset from line pointer
				y4 = ( y4 << iDstShift ) + iDstOffset;

				// flip upside down
				y4 = screen_height - y4;

				ivPtr4 = sx4 + ( sy4 << 10 );
				//Pixel16 = uint( VRAM16 [ iptr_vram16 + current_x - LeftBorder_Width ] );
				uvPixel16_0.x = uint( VRAM16 [ ivPtr4.x ] );
				uvPixel16_0.y = uint( VRAM16 [ ivPtr4.y ] );
				uvPixel16_0.z = uint( VRAM16 [ ivPtr4.z ] );
				uvPixel16_0.w = uint( VRAM16 [ ivPtr4.w ] );

				ivPtr4 = sx4 + 1 + ( sy4 << 10 );
				uvPixel16_1.x = uint( VRAM16 [ ivPtr4.x ] );
				uvPixel16_1.y = uint( VRAM16 [ ivPtr4.y ] );
				uvPixel16_1.z = uint( VRAM16 [ ivPtr4.z ] );
				uvPixel16_1.w = uint( VRAM16 [ ivPtr4.w ] );

				ivPtr4 = sx4 + 2 + ( sy4 << 10 );
				uvPixel16_2.x = uint( VRAM16 [ ivPtr4.x ] );
				uvPixel16_2.y = uint( VRAM16 [ ivPtr4.y ] );
				uvPixel16_2.z = uint( VRAM16 [ ivPtr4.z ] );
				uvPixel16_2.w = uint( VRAM16 [ ivPtr4.w ] );
				
				// draw first pixel
				//Pixel32_0 = ( ((u32)Pixel24.Red0) ) | ( ((u32)Pixel24.Green0) << 8 ) | ( ((u32)Pixel24.Blue0) << 16 );
				uvPixel32_0 = ( uvPixel16_0 & 0xffff ) | ( ( uvPixel16_1 & 0xff ) << 16 );
					
				// draw second pixel
				//Pixel32_1 = ( ((u32)Pixel24.Red1) ) | ( ((u32)Pixel24.Green1) << 8 ) | ( ((u32)Pixel24.Blue1) << 16 );
				uvPixel32_1 = ( ( uvPixel16_2 & 0xffff ) << 8 ) | ( ( uvPixel16_1 >> 8 ) & 0xff );

				// for the destination it is x times 2
				ivPtr4 = iptr_pixelbuffer32 + ( LeftBorder_Width + ( x4 << 1 ) ) + ( y4 * VisibleArea_Width );
				//pixelbuffer32 [ iptr_pixelbuffer32 + current_x ] = Pixel32_0;
				pixelbuffer32 [ ivPtr4.x ] = uvPixel32_0.x;
				pixelbuffer32 [ ivPtr4.y ] = uvPixel32_0.y;
				pixelbuffer32 [ ivPtr4.z ] = uvPixel32_0.z;
				pixelbuffer32 [ ivPtr4.w ] = uvPixel32_0.w;

				ivPtr4 = iptr_pixelbuffer32 + ( LeftBorder_Width + ( x4 << 1 ) ) + 1 + ( y4 * VisibleArea_Width );
				pixelbuffer32 [ ivPtr4.x ] = uvPixel32_1.x;
				pixelbuffer32 [ ivPtr4.y ] = uvPixel32_1.y;
				pixelbuffer32 [ ivPtr4.z ] = uvPixel32_1.z;
				pixelbuffer32 [ ivPtr4.w ] = uvPixel32_1.w;
			
				//current_x += xxinc;
			}

			// shift screen width back
			screen_width <<= 1;

		}

		// put in the left border pixels //

		// set screen offset to zero right border - do this first
		screen_offset = LeftBorder_Width + screen_width;

		screen_width = LeftBorder_Width;

		count = screen_width * screen_height;

		//iptr_pixelbuffer32 = current_ymax * VisibleArea_Width;
		count = ( VisibleArea_Height - current_ymax ) * VisibleArea_Width;
		//for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
		for ( idx = gxxid << 2; idx < count; idx += gxxinc << 2 )
		{
			idx4 = idx + ivec4( 0, 1, 2, 3 );

			x4 = idx4 % screen_width;
			y4 = idx4 / screen_width;

			//y4 <<= bEnableScanline;

			ivPtr4 = iptr_pixelbuffer32 + x4 + ( y4 * VisibleArea_Width );
			pixelbuffer32 [ ivPtr4.x ] = 0;
			pixelbuffer32 [ ivPtr4.y ] = 0;
			pixelbuffer32 [ ivPtr4.z ] = 0;
			pixelbuffer32 [ ivPtr4.w ] = 0;
		}

		// put in the right border pixels //

		screen_width = VisibleArea_Width - current_xmax;

		count = screen_width * screen_height;

		//for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
		for ( idx = gxxid << 2; idx < count; idx += gxxinc << 2 )
		{
			idx4 = idx + ivec4( 0, 1, 2, 3 );

			x4 = idx4 % screen_width;
			y4 = idx4 / screen_width;

			//y4 <<= bEnableScanline;

			ivPtr4 = iptr_pixelbuffer32 + x4 + screen_offset + ( y4 * VisibleArea_Width );
			pixelbuffer32 [ ivPtr4.x ] = 0;
			pixelbuffer32 [ ivPtr4.y ] = 0;
			pixelbuffer32 [ ivPtr4.z ] = 0;
			pixelbuffer32 [ ivPtr4.w ] = 0;
		}



	
		

		// put in top border //
		

		iptr_pixelbuffer32 = current_ymax * VisibleArea_Width;
		count = ( VisibleArea_Height - current_ymax ) * VisibleArea_Width;
		//for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
		for ( idx = gxxid << 2; idx < count; idx += gxxinc << 2 )
		{
			idx4 = idx + ivec4( 0, 1, 2, 3 );

			x4 = idx4 % VisibleArea_Width;
			y4 = idx4 / VisibleArea_Width;

			y4 <<= bEnableScanline;

			ivPtr4 = iptr_pixelbuffer32 + x4 + ( y4 * VisibleArea_Width );
			pixelbuffer32 [ ivPtr4.x ] = 0;
			pixelbuffer32 [ ivPtr4.y ] = 0;
			pixelbuffer32 [ ivPtr4.z ] = 0;
			pixelbuffer32 [ ivPtr4.w ] = 0;
		}

		
	}
	else
	{
		// display disabled //
		
		
		current_y = 0;
		//current_y = group_yoffset + yid;
		
		// set initial row for pixel buffer pointer
		//ptr_pixelbuffer32 += ( VisibleArea_Width * current_y );
		
		if ( bEnableScanline != 0 )
		{
			// space out to every other line
			//ptr_pixelbuffer32 += ( VisibleArea_Width * current_y );
			
			if ( ( Y_Pixel & 1 ) != 0 )
			{
				// odd field //
				
				iptr_pixelbuffer32 += VisibleArea_Width;
			}
		}

		count = VisibleArea_Width * VisibleArea_Height;
		//for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
		for ( idx = gxxid << 2; idx < count; idx += gxxinc << 2 )
		{
			idx4 = idx + ivec4( 0, 1, 2, 3 );

			x4 = idx4 % VisibleArea_Width;
			y4 = idx4 / VisibleArea_Width;

			y4 <<= bEnableScanline;

			ivPtr4 = iptr_pixelbuffer32 + x4 + ( y4 * VisibleArea_Width );
			pixelbuffer32 [ ivPtr4.x ] = 0;
			pixelbuffer32 [ ivPtr4.y ] = 0;
			pixelbuffer32 [ ivPtr4.z ] = 0;
			pixelbuffer32 [ ivPtr4.w ] = 0;
		}


		

	}	// end if ( subgroupAll( GPU_CTRL_Read_DEN == 0 ) )



	// check if simulating scanlines
	if ( bEnableScanline != 0 )
	{
		// the visible height is actually times 2 in the buffer for odd and even fields
		VisibleArea_Height <<= 1;
		
		// but, its actually times 2 and then minus one
		VisibleArea_Height--;
	}


#ifdef ENABLE_DRAW_IMAGE

	draw_texture ( VisibleArea_Width, VisibleArea_Height );

#endif


	// write back VisibleArea data
	//inputdata [ 8 ].Value = VisibleArea_Width;
	//inputdata [ 9 ].Value = VisibleArea_Height;

	//}	// end if ( !local_id )


	// this needs to be complete before proceeding
	//barrier ();
}



void vDraw_FrameBufferRectangle_02 (uint iIdx)
{
	//int xxid = int( gl_LocalInvocationIndex );

	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	//int xid = int( gl_GlobalInvocationID.x );
	//int yid = int( gl_GlobalInvocationID.y );
	int yid;

	
	int xoff, yoff;
	

	uint bgr16;
	uint bgr32;

	uint64_t bgr64;

	int w, h, xmax, ymax, ymax2;
	int x, y;

	int xinc2;

	int idx;
	int count;
	int sh;

	uvec4 uvbgr16;
	u64vec4 uvbgr64;

	//uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	//int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	//int DrawArea_OffsetX, DrawArea_OffsetY;
	//uint Command_ABE;

	//uint PixelMask, SetPixelMask;


	// set local variables
	//if ( (xid + yid) == 0 )
	//{
		iIdx <<= 4;

		// set bgr
		//bgr32 = inputdata [ 7 ].Value;
		bgr32 = inputdata [ iIdx + 7 ];
		bgr16 = ( ( bgr32 >> 9 ) & 0x7c00 ) | ( ( bgr32 >> 6 ) & 0x3e0 ) | ( ( bgr32 >> 3 ) & 0x1f );
		bgr16 |= ( bgr16 << 16 );
		
#ifdef USE_LOAD_STORE_VRAM16
		//bgr64 = uint64_t( bgr16 );
		//bgr64 |= ( bgr64 << 32 );
		bgr64 = packUint2x32( uvec2( bgr16 ) );
#endif
		
		//x = inputdata [ 8 ].x;
		//y = inputdata [ 8 ].y;
		x = int( inputdata [ iIdx + 8 ] );
		y = x >> 16;
		

		
		// x and y are actually 11 bits
		// doesn't matter for frame buffer
		//x = ( x << 21 ) >> 21;
		//y = ( y << 21 ) >> 21;
		
		//w = inputdata [ 9 ].w;
		//h = inputdata [ 9 ].h;
		w = int( inputdata [ iIdx + 9 ] );
		h = w >> 16;
		
		// Xpos=(Xpos AND 3F0h)
		x &= 0x3f0;
		
		// ypos & 0x1ff
		y &= 0x1ff;
		
		// Xsiz=((Xsiz AND 3FFh)+0Fh) AND (NOT 0Fh)
		w = ( ( w & 0x3ff ) + 0xf ) & ~0xf;
		
		// Ysiz=((Ysiz AND 1FFh))
		h &= 0x1ff;
	
		// adding xmax, ymax
		xmax = x + w;
		ymax = y + h;
		
		count = w * h;

#ifdef USE_LOAD_STORE_VRAM16
		uvbgr64 = u64vec4( bgr64 );
#else
		// make a color vector to store
		uvbgr16 = uvec4( bgr16 );
#endif

	//}
	


#ifdef SYNC_BEFORE_TRANSFER
	// synchronize local variables across workers
	barrier ();
#endif


	yid = int( ( subgroup_global_id - y ) & subgroup_mask );

	// sh - height for subgroup
	sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );

	// count - count of pixels to draw for the subgroup
	count = w * sh;

	

	if ( subgroupAll( count > 0 ) )
	{

		for ( idx = int( lxid << 4 ); idx < count; idx += int( lxinc << 4 ) )
		{
			xoff = idx % w;
			yoff = ( ( idx / w ) << subgroup_shift ) + yid;

			xoff += x;
			yoff += y;

			VRAM64_4 [ ( ( xoff & c_lFrameBuffer_Width_Mask ) + ( ( yoff & c_lFrameBuffer_Height_Mask ) << 10 ) ) >> 4 ] = uvbgr64;
		}

				
	}	// end if ( subgroupAll( count > 0 ) )


#ifdef SYNC_AFTER_TRANSFER
	// need to complete command before proceeding
	barrier ();
#endif

}






uvec4 vSemiTransparency16 ( uvec4 B, uvec4 F, uint abrCode )
{
	
	const uint ShiftSame = 0;
	const uint ShiftHalf = 1;
	const uint ShiftQuarter = 2;
	
	const uint c_iBitsPerPixel = 5;
	const uvec4 c_iShiftHalf_Mask = uvec4( ~( ( 1 << ( c_iBitsPerPixel - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 2 ) - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 3 ) - 1 ) ) ) );
	const uvec4 c_iShiftQuarter_Mask = uvec4( ~( ( 3 << ( c_iBitsPerPixel - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 2 ) - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 3 ) - 2 ) ) ) );
	const uvec4 c_iClampMask = uvec4( ( 1 << ( c_iBitsPerPixel ) ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) + ( 1 << ( c_iBitsPerPixel * 3 ) ) );
	const uvec4 c_iLoBitMask = uvec4( ( 1 ) + ( 1 << c_iBitsPerPixel ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) );
	const uvec4 c_iPixelMask = uvec4( 0x7fff );
	
	//uint Red, Green, Blue;
	
	uvec4 Color, Actual, Mask;
	
	switch ( abrCode )
	{
		// 0.5xB+0.5 xF
		case 0:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftHalf ) + ( GetRed16( F ) >> ShiftHalf ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftHalf ) + ( GetGreen16( F ) >> ShiftHalf ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftHalf ) + ( GetBlue16( F ) >> ShiftHalf ) ) );
			
			Mask = B & F & c_iLoBitMask;
			Color = ( ( B >> 1 ) & c_iShiftHalf_Mask ) + ( ( F >> 1 ) & c_iShiftHalf_Mask ) + Mask;
			return Color;
			
			break;
		
		// 1.0xB+1.0 xF
		case 1:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
			
		// 1.0xB-1.0 xF
		case 2:
			//Color = SetRed16 ( Clamp5 ( (s32) ( GetRed16 ( B ) >> ShiftSame ) - (s32) ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( (s32) ( GetGreen16 ( B ) >> ShiftSame ) - (s32) ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( (s32) ( GetBlue16 ( B ) >> ShiftSame ) - (s32) ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B - F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual + Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color &= ~Mask;
			return Color;
			
			break;
			
		// 1.0xB+0.25xF
		case 3:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftQuarter ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftQuarter ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftQuarter ) ) );
			
			B &= c_iPixelMask;
			F = ( F >> 2 ) & c_iShiftQuarter_Mask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
	}
	
	return Color;
	
}



uint SemiTransparency16 ( uint B, uint F, uint abrCode )
{
	
	const uint ShiftSame = 0;
	const uint ShiftHalf = 1;
	const uint ShiftQuarter = 2;
	
	const uint c_iBitsPerPixel = 5;
	const uint c_iShiftHalf_Mask = ~( ( 1 << ( c_iBitsPerPixel - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 2 ) - 1 ) ) + ( 1 << ( ( c_iBitsPerPixel * 3 ) - 1 ) ) );
	const uint c_iShiftQuarter_Mask = ~( ( 3 << ( c_iBitsPerPixel - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 2 ) - 2 ) ) + ( 3 << ( ( c_iBitsPerPixel * 3 ) - 2 ) ) );
	const uint c_iClampMask = ( ( 1 << ( c_iBitsPerPixel ) ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) + ( 1 << ( c_iBitsPerPixel * 3 ) ) );
	const uint c_iLoBitMask = ( ( 1 ) + ( 1 << c_iBitsPerPixel ) + ( 1 << ( c_iBitsPerPixel * 2 ) ) );
	const uint c_iPixelMask = 0x7fff;
	
	uint Red, Green, Blue;
	
	uint Color, Actual, Mask;
	
	switch ( abrCode )
	{
		// 0.5xB+0.5 xF
		case 0:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftHalf ) + ( GetRed16( F ) >> ShiftHalf ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftHalf ) + ( GetGreen16( F ) >> ShiftHalf ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftHalf ) + ( GetBlue16( F ) >> ShiftHalf ) ) );
			
			Mask = B & F & c_iLoBitMask;
			Color = ( ( B >> 1 ) & c_iShiftHalf_Mask ) + ( ( F >> 1 ) & c_iShiftHalf_Mask ) + Mask;
			return Color;
			
			break;
		
		// 1.0xB+1.0 xF
		case 1:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
			
		// 1.0xB-1.0 xF
		case 2:
			//Color = SetRed16 ( Clamp5 ( (s32) ( GetRed16 ( B ) >> ShiftSame ) - (s32) ( GetRed16( F ) >> ShiftSame ) ) ) |
			//		SetGreen16 ( Clamp5 ( (s32) ( GetGreen16 ( B ) >> ShiftSame ) - (s32) ( GetGreen16( F ) >> ShiftSame ) ) ) |
			//		SetBlue16 ( Clamp5 ( (s32) ( GetBlue16 ( B ) >> ShiftSame ) - (s32) ( GetBlue16( F ) >> ShiftSame ) ) );
			
			B &= c_iPixelMask;
			F &= c_iPixelMask;
			Actual = B - F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual + Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color &= ~Mask;
			return Color;
			
			break;
			
		// 1.0xB+0.25xF
		case 3:
			//Color = SetRed16 ( Clamp5 ( ( GetRed16 ( B ) >> ShiftSame ) + ( GetRed16( F ) >> ShiftQuarter ) ) ) |
			//		SetGreen16 ( Clamp5 ( ( GetGreen16 ( B ) >> ShiftSame ) + ( GetGreen16( F ) >> ShiftQuarter ) ) ) |
			//		SetBlue16 ( Clamp5 ( ( GetBlue16 ( B ) >> ShiftSame ) + ( GetBlue16( F ) >> ShiftQuarter ) ) );
			
			B &= c_iPixelMask;
			F = ( F >> 2 ) & c_iShiftQuarter_Mask;
			Actual = B + F;
			Mask = ( B ^ F ^ Actual ) & c_iClampMask;
			Color = Actual - Mask;
			Mask -= ( Mask >> c_iBitsPerPixel );
			Color |= Mask;
			return Color;
			
			break;
	}
	
	return Color;
	
}





void vDraw_Line ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;



	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	//s64 r10, r20, r21;
	
	// new variables
	int x0, x1, y0, y1;
	int dx_left, dx_right;
	uint bgr;
	int t0, t1, denominator;

	uint bgr32, bgr16;
	
	int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;
	
	int h, sh;
	int w;
	ivec4 vLine;
	ivec4 vix;
	ivec4 viy;
	ivec4 vxid;
	ivec4 vyid;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	
	const ivec4 vZero = ivec4( 0 );

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	int iEndpointX, iEndpointY;
	uint uIdx;
	int bDraw;

	uIndex <<= 4;

	// setup vars
	//if ( !local_id )
	//{

		uIdx = uIndex << 2;

		bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw != 0 ) )
	{

		PixelMask = data [ uIdx + 1 ];
		SetPixelMask = data [ uIdx + 2 ];
		GPU_CTRL_Read_ABR = data [ uIdx + 3 ];

		Command_ABE = data [ uIdx + 4 ];
		bgr32 = data [ uIdx + 5 ];
		bgr16 = data [ uIdx + 6 ];
		//GPU_CTRL_Read_DTD = data [ uIdx + 7 ];

		DrawArea_TopLeftX = data [ uIdx + 8 ];
		DrawArea_BottomRightX = data [ uIdx + 9 ];
		DrawArea_TopLeftY = data [ uIdx + 10 ];
		DrawArea_BottomRightY = data [ uIdx + 11 ];

		ix = data [ uIdx + 12 ];
		iy = data [ uIdx + 13 ];
		dx = data [ uIdx + 14 ];
		dy = data [ uIdx + 15 ];

		x_distance = data [ uIdx + 16 ];
		y_distance = data [ uIdx + 17 ];
		line_length = data [ uIdx + 18 ];
		//data [ uIdx + 19 ] = ;

		StartX = data [ uIdx + 20 ];
		StartY = data [ uIdx + 21 ];
		EndX = data [ uIdx + 22 ];
		EndY = data [ uIdx + 23 ];

		iBShift = data [ uIdx + 24 ];
		iFShift = data [ uIdx + 25 ];
		iFSign = data [ uIdx + 26 ];
		//data [ uIdx + 27 ] = ;

		//dr = data [ uIdx + 28 ];
		//dg = data [ uIdx + 29 ];
		//db = data [ uIdx + 30 ];
		//data [ uIdx + 31 ] = ;

		//iR = data [ uIdx + 32 ];
		//iG = data [ uIdx + 33 ];
		//iB = data [ uIdx + 34 ];
		//data [ uIdx + 35 ] = ;

		iEndpointX = data [ uIdx + 36 ];
		iEndpointY = data [ uIdx + 37 ];

	yid = int( ( subgroup_global_id - StartY ) & subgroup_mask );

	h = EndY - StartY + 1;

	// sh - height for subgroup
	sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );

#ifdef ENABLE_LINE_SUBGROUP_SKIP

	// if nothing to draw, then done
	//if ( subgroupAll( sh <= 0 ) )
	//{
	//	return;
	//}

#endif


	// check if line is horizontal
	if ( subgroupAll( x_distance > y_distance ) )
	{

		w = EndX - StartX;


		// draw the line horizontally
		for ( ix = int( lxid ) << 2; ix <= w; ix += int( lxinc ) << 2 )
		{
			//Line = iy + (( ix - StartX ) * dy);
			//Line >>= 16;
			vix = ix + ivec4( 0, 1, 2, 3 );

			vLine = iy + (vix * dy);
			vLine >>= 16;
			

#ifdef ENABLE_RANGE_DRAW

			bvEnable = bvec4( ivec4(greaterThanEqual( vLine, ivec4( ivDrawRange[subgroup_local_id].x ) )) & ivec4(lessThan( vLine, ivec4( ivDrawRange[subgroup_local_id].y ) )) & ivec4(lessThanEqual( uvec4( vix ), uvec4( w ) )) & ivec4(notEqual(vix+StartX,ivec4(iEndpointX))) );
#else
			vyid = ivec4( ( subgroup_global_id - vLine ) & subgroup_mask );

			//bvEnable = bvec4(ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )));
			bvEnable = bvec4( ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )) & ivec4(lessThanEqual( uvec4( vix ), uvec4( w ) )) & ivec4(notEqual(vix+StartX,ivec4(iEndpointX))) );

#endif

			//if ( yid == 0 )
			if ( any( bvEnable ) )
			{

				// read pixel from frame buffer if we need to check mask bit
				//iPtr = ix + ( Line << 10 );
				//DestPixel = VRAM [ iPtr ];

				ivPtr = ( (vix + StartX) & c_lFrameBuffer_Width_Mask ) + ( ( vLine & c_lFrameBuffer_Height_Mask ) << 10 );


				if( bvEnable.x ) uvDestPixel [ 0 ] = uint( VRAM16 [ ivPtr [ 0 ] ] );
				if( bvEnable.y ) uvDestPixel [ 1 ] = uint( VRAM16 [ ivPtr [ 1 ] ] );
				if( bvEnable.z ) uvDestPixel [ 2 ] = uint( VRAM16 [ ivPtr [ 2 ] ] );
				if( bvEnable.w ) uvDestPixel [ 3 ] = uint( VRAM16 [ ivPtr [ 3 ] ] );

				
				//bgr_temp = bgr16;
	
				// semi-transparency
				//if ( Command_ABE != 0 )
				//{
				//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				//}
				
				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 31 );
				ivGreenB = clamp( ivGreenB, 0, 31 );
				ivBlueB = clamp( ivBlueB, 0, 31 );

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );

				// check if we should set mask bit when drawing
				uvbgr_temp |= SetPixelMask;


				// draw pixel if we can draw to mask pixels or mask bit not set
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				//uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );

				bvEnable = bvec4( ivec4( bvEnable ) & ivec4( equal( ( uvDestPixel & PixelMask ), vZero ) ) );

				//VRAM16 [ ivPtr [ 0 ] ] = uint16_t( uvDestPixel [ 0 ] );
				//VRAM16 [ ivPtr [ 1 ] ] = uint16_t( uvDestPixel [ 1 ] );
				//VRAM16 [ ivPtr [ 2 ] ] = uint16_t( uvDestPixel [ 2 ] );
				//VRAM16 [ ivPtr [ 3 ] ] = uint16_t( uvDestPixel [ 3 ] );
				if( bvEnable.x ) VRAM16 [ ivPtr.x ] = uint16_t( uvbgr_temp.x );
				if( bvEnable.y ) VRAM16 [ ivPtr.y ] = uint16_t( uvbgr_temp.y );
				if( bvEnable.z ) VRAM16 [ ivPtr.z ] = uint16_t( uvbgr_temp.z );
				if( bvEnable.w ) VRAM16 [ ivPtr.w ] = uint16_t( uvbgr_temp.w );


			}	// end if ( yid == 0 )
			

		}	// end for ( ix = StartX; ix != EndX; ix += incdec )
		
	}
	else
	{
		// line is vertical //


		w = EndY - StartY;

		// draw the line vertically
		for ( iy = int( lxid ) << 2; iy <= w; iy += int( lxinc ) << 2 )
		{
			//Line = ix + (( iy - StartY ) * dx);
			//Line >>= 16;
			viy = iy + ivec4( 0, 1, 2, 3 );


			vLine = ix + (viy * dx);
			vLine >>= 16;
			
#ifdef ENABLE_RANGE_DRAW

			bvEnable = bvec4( ivec4( greaterThanEqual( viy+StartY, ivec4( ivDrawRange[subgroup_local_id].x ) ) ) & ivec4( lessThan( viy+StartY, ivec4( ivDrawRange[subgroup_local_id].y ) ) ) & ivec4( greaterThanEqual( vLine, ivec4( DrawArea_TopLeftX ) ) ) & ivec4( lessThanEqual( vLine, ivec4( DrawArea_BottomRightX ) ) ) & ivec4( lessThanEqual( uvec4( viy ), uvec4( w ) ) ) & ivec4( notEqual( viy + StartY, ivec4( iEndpointY ) ) ) );
#else

			//vyid = ( vyid << subgroup_shift ) + yid;
			vyid = ivec4( ( subgroup_global_id - ( viy + StartY ) ) & subgroup_mask );

			bvEnable = bvec4( ivec4( equal( vyid, vZero ) ) & ivec4( greaterThanEqual( vLine, ivec4( DrawArea_TopLeftX ) ) ) & ivec4( lessThanEqual( vLine, ivec4( DrawArea_BottomRightX ) ) ) & ivec4( lessThanEqual( uvec4( viy ), uvec4( w ) ) ) & ivec4( notEqual( viy + StartY, ivec4( iEndpointY ) ) ) );
#endif


			if ( any( bvEnable ) )
			{

				// read pixel from frame buffer if we need to check mask bit
				// need to use the mask in case the pixel is actually off screen
				ivPtr = ( vLine & c_lFrameBuffer_Width_Mask ) + ( ( ( viy + StartY ) & c_lFrameBuffer_Height_Mask ) << 10 );

				if( bvEnable.x ) uvDestPixel.x = uint( VRAM16 [ ivPtr.x ] );
				if( bvEnable.y ) uvDestPixel.y = uint( VRAM16 [ ivPtr.y ] );
				if( bvEnable.z ) uvDestPixel.z = uint( VRAM16 [ ivPtr.z ] );
				if( bvEnable.w ) uvDestPixel.w = uint( VRAM16 [ ivPtr.w ] );

				uvbgr_temp = uvec4( bgr16 );
	
				// semi-transparency
				//if ( Command_ABE != 0 )
				//{
				//	uvbgr_temp = vSemiTransparency16 ( uvDestPixel, uvbgr_temp, GPU_CTRL_Read_ABR );
				//}

				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 31 );
				ivGreenB = clamp( ivGreenB, 0, 31 );
				ivBlueB = clamp( ivBlueB, 0, 31 );

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );


				// check if we should set mask bit when drawing
				uvbgr_temp |= SetPixelMask;

				// make sure dest pixel does not have mask set
				bvEnable = bvec4( ivec4( bvEnable ) & ivec4( equal( uvDestPixel & PixelMask, uvec4( 0 ) ) ) );

				uvbgr_temp |= SetPixelMask;

				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, bvEnable );

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM16 [ iPtr ] = uint16_t( bgr_temp | SetPixelMask );

				// don't need to control drawing pixel by pixel, since if it is offscreen it could be on any line it wants
				//VRAM16 [ ivPtr.x ] = uint16_t( uvbgr_temp.x );
				//VRAM16 [ ivPtr.y ] = uint16_t( uvbgr_temp.y );
				//VRAM16 [ ivPtr.z ] = uint16_t( uvbgr_temp.z );
				//VRAM16 [ ivPtr.w ] = uint16_t( uvbgr_temp.w );
				if( bvEnable.x ) VRAM16 [ ivPtr.x ] = uint16_t( uvbgr_temp.x );
				if( bvEnable.y ) VRAM16 [ ivPtr.y ] = uint16_t( uvbgr_temp.y );
				if( bvEnable.z ) VRAM16 [ ivPtr.z ] = uint16_t( uvbgr_temp.z );
				if( bvEnable.w ) VRAM16 [ ivPtr.w ] = uint16_t( uvbgr_temp.w );


			}	// end if ( xid == 0 )
			
			//ix += dx;

		}	// end for ( iy = StartY; iy != EndY; iy += incdec )

	}	// end if else if ( x_distance > y_distance )


	}	// end if ( subgroupAll( bDraw != 0 ) )

	return;
}






void vDraw_Line_Gradient ( uint uIndex )
{
	//int xxid = int( gl_LocalInvocationIndex );

	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	//int cxid = int( gl_GlobalInvocationID.x );
	//int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	int DrawArea_OffsetX, DrawArea_OffsetY;
	
	int Temp;
	int LeftMostX, RightMostX;
	int TopMostY, BottomMostY;
	
	
	// the y starts and ends at the same place, but the x is different for each line
	int StartY, EndY;
	
	
	
	// new variables
	int x0, x1, y0, y1;
	//int dx_left, dx_right;
	uint bgr;
	//int t0, t1, denominator;
	
	//int Coord0, Coord1, Coord2;
	
	uint PixelMask, SetPixelMask;
	
	int gx [ 3 ], gy [ 3 ], gbgr [ 3 ];
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	
	int x_left, x_right;
	
	
	
	int StartX, EndX;
	int x_across;
	int xoff, yoff;
	int xoff_left, xoff_right;
	uint DestPixel;
	uint bgr_temp;
	int Line;
	//u16 *ptr;
	int iPtr;
	
	int x_distance, y_distance, line_length, incdec;
	int y_left, dy_left, yoff_left;
	
	int ix, iy, dx, dy;


	int h, sh;
	int w;
	ivec4 ivIndex;
	ivec4 ivDitherValue;
	ivec4 vLine;
	ivec4 ivR, ivG, ivB;
	ivec4 vix;
	ivec4 viy;
	ivec4 vxid;
	ivec4 vyid;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;


	const ivec4 vZero = ivec4( 0 );

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;
	

	int iR, iG, iB;
	int r0, r1, r2, g0, g1, g2, b0, b1, b2;
	int Red, Blue, Green;
	int dr, dg, db;
	int DitherValue;
	
	int oR, oG, oB;
	
	int iEndpointX, iEndpointY;
	uint uIdx;
	int bDraw;

	int64_t iDitherValues64;
	i64vec4 ivDitherValues64;

	ivec4 ivDitherValues32;

	const int iDitherValues32_0 = ( ( -4 & 0xf ) << 28 ) + ( ( 0 & 0xf ) << 24 ) + ( ( -3 & 0xf ) << 20 ) + ( ( 1 & 0xf ) << 16 ) +
									( ( 2 & 0xf ) << 12 ) + ( ( -2 & 0xf ) << 8 ) + ( ( 3 & 0xf ) << 4 ) + ( ( -1 & 0xf ) << 0 );

	const int iDitherValues32_1 = ( ( -3 & 0xf ) << 28 ) + ( ( 1 & 0xf ) << 24 ) + ( ( -4 & 0xf ) << 20 ) + ( ( 0 & 0xf ) << 16 ) +
									( ( 3 & 0xf ) << 12 ) + ( ( -1 & 0xf ) << 8 ) + ( ( 2 & 0xf ) << 4 ) + ( ( -2 & 0xf ) << 0 );

	iDitherValues64 = packInt2x32( ivec2( iDitherValues32_0, iDitherValues32_1 ) );
	ivDitherValues64 = i64vec4( iDitherValues64 );



		uIndex <<= 4;


		uIdx = uIndex << 2;

		bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw != 0 ) )
	{
		PixelMask = data [ uIdx + 1 ];
		SetPixelMask = data [ uIdx + 2 ];
		GPU_CTRL_Read_ABR = data [ uIdx + 3 ];

		Command_ABE = data [ uIdx + 4 ];
		//bgr32 = data [ uIdx + 5 ];
		//bgr16 = data [ uIdx + 6 ];
		GPU_CTRL_Read_DTD = data [ uIdx + 7 ];

		DrawArea_TopLeftX = data [ uIdx + 8 ];
		DrawArea_BottomRightX = data [ uIdx + 9 ];
		DrawArea_TopLeftY = data [ uIdx + 10 ];
		DrawArea_BottomRightY = data [ uIdx + 11 ];

		ix = data [ uIdx + 12 ];
		iy = data [ uIdx + 13 ];
		dx = data [ uIdx + 14 ];
		dy = data [ uIdx + 15 ];

		x_distance = data [ uIdx + 16 ];
		y_distance = data [ uIdx + 17 ];
		line_length = data [ uIdx + 18 ];
		//data [ uIdx + 19 ] = ;

		StartX = data [ uIdx + 20 ];
		StartY = data [ uIdx + 21 ];
		EndX = data [ uIdx + 22 ];
		EndY = data [ uIdx + 23 ];

		iBShift = data [ uIdx + 24 ];
		iFShift = data [ uIdx + 25 ];
		iFSign = data [ uIdx + 26 ];
		//data [ uIdx + 27 ] = ;

		// note: index 31 has sync var
		//dr = data [ uIdx + 28 ];
		//dg = data [ uIdx + 29 ];
		//db = data [ uIdx + 30 ];
		//data [ uIdx + 31 ] = ;

		oR = data [ uIdx + 32 ];
		oG = data [ uIdx + 33 ];
		oB = data [ uIdx + 34 ];
		//data [ uIdx + 35 ] = ;

		// get endpoints
		iEndpointX = data [ uIdx + 36 ];
		iEndpointY = data [ uIdx + 37 ];

		dr = data [ uIdx + 40 ];
		dg = data [ uIdx + 41 ];
		db = data [ uIdx + 42 ];
		//data [ uIdx + 43 ] = ;

		// only dither if dithering is enabled
		ivDitherValues64 = ( GPU_CTRL_Read_DTD != 0 ) ? ivDitherValues64 : i64vec4( 0 );


	yid = int( ( subgroup_global_id - StartY ) & subgroup_mask );

	h = EndY - StartY + 1;

	// sh - height for subgroup
	sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );

#ifdef ENABLE_LINE_SUBGROUP_SKIP

	// if nothing to draw, then done
	//if ( subgroupAll( sh <= 0 ) )
	//{
	//	return;
	//}

#endif



	// check if line is horizontal
	if ( x_distance > y_distance )
	{

		w = EndX - StartX;


		// draw the line horizontally
		for ( ix = int( lxid ) << 2; ix <= w; ix += int( lxinc ) << 2 )
		{
			vix = ix + ivec4( 0, 1, 2, 3 );

			//Line = iy + (( ix - StartX ) * dy);
			//Line >>= 16;
			vLine = iy + (vix * dy);
			vLine >>= 16;
			

#ifdef ENABLE_RANGE_DRAW

			bvEnable = bvec4( ivec4(greaterThanEqual( vLine, ivec4( ivDrawRange[subgroup_local_id].x ) )) & ivec4(lessThan( vLine, ivec4( ivDrawRange[subgroup_local_id].y ) )) & ivec4(lessThanEqual( uvec4( vix ), uvec4( w ) )) & ivec4(notEqual(vix+StartX,ivec4(iEndpointX))) );
#else
			vyid = ivec4( ( subgroup_global_id - vLine ) & subgroup_mask );
			bvEnable = bvec4( ivec4(equal( vyid, vZero )) & ivec4(greaterThanEqual( vLine, ivec4(DrawArea_TopLeftY) )) & ivec4(lessThanEqual( vLine, ivec4(DrawArea_BottomRightY) )) & ivec4(lessThanEqual( uvec4( vix ), uvec4( w ) )) & ivec4(notEqual(vix+StartX,ivec4(iEndpointX))) );
#endif

			if ( any( bvEnable ) )
			{

				ivR = oR + ( vix * dr );
				ivG = oG + ( vix * dg );
				ivB = oB + ( vix * db );

				
#ifdef USE_PRIVATE_DITHER

				ivDitherValue = ivec4( ( ivDitherValues64 << ( ( ( vLine & 3 ) << 4 ) + ( ( ( vix + StartX ) & 3 ) << 2 ) ) ) >> 60 );
				ivDitherValue <<= 16;
#else
				ivIndex = ( ( vix + StartX ) & 3 ) + ( ( vLine & 3 ) << 2 );

				ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );
				ivDitherValue[0] = c_iDitherValues16 [ ivIndex[0] ];
				ivDitherValue[1] = c_iDitherValues16 [ ivIndex[1] ];
				ivDitherValue[2] = c_iDitherValues16 [ ivIndex[2] ];
				ivDitherValue[3] = c_iDitherValues16 [ ivIndex[3] ];
#endif

				// perform dither
				ivRedF = ivR + ivDitherValue;
				ivGreenF = ivG + ivDitherValue;
				ivBlueF = ivB + ivDitherValue;
				
				// perform shift
				ivRedF >>= ( 16 + 3 );
				ivGreenF >>= ( 16 + 3 );
				ivBlueF >>= ( 16 + 3 );
				
				ivRedF = clamp ( ivRedF, 0, 31 );
				ivGreenF = clamp ( ivGreenF, 0, 31 );
				ivBlueF = clamp ( ivBlueF, 0, 31 );
				
				// read pixel from frame buffer if we need to check mask bit
				ivPtr = ( (vix + StartX) & c_lFrameBuffer_Width_Mask ) + ( ( vLine & c_lFrameBuffer_Height_Mask ) << 10 );
				
				if( bvEnable.x ) uvDestPixel [ 0 ] = uint( VRAM16 [ ivPtr [ 0 ] ] );
				if( bvEnable.y ) uvDestPixel [ 1 ] = uint( VRAM16 [ ivPtr [ 1 ] ] );
				if( bvEnable.z ) uvDestPixel [ 2 ] = uint( VRAM16 [ ivPtr [ 2 ] ] );
				if( bvEnable.w ) uvDestPixel [ 3 ] = uint( VRAM16 [ ivPtr [ 3 ] ] );

				
				//bgr_temp = bgr;
	
				// semi-transparency
				//if ( Command_ABE != 0 )
				//{
				//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				//}

				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 31 );
				ivGreenB = clamp( ivGreenB, 0, 31 );
				ivBlueB = clamp( ivBlueB, 0, 31 );

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask;

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( bgr_temp | SetPixelMask );
				// check if we should set mask bit when drawing
				uvbgr_temp |= SetPixelMask;


				// draw pixel if we can draw to mask pixels or mask bit not set
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				// testing
				//uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );

				bvEnable = bvec4( ivec4( bvEnable ) & ivec4( equal( ( uvDestPixel & PixelMask ), vZero ) ) );

				//VRAM16 [ ivPtr [ 0 ] ] = uint16_t( uvDestPixel[ 0 ] );
				//VRAM16 [ ivPtr [ 1 ] ] = uint16_t( uvDestPixel[ 1 ] );
				//VRAM16 [ ivPtr [ 2 ] ] = uint16_t( uvDestPixel[ 2 ] );
				//VRAM16 [ ivPtr [ 3 ] ] = uint16_t( uvDestPixel[ 3 ] );
				if( bvEnable.x ) VRAM16 [ ivPtr.x ] = uint16_t( uvbgr_temp.x );
				if( bvEnable.y ) VRAM16 [ ivPtr.y ] = uint16_t( uvbgr_temp.y );
				if( bvEnable.z ) VRAM16 [ ivPtr.z ] = uint16_t( uvbgr_temp.z );
				if( bvEnable.w ) VRAM16 [ ivPtr.w ] = uint16_t( uvbgr_temp.w );


			}	// end if ( any( bvEnable ) )
			
		}	// end for
		
		
	}
	else
	{
		// line is vertical //





		w = EndY - StartY;


		// draw the line vertically
		for ( iy = int( lxid ) << 2; iy <= w; iy += int( lxinc ) << 2 )
		{
			//Line = ix + (( iy - StartY ) * dx);
			//Line >>= 16;
			viy = iy + ivec4( 0, 1, 2, 3 );

			// TODO: problem here if line is cropped from off-screen, because vyid is offset from StartY and not ix
			vLine = ix + (viy * dx);
			vLine >>= 16;
			

#ifdef ENABLE_RANGE_DRAW

			bvEnable = bvec4( ivec4( greaterThanEqual( viy+StartY, ivec4( ivDrawRange[subgroup_local_id].x ) ) ) & ivec4( lessThan( viy+StartY, ivec4( ivDrawRange[subgroup_local_id].y ) ) ) & ivec4( greaterThanEqual( vLine, ivec4( DrawArea_TopLeftX ) ) ) & ivec4( lessThanEqual( vLine, ivec4( DrawArea_BottomRightX ) ) ) & ivec4( lessThanEqual( uvec4( viy ), uvec4( w ) ) ) & ivec4( notEqual( viy + StartY, ivec4( iEndpointY ) ) ) );
#else
			//vyid = ( vyid << subgroup_shift ) + yid;
			vyid = ivec4( ( subgroup_global_id - ( viy + StartY ) ) & subgroup_mask );
			bvEnable = bvec4( ivec4( equal( vyid, vZero ) ) & ivec4( greaterThanEqual( vLine, ivec4( DrawArea_TopLeftX ) ) ) & ivec4( lessThanEqual( vLine, ivec4( DrawArea_BottomRightX ) ) ) & ivec4( lessThanEqual( uvec4( viy ), uvec4( w ) ) ) & ivec4( notEqual( viy + StartY, ivec4( iEndpointY ) ) ) );
#endif


			if ( any( bvEnable ) )
			{

				ivR = oR + ( viy * dr );
				ivG = oG + ( viy * dg );
				ivB = oB + ( viy * db );


				//if ( GPU_CTRL_Read_DTD != 0 )
				{
#ifdef USE_PRIVATE_DITHER

					ivDitherValue = ivec4( ( ivDitherValues64 << ( ( ( ( viy + StartY ) & 3 ) << 4 ) + ( ( vLine & 3 ) << 2 ) ) ) >> 60 );
					ivDitherValue <<= 16;
#else

					//DitherValue = DitherLine [ x_across & 0x3 ];
					//DitherValue = c_iDitherValues16 [ ( vLine & 3 ) + ( ( ( viy + StartY ) & 3 ) << 2 ) ];
					ivIndex = ( vLine & 3 ) + ( ( ( viy + StartY ) & 3 ) << 2 );
					ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );
					ivDitherValue.x = c_iDitherValues16 [ ivIndex.x ];
					ivDitherValue.y = c_iDitherValues16 [ ivIndex.y ];
					ivDitherValue.z = c_iDitherValues16 [ ivIndex.z ];
					ivDitherValue.w = c_iDitherValues16 [ ivIndex.w ];

#endif
					
					// perform dither
					ivRedF = ivR + DitherValue;
					ivGreenF = ivG + DitherValue;
					ivBlueF = ivB + DitherValue;
					
					// perform shift
					ivRedF >>= ( 16 + 3 );
					ivGreenF >>= ( 16 + 3 );
					ivBlueF >>= ( 16 + 3 );
					
					ivRedF = clamp ( ivRedF, 0, 31 );
					ivGreenF = clamp ( ivGreenF, 0, 31 );
					ivBlueF = clamp ( ivBlueF, 0, 31 );
				}
				//else
				//{
				//	ivRedF = ivR >> ( 16 + 3 );
				//	ivGreenF = ivG >> ( 16 + 3 );
				//	ivBlueF = ivB >> ( 16 + 3 );
				//}

				// need to use the mask in case the pixel is actually off screen
				ivPtr = ( vLine & c_lFrameBuffer_Width_Mask ) + ( ( ( viy + StartY ) & c_lFrameBuffer_Height_Mask ) << 10 );

				if( bvEnable.x ) uvDestPixel.x = uint( VRAM16 [ ivPtr.x ] );
				if( bvEnable.y ) uvDestPixel.y = uint( VRAM16 [ ivPtr.y ] );
				if( bvEnable.z ) uvDestPixel.z = uint( VRAM16 [ ivPtr.z ] );
				if( bvEnable.w ) uvDestPixel.w = uint( VRAM16 [ ivPtr.w ] );

				//uvbgr_temp = uvec4( bgr16 );
	
				// semi-transparency
				//if ( Command_ABE != 0 )
				//{
				//	uvbgr_temp = vSemiTransparency16 ( uvDestPixel, uvbgr_temp, GPU_CTRL_Read_ABR );
				//}

				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedB = clamp( ivRedB, 0, 31 );
				ivGreenB = clamp( ivGreenB, 0, 31 );
				ivBlueB = clamp( ivBlueB, 0, 31 );

				uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );


				// check if we should set mask bit when drawing
				uvbgr_temp |= SetPixelMask;

				// make sure dest pixel does not have mask set
				bvEnable = bvec4( ivec4( bvEnable ) & ivec4( equal( uvDestPixel & PixelMask, uvec4( 0 ) ) ) );

				uvbgr_temp |= SetPixelMask;
				//uvbgr_temp = mix( uvDestPixel, uvbgr_temp, bvEnable );

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM16 [ iPtr ] = uint16_t( bgr_temp | SetPixelMask );

				// don't need to control drawing pixel by pixel, since if it is offscreen it could be on any line it wants
				if( bvEnable.x ) VRAM16 [ ivPtr.x ] = uint16_t( uvbgr_temp.x );
				if( bvEnable.y ) VRAM16 [ ivPtr.y ] = uint16_t( uvbgr_temp.y );
				if( bvEnable.z ) VRAM16 [ ivPtr.z ] = uint16_t( uvbgr_temp.z );
				if( bvEnable.w ) VRAM16 [ ivPtr.w ] = uint16_t( uvbgr_temp.w );


			}	// end if ( xid == 0 )
			
		}


	}
	
	}	// end if ( subgroupAll( bDraw != 0 ) )

	return;
}










#ifdef ENABLE_PRIMITIVE_LOOP
uint Draw_Pixel_68 ( uint uIndex )
#else
void Draw_Pixel_68 ( uint uIndex )
#endif
{
	int xxid = int( gl_LocalInvocationIndex );

	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	int cxid = int( gl_GlobalInvocationID.x );
	int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;

	

//inputdata format:
//0: GPU_CTRL_Read
//1: DrawArea_TopLeft
//2: DrawArea_BottomRight
//3: DrawArea_Offset
//4: (TextureWindow)(not used here)
//5: ------------
//6: ------------
//7:GetBGR24 ( Buffer [ 0 ] );
//8:GetXY ( Buffer [ 1 ] );


	
	
	uint DestPixel;

	int iPtr;

uint bgr16;
uint bgr32;

int w, h, xmax, ymax, ymax2;
int x, y;


uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
int DrawArea_OffsetX, DrawArea_OffsetY;
uint Command_ABE;

uint PixelMask, SetPixelMask;

	ivec4 vxid;
	const ivec4 vZero = ivec4(0);

	uint Comm;
	int bDraw;

	uint uIdx;

	uIndex <<= 4;

	//do
	//{


	
	uIdx = uIndex << 2;
	bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw == 1 ) )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );

		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );

		//StartX = data [ uIdx + 8 ];
		//EndX = data [ uIdx + 9 ];
		//StartY = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];

		x = data [ uIdx + 25 ];
		y = data [ uIdx + 26 ];
	
		// align the compute units with pixels
		//xid = ( ( ( cxid << group_xshift ) + group_x ) - x ) & group_xmask;
		yid = ( ( ( cyid << group_yshift ) + group_y ) - y ) & group_ymask;

		//yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

		//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
		xid = ( ( cxid << group_xshift ) + group_x );
		vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
		vxid = ( vxid ) - ( x & group_vxmask );

		//vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );

		if ( any( equal( vxid, vZero ) ) )
		{
			/////////////////////////////////////////
			// Draw the pixel

			//ptr16 = & ( VRAM [ x + ( y << 10 ) ] );
			iPtr = x + ( y << 10 );
			
			// read pixel from frame buffer if we need to check mask bit
			DestPixel = uint( VRAM16 [ iPtr ] );
			
			// semi-transparency
			if ( Command_ABE != 0 )
			{
				bgr16 = SemiTransparency16 ( DestPixel, bgr16, GPU_CTRL_Read_ABR );
			}
			
			// check if we should set mask bit when drawing
			bgr16 |= SetPixelMask;

			// draw pixel if we can draw to mask pixels or mask bit not set
			DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr16 : DestPixel;
			VRAM16 [ iPtr ] = uint16_t( DestPixel );

		}	// end if ( xid + yid == 0 )

	}	// end if ( bDraw == 1 )

	
		//uIndex += 16;
		//Comm = inputdata [ uIndex + 7 ] >> 24;
	//} while ( ( Comm >= 0x68 && Comm <= 0x6b ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );

#ifdef ENABLE_PRIMITIVE_LOOP
	return uIndex;
#else
	return;
#endif
}



#ifdef ENABLE_PRIMITIVE_LOOP
uint vDraw_Rectangle_60 ( uint uIndex )
#else
void vDraw_Rectangle_60 ( uint uIndex )
#endif
{
	//int xxid = int( gl_LocalInvocationIndex );

	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	//int cxid = int( gl_GlobalInvocationID.x );
	//int cyid = int( gl_GlobalInvocationID.y );
	
	//int xid;
	int yid;


	
	//int iPtr;

	
	
	
	uint DestPixel;
	uint bgr_temp;
	int x_across;
	int Line;

	uint bgr16;
	//int x, y;
	int w, h;
	uint GPU_CTRL_Read;

	//int x0;
	//int y0;
	//int x1;
	//int y1;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;

	uvec4 uvEnable;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	uint Comm;
	int bDraw;

	uint uIdx;

	int idx, count;
	int sh;
	int sw;
	int offset_align;
	ivec4 idx4;
	ivec4 ivLine;

		uIndex <<= 4;

	
#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		// should be 64 per element instead of 128
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;

		bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw == 1 ) )
	{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );

		Command_ABE = uint( data [ uIdx + 4 ] );
		//Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		uvbgr16 = uvec4( uint( data [ uIdx + 7 ] ) );

		StartX = data [ uIdx + 8 ];
		StartY = data [ uIdx + 9 ];
		EndX = data [ uIdx + 10 ];
		EndY = data [ uIdx + 11 ];

		iBShift = data [ uIdx + 24 ];
		iFShift = data [ uIdx + 25 ];
		iFSign = data [ uIdx + 26 ];


		ivRedF = ivec4( uvbgr16 >> 0 ) & 0x1f;
		ivGreenF = ivec4( uvbgr16 >> 5 ) & 0x1f;
		ivBlueF = ivec4( uvbgr16 >> 10 ) & 0x1f;

		uvbgr_temp = uvec4( bgr16 );
		uvbgr_temp |= SetPixelMask;



	// align the compute units with pixels
#ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE

	//yid = ( xxid - StartY ) & xxmask;
	//vxid =  ivec4( 0, 1, 2, 3 );
	yid = int( ( subgroup_global_id - StartY ) & subgroup_mask );

#else
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( StartX & group_vxmask );

	vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
#endif



	w = EndX - StartX + 1;

#ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE

	// h - total height
	h = EndY - StartY;

#ifdef ENABLE_RANGE_DRAW

	// adjust starty (here it is doing inclusive of window start)
	yid = max( StartY, ivDrawRange [ subgroup_local_id ].x ) - StartY;
	//StartY = max( StartY, ivDrawRange [ subgroup_local_id ].x );

	// adjust endy (here it is doing exclusive of window end)
	//EndY = min( EndY, ivDrawRange [ subgroup_local_id ].y - 1 );
	EndY = min( EndY, ivDrawRange [ subgroup_local_id ].y );

	// get height for subgroup (adding one for inclusive of EndY)
	//sh = EndY - StartY + 1 - yid;
	sh = EndY - StartY - yid;

#else
	
	// sh - height for subgroup
	sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );
#endif


#ifdef ENABLE_RECTANGLE_SUBGROUP_SKIP

	// if nothing to draw, then done
	if ( subgroupAll( sh < 0 ) )
	{
		return;
	}

#endif

	sw = w - 1;

#ifdef ALIGN_READ_WRITE_RECTANGLE

	// offset needed to align to 4 pixels
	offset_align = StartX & 3;

	// adjust the width after the alignment
	sw += offset_align;

	// adjust the width to make it a multiple of 4 pixels
	sw = ( sw + 3 ) & ~3;

#endif	// end #ifdef ALIGN_READ_WRITE_RECTANGLE

	// count - count of pixels to draw for the subgroup
	count = sw * sh;

#endif	// end #ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE




#ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE
	for ( idx = int( lxid ) << 2; idx < count; idx += int( lxinc ) << 2 )
#else
	for ( Line = StartY + yid; Line <= EndY; Line += group_vyinc )
#endif
	{
#ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE
		idx4 = idx + ivec4( 0, 1, 2, 3 );
		vx_across = idx4 % sw;

#ifdef ENABLE_RANGE_DRAW

		ivLine = ( idx4 / sw ) + yid;
#else

		ivLine = ( ( idx4 / sw ) << subgroup_shift ) + yid;
#endif


#ifdef ALIGN_READ_WRITE_RECTANGLE

		// offset the starting point to align to 4 pixels
		vx_across -= offset_align;

#endif	// end #ifdef ALIGN_READ_WRITE_RECTANGLE

		ivPtr = ( StartX + vx_across ) + ( ( StartY + ivLine ) << 10 );

#else

		//iPtr = ( StartX & ~3 ) + (xid << 2) + ( Line << 10 );
		ivPtr = ( StartX + vxid ) + ( Line << 10 );

		
		// draw horizontal line
		for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
#endif	// end #ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE
		{
			// check what pixels are enabled
#ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE

#ifdef ALIGN_READ_WRITE_RECTANGLE

			// testing the x against the width is needed when things are aligned
			bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

#else

#ifdef ENABLE_USE_MIX
			bvEnable = lessThan( idx4, ivec4( count ) );
#else
			usubBorrow( uvec4( idx4 ), uvec4( count ), uvEnable );
#endif

#endif	// end #ifdef ALIGN_READ_WRITE_RECTANGLE

#else

			bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

#endif	// end #ifdef USE_NEW_SCANLINE_DRAW_RECTANGLE



#ifdef ENABLE_BUFFER_READ

#ifdef ALIGN_READ_WRITE_RECTANGLE

			uvDestPixel = uvec4 ( VRAM16_4 [ ivPtr.x >> 2 ] );

#else

			// read pixel from frame buffer if we need to check mask bit
			//DestPixel = *ptr;
			uvDestPixel = uvec4( VRAM16 [ ivPtr.x ], VRAM16 [ ivPtr.y ], VRAM16 [ ivPtr.z ], VRAM16 [ ivPtr.w ] );

#endif	// end #ifdef ALIGN_READ_WRITE_RECTANGLE

#endif	// end #ifdef ENABLE_BUFFER_READ

			// semi-transparency //

#ifdef USE_MORE_JUMPS
			if ( Command_ABE != 0 )
#endif
			{

			ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
			ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
			ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

			ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
			ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
			ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

			ivRedB = clamp( ivRedB, 0, 31 );
			ivGreenB = clamp( ivGreenB, 0, 31 );
			ivBlueB = clamp( ivBlueB, 0, 31 );

			uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );

			// just set bshift to 16/31 and fsign to if alpha not enabled
			//uvbgr_temp = ( Command_ABE != 0 ) ? uvbgr_temp : uvbgr16;

			
			// check if we should set mask bit when drawing
			//bgr_temp |= SetPixelMask;
			uvbgr_temp |= SetPixelMask;

			}	// end if ( Command_ABE != 0 )

			// draw pixel if we can draw to mask pixels or mask bit not set
			//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
#ifdef ENABLE_USE_MIX
			uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );
#else
			usubBorrow( uvbgr_temp & PixelMask, uvEnable, uvEnable );
#endif

			// only enabled pixels should be active
#ifdef ENABLE_USE_MIX
			uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );
#else
			uvDestPixel = ( uvDestPixel & ( uvEnable - 1 ) ) | ( uvbgr_temp & -uvEnable );
#endif

#ifdef ENABLE_BUFFER_WRITE

#ifdef ALIGN_READ_WRITE_RECTANGLE

			VRAM16_4 [ ivPtr.x >> 2 ] = u16vec4( uvDestPixel );

#else
			
			// store pixels //
			VRAM16 [ ivPtr.x ] = uint16_t( uvDestPixel.x );
			VRAM16 [ ivPtr.y ] = uint16_t( uvDestPixel.y );
			VRAM16 [ ivPtr.z ] = uint16_t( uvDestPixel.z );
			VRAM16 [ ivPtr.w ] = uint16_t( uvDestPixel.w );

#endif	// end #ifdef ALIGN_READ_WRITE_RECTANGLE

#endif	// end #ifdef ENABLE_BUFFER_WRITE

#ifndef USE_NEW_SCANLINE_DRAW_RECTANGLE
			// update pointer for pixel out
			ivPtr += group_vxinc;
#endif
		}
		
	}	// end for ( Line = StartY + group_yoffset + yid; Line <= EndY; Line += yinc )

	}	// end if ( bDraw == 1 )

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x60 && Comm <= 0x63 ) || ( Comm >= 0x70 && Comm <= 0x73 ) || ( Comm >= 0x78 && Comm <= 0x7b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif



#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}






#ifdef ENABLE_PRIMITIVE_LOOP
uint vDraw_Sprite_64 ( uint uIndex )
#else
void vDraw_Sprite_64 ( uint uIndex )
#endif
{
	//int xxid = int( gl_LocalInvocationIndex );

	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	//int cxid = int( gl_GlobalInvocationID.x );
	//int cyid = int( gl_GlobalInvocationID.y );
	
	int xid, yid;


	int iPtr;


	// notes: looks like sprite size is same as specified by w/h

	
	int TexelIndex;
	
	
	
	int Temp;
	
	// new local variables
	uint bgr, bgr_temp;
	int iU, iV;
	int x_across;
	int Line;
	
	uint DestPixel;
	int TexCoordX, TexCoordY;

	
	uint bgr16;
	int x, y, w, h;
	uint GPU_CTRL_Read;
	int DrawArea_TopLeftX;
	int DrawArea_TopLeftY;
	int DrawArea_BottomRightX;
	int DrawArea_BottomRightY;
	int DrawArea_OffsetX;
	int DrawArea_OffsetY;
	int x0;
	int y0;
	int x1;
	int y1;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;

	uint GPU_CTRL_Read_ABR;
	uint Command_ABE;
	uint PixelMask;
	uint SetPixelMask;

	int u;
	int v;
	
	// bits 0-5 in upper halfword
	int clut_x;
	int clut_y;

	int TWY;
	int TWX;
	int TWH;
	int TWW;
		
	int tpage_tx;
	int tpage_ty;
	int tpage_tp;
	int Shift1;
	int Shift2;
	int And1;
	int And2;
	int TWYTWH;
	int TWXTWW;
	int Not_TWH;
	int Not_TWW;
	int TextureOffset;
	int ClutOffset;
	int clut_xoffset;

	int u0, v0;
	uint color_add;
	uint Command_TGE;


	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 vEndX;

	const ivec4 vZero = ivec4( 0 );

	uvec4 uvbgr, uvbgr2;
	uvec4 uvDest;

	ivec4 ivTexCoordX;
	ivec4 ivU;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;

	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivIndex;
	
	uint Comm;
	int bDraw;

	uint uIdx;

	int idx, count;
	int sh;
	int sw;
	int offset_align;
	ivec4 idx4;
	ivec4 ivLine;
	ivec4 ivTexCoordY;
	ivec4 ivV;

	uvec4 uvEnable;

	uvec4 uLoad4;

	bool bLoadDest;

	// set local variables
	//if ( xxid == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		// should be 64 per element instead of 128
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;

		bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw == 1 ) )
	{
#ifdef QUICK_LOAD_SPRITE
		if ( lxid < 12 )
		{
			uLoad4 = data32_4 [ uIndex + lxid ];
		}

		PixelMask = subgroupBroadcast( uLoad4[1], 0 );
		SetPixelMask = subgroupBroadcast( uLoad4[2], 0 );
		GPU_CTRL_Read_ABR = subgroupBroadcast( uLoad4[3], 0 );
		Command_ABE = subgroupBroadcast( uLoad4[0], 1 );
		Command_TGE = subgroupBroadcast( uLoad4[1], 1 );
		color_add = subgroupBroadcast( uLoad4[2], 1 );

		StartX = int( subgroupBroadcast( uLoad4[1], 2 ) );
		EndX = int( subgroupBroadcast( uLoad4[2], 2 ) );

		Shift1 = int( subgroupBroadcast( uLoad4[0], 3 ) );
		Shift2 = int( subgroupBroadcast( uLoad4[1], 3 ) );
		And1 = int( subgroupBroadcast( uLoad4[2], 3 ) );
		And2 = int( subgroupBroadcast( uLoad4[3], 3 ) );

		TWYTWH = int( subgroupBroadcast( uLoad4[0], 4 ) );
		TWXTWW = int( subgroupBroadcast( uLoad4[1], 4 ) );
		Not_TWH = int( subgroupBroadcast( uLoad4[2], 4 ) );
		Not_TWW = int( subgroupBroadcast( uLoad4[3], 4 ) );
		TextureOffset = int( subgroupBroadcast( uLoad4[0], 5 ) );
		ClutOffset = int( subgroupBroadcast( uLoad4[1], 5 ) );
		clut_xoffset = int( subgroupBroadcast( uLoad4[2], 5 ) );

		StartY = int( subgroupBroadcast( uLoad4[2], 7 ) );
		EndY = int( subgroupBroadcast( uLoad4[3], 7 ) );

		u0 = int( subgroupBroadcast( uLoad4[2], 10 ) );
		v0 = int( subgroupBroadcast( uLoad4[3], 10 ) );

		u0 >>= 16;
		v0 >>= 16;

#else
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );

		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		color_add = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );

		StartX = data [ uIdx + 8 ];
		StartY = data [ uIdx + 9 ];
		EndX = data [ uIdx + 10 ];
		EndY = data [ uIdx + 11 ];

		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];

		//u0 = data [ uIdx + 16 ];
		//v0 = data [ uIdx + 17 ];

		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];

		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];

		iBShift = data [ uIdx + 24 ];
		iFShift = data [ uIdx + 25 ];
		iFSign = data [ uIdx + 26 ];

		//u0 = data [ uIdx + 42 ] >> 16;
		//v0 = data [ uIdx + 43 ] >> 16;
		u0 = data [ uIdx + 28 ];
		v0 = data [ uIdx + 29 ];
#endif
	

	if ( subgroupAll( Command_TGE != 0 ) )
	{
		color_add = 0x00808080;
	}





	// setup color_add value
	//ivRedC = ivec4( uvcolor_add >> 16 ) & 0xff;
	//ivGreenC = ivec4( uvcolor_add >> 8 ) & 0xff;
	//ivBlueC = ivec4( uvcolor_add >> 0 ) & 0xff;
	ivRedC = ivec4( ( int( color_add ) >> 0 ) & 0xff );
	ivGreenC = ivec4( ( int( color_add ) >> 8 ) & 0xff );
	ivBlueC = ivec4( ( int( color_add ) >> 16 ) & 0xff );

	//ivRedF = ivec4( uvbgr16 >> 10 ) & 0x1f;
	//ivGreenF = ivec4( uvbgr16 >> 5 ) & 0x1f;
	//ivBlueF = ivec4( uvbgr16 >> 0 ) & 0x1f;



#ifdef USE_LOCAL_CLUT
	// load palette if there is one
	if ( subgroupAll( Shift1 != 0 ) )
	{
		// get palette offset
		// ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask )

		count = And2 + 1;
		//for ( idx = int( lxid ); idx < int( count ); idx += int( lxinc ) )
		for ( idx = int( lxid ) << 2; idx < int( count ); idx += int( lxinc ) << 2 )
		{
			//ulocal_data32 [ ( subgroup_id << 8 ) + idx ] = uint( VRAM16 [ ClutOffset + ( ( clut_xoffset + idx ) & c_lFrameBuffer_Width_Mask ) ] );

			ivPtr = ivec4( ( subgroup_local_id << 8 ) + idx + ivec4( 0, 1, 2, 3 ) );
			uvbgr = uvec4( VRAM16_4 [ ( ClutOffset + ( ( clut_xoffset + idx ) & c_lFrameBuffer_Width_Mask ) ) >> 2 ] );
			ulocal_data32 [ ivPtr.x ] = uvbgr.x;
			ulocal_data32 [ ivPtr.y ] = uvbgr.y;
			ulocal_data32 [ ivPtr.z ] = uvbgr.z;
			ulocal_data32 [ ivPtr.w ] = uvbgr.w;

		}
	}
#endif




#ifdef USE_NEW_SCANLINE_DRAW_SPRITE

	//yid = ( xxid - StartY ) & xxmask;
	//vxid =  ivec4( 0, 1, 2, 3 );
	yid = int( ( subgroup_global_id - StartY ) & subgroup_mask );

#else
	yid = ( ( ( cyid << group_yshift ) + group_y ) - StartY ) & group_ymask;

	//xid = ( ( ( cxid << group_xshift ) + group_x ) - StartX ) & group_xmask;
	xid = ( ( cxid << group_xshift ) + group_x );
	vxid =  ivec4( 0, 1, 2, 3 ) + ( ( xid ) << 2 );
	vxid = ( vxid ) - ( StartX & group_vxmask );

	vxid = any( greaterThanEqual( vxid, vZero ) ) ? vxid : ( vxid + group_vxinc );
#endif


	//iV = v0;
	iV = v0 + yid;


	w = EndX - StartX + 1;


#ifdef USE_NEW_SCANLINE_DRAW_SPRITE

	// h - total height
	h = EndY - StartY;

#ifdef ENABLE_RANGE_DRAW

	// adjust starty (here it is doing inclusive of window start)
	yid = max( StartY, ivDrawRange [ subgroup_local_id ].x ) - StartY;
	//StartY = max( StartY, ivDrawRange [ subgroup_local_id ].x );

	// adjust endy (here it is doing exclusive of window end)
	//EndY = min( EndY, ivDrawRange [ subgroup_local_id ].y - 1 );
	EndY = min( EndY, ivDrawRange [ subgroup_local_id ].y );

	// get height for subgroup (adding one for inclusive of EndY)
	//sh = EndY - StartY + 1 - yid;
	sh = EndY - StartY - yid;

#else

	
	// sh - height for subgroup
	sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );

#endif

#ifdef ENABLE_SPRITE_SUBGROUP_SKIP

	// if nothing to draw, then done
	if ( subgroupAll( sh < 0 ) )
	{
		return;
	}

#endif

	sw = w - 1;

#ifdef ALIGN_READ_WRITE_SPRITE

	// offset needed to align to 4 pixels
	offset_align = StartX & 3;

	// adjust the width after the alignment
	sw += offset_align;

	// adjust the width to make it a multiple of 4 pixels
	sw = ( sw + 3 ) & ~3;

#endif	// end #ifdef ALIGN_READ_WRITE_SPRITE

	// count - count of pixels to draw for the subgroup
	count = sw * sh;

#endif	// end #ifdef USE_NEW_SCANLINE_DRAW_SPRITE


#ifdef USE_SELECTIVE_READ

	bLoadDest = ( ( Command_ABE != 0 ) || ( PixelMask != 0 ) );

#endif


#ifdef USE_NEW_SCANLINE_DRAW_SPRITE
	for ( idx = int( lxid ) << 2; idx < count; idx += int( lxinc ) << 2 )
#else
	for ( Line = StartY + yid; Line <= EndY; Line += group_vyinc )
#endif
	{
#ifdef USE_NEW_SCANLINE_DRAW_SPRITE
		idx4 = idx + ivec4( 0, 1, 2, 3 );
		vx_across = idx4 % sw;

#ifdef ENABLE_RANGE_DRAW

		ivLine = ( idx4 / sw ) + yid;
#else

		ivLine = ( ( idx4 / sw ) << subgroup_shift ) + yid;
#endif


#ifdef ALIGN_READ_WRITE_SPRITE

		// offset the starting point to align to 4 pixels
		vx_across -= offset_align;

#endif	// end #ifdef ALIGN_READ_WRITE_SPRITE

		ivU = u0 + vx_across;
		ivV = v0 + ivLine;

		ivTexCoordY = ( ( ivV & Not_TWH ) | ( TWYTWH ) ) & 0xff;
		ivTexCoordY <<= 10;

		ivPtr = ( StartX + vx_across ) + ( ( StartY + ivLine ) << 10 );
#else
		
		// need to start texture coord from left again
		//iU = u0;
		//iU = u0 + xid;
		ivU = u0 + vxid;

		TexCoordY = ( ( iV & Not_TWH ) | ( TWYTWH ) ) & 0xff;
		TexCoordY <<= 10;

		//ptr = & ( VRAM [ StartX + xid + ( Line << 10 ) ] );
		//iPtr = StartX + xid + ( Line << 10 );
		ivPtr = ( StartX + vxid ) + ( Line << 10 );


		// draw horizontal line
		for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )
#endif
		{
#ifdef USE_NEW_SCANLINE_DRAW_SPRITE

#ifdef ALIGN_READ_WRITE_SPRITE

			// testing the x against the width is needed when things are aligned
			bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

#else

#ifdef ENABLE_USE_MIX
			bvEnable = lessThan( idx4, ivec4( count ) );
#else
			usubBorrow( uvec4( idx4 ), uvec4( count ), uvEnable );
#endif

#endif	// end #ifdef ALIGN_READ_WRITE_SPRITE

#else
			// check what pixels are enabled
			bvEnable = lessThan( uvec4( vx_across ), uvec4( w ) );

#endif	// end #ifdef USE_NEW_SCANLINE_DRAW_SPRITE


			//TexCoordX = ( ( iU & Not_TWW ) | ( TWXTWW ) ) & 0xff;
			ivTexCoordX = ( ( ivU & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
			// x-component should be shifted right 1 again since 2 pixels per?
			//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
#ifdef USE_NEW_SCANLINE_DRAW_SPRITE
			ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + ivTexCoordY;
#else
			ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + TexCoordY;
#endif

#ifdef ENABLE_BUFFER_READ

			// read sprite pixel source data //
			uvbgr.x = uint( VRAM16 [ ivIndex.x ] );
			uvbgr.y = uint( VRAM16 [ ivIndex.y ] );
			uvbgr.z = uint( VRAM16 [ ivIndex.z ] );
			uvbgr.w = uint( VRAM16 [ ivIndex.w ] );

#endif	// end #ifdef ENABLE_BUFFER_READ
				
				
			//if ( Shift1 != 0 )
			//{
			//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( int( bgr ) >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
			//}
#ifdef USE_MORE_JUMPS
			if ( subgroupAll( Shift1 != 0 ) )
#endif
			{

#ifdef USE_LOCAL_CLUT
				ivIndex = ivec4( ( subgroup_local_id << 8 ) + ( ( ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) ) );
				uvbgr2.x = ulocal_data32 [ ivIndex.x ];
				uvbgr2.y = ulocal_data32 [ ivIndex.y ];
				uvbgr2.z = ulocal_data32 [ ivIndex.z ];
				uvbgr2.w = ulocal_data32 [ ivIndex.w ];

#else

				ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );

#ifdef ENABLE_BUFFER_READ

				uvbgr2.x = uint( VRAM16 [ ivIndex.x ] );
				uvbgr2.y = uint( VRAM16 [ ivIndex.y ] );
				uvbgr2.z = uint( VRAM16 [ ivIndex.z ] );
				uvbgr2.w = uint( VRAM16 [ ivIndex.w ] );
#endif

#endif	// end USE_LOCAL_CLUT

				uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;
			}
				
			//if ( bgr != 0 )
			//{
				// read pixel from frame buffer if we need to check mask bit
				//DestPixel = *ptr;
				//DestPixel = VRAM [ iPtr ];
				//uvDestPixel = uvec4( VRAM [ ivPtr [ 0 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 3 ] ] );
				//uvDestPixel = uvec4( VRAM [ ivPtr [ 3 ] ], VRAM [ ivPtr [ 2 ] ], VRAM [ ivPtr [ 1 ] ], VRAM [ ivPtr [ 0 ] ] );
#ifdef USE_SELECTIVE_READ
				if( subgroupAll( bLoadDest ) )
				{
				uvDestPixel.x = uint( VRAM16 [ ivPtr.x ] );
				uvDestPixel.y = uint( VRAM16 [ ivPtr.y ] );
				uvDestPixel.z = uint( VRAM16 [ ivPtr.z ] );
				uvDestPixel.w = uint( VRAM16 [ ivPtr.w ] );
				}
#else

#ifdef ALIGN_READ_WRITE_SPRITE

				uvDestPixel = uvec4( VRAM16_4 [ ivPtr.x >> 2 ] );

#else

				uvDestPixel.x = uint( VRAM16 [ ivPtr.x ] );
				uvDestPixel.y = uint( VRAM16 [ ivPtr.y ] );
				uvDestPixel.z = uint( VRAM16 [ ivPtr.z ] );
				uvDestPixel.w = uint( VRAM16 [ ivPtr.w ] );

#endif	// end #ifdef ALIGN_READ_WRITE_SPRITE

#endif	// end #ifdef USE_SELECTIVE_READ

					
				//bgr_temp = bgr;
					
//#ifdef ENABLE_COLOR_MULTIPLY
				// color multiply //


				//ivRedC = ivec4( uvcolor_add >> 16 ) & 0xff;
				//ivGreenC = ivec4( uvcolor_add >> 8 ) & 0xff;
				//ivBlueC = ivec4( uvcolor_add >> 0 ) & 0xff;

				ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
				ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
				ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;

#ifdef USE_MORE_JUMPS
				if ( subgroupAll( Command_TGE == 0 ) )
#endif
				{
				ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
				ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
				ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );
					
				//uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

				// no need for selection, because can color multiply with 0x80
				//uvbgr_temp = ( Command_TGE == 0 ) ? uvbgr_temp : uvbgr;
				}
//#endif


				// needs a pixel to choose from without transparency
				uvbgr2 = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );


//#ifdef ENABLE_SEMI_TRANSPARENCY
				// semi-transparency //

#ifdef USE_MORE_JUMPS
				if ( subgroupAll( Command_ABE != 0 ) )
#endif
				{
				// semi-transparency
				//if ( Command_ABE != 0 && ( bgr & 0x8000 ) != 0 )
				//{
				//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, GPU_CTRL_Read_ABR );
				//}
					
				//ivRedF = ivec4( uvbgr_temp >> 0 ) & 0x1f;
				//ivBlueF = ivec4( uvbgr_temp >> 5 ) & 0x1f;
				//ivGreenF = ivec4( uvbgr_temp >> 10 ) & 0x1f;

				ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
				ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
				ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;

				ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
				ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
				ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

				ivRedF = clamp( ivRedB, 0, 0x1f );
				ivGreenF = clamp( ivGreenB, 0, 0x1f );
				ivBlueF = clamp( ivBlueB, 0, 0x1f );
				}

				uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );

				// no need to select based on command_abe since can just set shift to 16 and sign to zero
				//uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
				uvbgr_temp = mix( uvbgr_temp, uvbgr2, equal( uvbgr & 0x8000, vZero ) );

//#endif
					
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
				uvbgr_temp |= SetPixelMask | ( uvbgr & 0x8000 );

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;

#ifdef USE_SELECTIVE_WRITE
				bvEnable = bvec4( ivec4( bvEnable ) & ivec4( notEqual( uvbgr, vZero ) ) & ivec4( equal( uvDestPixel & PixelMask, vZero ) ) );
#else
				// only draw pixel if not key color (zero)
				uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );
					
				// draw pixel if we can draw to mask pixels or mask bit not set
				//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );

#endif


					
				// store pixels //

#ifdef ENABLE_BUFFER_WRITE

#ifdef USE_MORE_JUMPS
				if ( any( bvEnable ) )
#endif
				{
#ifdef USE_SELECTIVE_WRITE
					if( bvEnable.x ) VRAM16 [ ivPtr.x ] = uint16_t( uvbgr_temp.x );
					if( bvEnable.y ) VRAM16 [ ivPtr.y ] = uint16_t( uvbgr_temp.y );
					if( bvEnable.z ) VRAM16 [ ivPtr.z ] = uint16_t( uvbgr_temp.z );
					if( bvEnable.w ) VRAM16 [ ivPtr.w ] = uint16_t( uvbgr_temp.w );
#else

#ifdef ALIGN_READ_WRITE_SPRITE

					VRAM16_4 [ ivPtr.x >> 2 ] = u16vec4( uvDestPixel );

#else
					//VRAM [ iPtr ] = DestPixel;
					VRAM16 [ ivPtr.x ] = uint16_t( uvDestPixel.x );
					VRAM16 [ ivPtr.y ] = uint16_t( uvDestPixel.y );
					VRAM16 [ ivPtr.z ] = uint16_t( uvDestPixel.z );
					VRAM16 [ ivPtr.w ] = uint16_t( uvDestPixel.w );
#endif	// end #ifdef ALIGN_READ_WRITE_SPRITE

#endif	// end #ifdef USE_SELECTIVE_WRITE

				}

#endif

				//}
				
					
#ifndef USE_NEW_SCANLINE_DRAW_SPRITE
			/////////////////////////////////////////////////////////
			// interpolate texture coords across
			//iU += xinc;
			ivU += group_vxinc;
				
			// update pointer for pixel out
			ivPtr += group_vxinc;
#endif
					
		}
		
#ifndef USE_NEW_SCANLINE_DRAW_SPRITE
		iV += group_vyinc;
#endif
		
	}

	}	// end if ( bDraw == 1 )
	
#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x64 && Comm <= 0x67 ) || ( Comm >= 0x74 && Comm <= 0x77 ) || ( Comm >= 0x7c && Comm <= 0x7f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif



#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}






#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Mono ( uint uIndex )
#else
void vDrawTriangle_Mono ( uint uIndex )
#endif
{
	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	
	int xid, yid;

	int idx, count;

	int yid1;
	int yoffset;
	int yoffset1;

	int iPtr;

	int iLoopMax;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	uint bgr16, bgr32;
	int Line;

	int h;
	int sh;
	ivec4 idx4;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;

	ivec4 Coff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;

	ivec4 Toff_left;
	
	
	int xoff_left, xoff_right;
	ivec4 xoff;

	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	
	int TexCoordX, TexCoordY;


	//uint bgr16;
	//uint bgr32;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	uint Command_TGE;

	//uint color_add;
	int clut_xoffset, clut_yoffset;
	int clut_x, clut_y, tpage_tx, tpage_ty;
	uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;
	int StartY1, EndY1;
	int StartY0, EndY0;

	uint PixelMask, SetPixelMask;


	ivec4 x, dx;

	ivec4 x1, dx1;

	ivec4 dR_across, dG_across, dB_across;


	ivec4 iC, dC_across, dCx_across;
	ivec4 C_left, dC_left;
	ivec4 C_left1, dC_left1;

	int Shift1, Shift2, And1, And2;
	int TextureOffset;
	int ClutOffset;

	int bTexture;

	int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	int TWX, TWY, TWW, TWH;

	ivec4 dU_across, dV_across;

	ivec4 iT, dT_across, dTx_across;

	ivec4 T_left, dT_left;
	ivec4 T_left1, dT_left1;

	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	uvec4 uvbgr, uvbgr2;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivTexCoordY;
	ivec4 ivTexCoordX;
	ivec4 ivU;
	ivec4 ivV;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;

	ivec4 ivLine;
	ivec4 vyid;
	int wl;

	int iXInc, iYInc;
	ivec4 ivEnable;

	ivec4 ivBFShiftSign;

	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;




		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
	do
	{
#endif
		

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		// this one needs to be 64 per element instead of 128 per element
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;


		bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw == 1 ) )
	{

		//if ( subgroupElect() )
		{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );

		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		bgr32 = uint( data [ uIdx + 6 ] );
		bgr16 = uint( data [ uIdx + 7 ] );

		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];

		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];

		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];

		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];

		//iLoopMax = data [ uIdx + 62 ];
		//iLoopMax = 32;


		//dC_across.r = data [ uIdx + 24 ];
		//dC_across.g = data [ uIdx + 25 ];
		//dC_across.b = data [ uIdx + 26 ];
		//dC_across = data32_4 [ uIndex + 6 ];

		//bTexture = data [ uIdx + 27 ];
		//bTexture = dC_across.w;

		//dT_across.s = data [ uIdx + 28 ];
		//dT_across.t = data [ uIdx + 29 ];
		dT_across = data32_4 [ uIndex + 7 ];
		iBShift = dT_across.z & 0xff;
		iFShift = ( dT_across.z >> 8 ) & 0xff;
		iFSign = ( dT_across.z >> 16 );


		//x.x = data [ uIdx + 32 + 0 ];
		//x.y = data [ uIdx + 33 + 0 ];
		//dx.x = data [ uIdx + 34 + 0 ];
		//dx.y = data [ uIdx + 35 + 0 ];
		x = data32_4 [ uIndex + 8 ];
		dx.xy = x.zw;

		//C_left.r = data [ uIdx + 36 + 0 ];
		//C_left.g = data [ uIdx + 37 + 0 ];
		//C_left.b = data [ uIdx + 38 + 0 ];
		C_left = data32_4 [ uIndex + 9 ];

		//StartY = data [ uIdx + 39 + 0 ];
		StartY = C_left.w;

		//dC_left.r = data [ uIdx + 40 + 0 ];
		//dC_left.g = data [ uIdx + 41 + 0 ];
		//dC_left.b = data [ uIdx + 42 + 0 ];
		dC_left = data32_4 [ uIndex + 10 ];

		//EndY = data [ uIdx + 43 + 0 ];
		EndY = dC_left.w;

		//T_left.s = data [ uIdx + 44 + 0 ];
		//T_left.t = data [ uIdx + 45 + 0 ];
		//dT_left.s = data [ uIdx + 46 + 0 ];
		//dT_left.t = data [ uIdx + 47 + 0 ];
		//T_left = data32_4 [ uIndex + 11 ];
		//dT_left.st = T_left.pq;


		//x1.x = data [ uIdx + 32 + 16 ];
		//x1.y = data [ uIdx + 33 + 16 ];
		//dx1.x = data [ uIdx + 34 + 16 ];
		//dx1.y = data [ uIdx + 35 + 16 ];
		x1 = data32_4 [ uIndex + 12 ];
		dx1.xy = x1.zw;

		//C_left1.r = data [ uIdx + 36 + 16 ];
		//C_left1.g = data [ uIdx + 37 + 16 ];
		//C_left1.b = data [ uIdx + 38 + 16 ];
		C_left1 = data32_4 [ uIndex + 13 ];

		//StartY1 = data [ uIdx + 39 + 16 ];
		StartY1 = C_left1.w;

		//dC_left1.r = data [ uIdx + 40 + 16 ];
		//dC_left1.g = data [ uIdx + 41 + 16 ];
		//dC_left1.b = data [ uIdx + 42 + 16 ];
		dC_left1 = data32_4 [ uIndex + 14 ];

		//EndY1 = data [ uIdx + 43 + 16 ];
		EndY1 = dC_left1.w;




		}	// end if ( subgroupElect() )


#ifdef ENABLE_RANGE_DRAW

	// adjust starty (here it is doing inclusive of window start)
	yid = max( StartY, ivDrawRange [ subgroup_local_id ].x ) - StartY;
	//StartY = max( StartY, ivDrawRange [ subgroup_local_id ].x );

	// adjust endy (here it is doing exclusive of window end since it is already exclusive of EndY1)
	EndY1 = min( EndY1, ivDrawRange [ subgroup_local_id ].y );

	// get height for subgroup (exclusive of EndY1)
	sh = EndY1 - StartY - yid;

#else

		yid = int( ( subgroup_global_id - StartY ) & subgroup_mask );

		// h - total height
		h = EndY1 - StartY;
	
		// sh - height for subgroup
		sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );

#endif

#ifdef ENABLE_TRIANGLE_SUBGROUP_SKIP

		// if nothing to draw, then done
		if ( subgroupAll( sh < 0 ) )
		{
			return;
		}

#endif


		idx = int( lxid ) << 2;
		idx4 = idx + ivec4( 0, 1, 2, 3 );
		xid = idx & SHADER_X_MASK;
		vxid = idx4 & SHADER_X_MASK;

		// number of pixels to go across is number of pixels being drawn across
		iXInc = SHADER_X_MASK + 1;

#ifdef ENABLE_RANGE_DRAW

		yoffset = ( idx >> SHADER_Y_SHIFT ) + yid;
		iYInc = ( int( lxinc << 2 ) >> SHADER_Y_SHIFT );
#else
		yoffset = ( idx >> SHADER_Y_SHIFT ) << subgroup_shift;
		yoffset = yoffset + yid;

		// the amount to loop down is the number of shader lines being drawn times global shader groups
		iYInc = ( int( lxinc << 2 ) >> SHADER_Y_SHIFT ) << subgroup_shift;
#endif


		// set bgr in case not a texture
		// will use 16-bit version of color for now
		uvbgr = uvec4( bgr16 );

		//ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
		//ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
		//ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;
		ivRedF = ivec4( bitfieldExtract( uvbgr, 0, 5 ) );
		ivGreenF = ivec4( bitfieldExtract( uvbgr, 5, 5 ) );
		ivBlueF = ivec4( bitfieldExtract( uvbgr, 10, 5 ) );


		//for ( uLoop = ((yoffset + StartY) < EndY) ? 0 : 16; uLoop < iLoopMax; uLoop += 16 )
		{


	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yoffset; Line < EndY1; Line += iYInc )
	{
		if ( Line >= StartY1 )
		{
			StartY = StartY1;
			EndY = EndY1;

			x = x1;
			dx = dx1;
			//C_left = C_left1;
			//dC_left = dC_left1;
			//T_left = T_left1;
			//dT_left = dT_left1;
				
		}

		yoffset = Line - StartY;

		//xoff.xy = x.xy + ( dx.xy * (yid) );
		xoff.xy = x.xy + ( dx.xy * (yoffset) );
	

		// left point is included if points are equal
		iStartX = ( xoff.x + 0xffff ) >> 16;
		iEndX = ( xoff.y - 1 ) >> 16;
		
		
		//if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			ivEnable = ivec4( iStartX <= DrawArea_BottomRightX ) & ivec4( iEndX >= DrawArea_TopLeftX ) & ivec4( iEndX >= iStartX );

			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff.x;
			
			//if ( iStartX < DrawArea_TopLeftX )
			//{
			//	Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
			//	iStartX = DrawArea_TopLeftX;
			//}
			Temp += ( DrawArea_TopLeftX - min( iStartX, DrawArea_TopLeftX ) ) << 16;
			iStartX = max( iStartX, DrawArea_TopLeftX );
			
			
			//if ( iEndX > DrawArea_BottomRightX )
			//{
			//	//EndX = DrawArea_BottomRightX + 1;
			//	iEndX = DrawArea_BottomRightX;
			//}
			iEndX = min( iEndX, DrawArea_BottomRightX );


			w = iEndX - iStartX + 1;

			

			//ivPtr = ( iStartX + vxid ) + ( Line << 10 );


			
			
			// draw horizontal line
			vx_across = vxid;
			for ( x_across = xid; x_across < w; x_across += iXInc )
			{

				// check what pixels are enabled
				bvEnable = bvec4( ivec4( lessThan( uvec4( vx_across ), uvec4( w ) ) ) & ivEnable );

				// might want to wrap pixels around framebuffer ?
				ivPtr = ( iStartX + vx_across ) + ( Line << 10 );


				// dest pixels //

				// read pixel from frame buffer if we need to check mask bit


#ifdef ENABLE_BUFFER_READ

				uvDestPixel.x = uint( VRAM16 [ ivPtr.x ] );
				uvDestPixel.y = uint( VRAM16 [ ivPtr.y ] );
				uvDestPixel.z = uint( VRAM16 [ ivPtr.z ] );
				uvDestPixel.w = uint( VRAM16 [ ivPtr.w ] );

#endif




				// blending //


#ifdef USE_MORE_JUMPS
				uvbgr_temp = uvbgr;
				//if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )
				if ( ( Command_ABE != 0 ) )
#endif
				{

					// semi-transparency
					//if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					//}
					//ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					//ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					//ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;
					ivRedB = ivec4( bitfieldExtract( uvDestPixel, 0, 5 ) );
					ivGreenB = ivec4( bitfieldExtract( uvDestPixel, 5, 5 ) );
					ivBlueB = ivec4( bitfieldExtract( uvDestPixel, 10, 5 ) );


					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedB = clamp( ivRedB, 0, 0x1f );
					ivGreenB = clamp( ivGreenB, 0, 0x1f );
					ivBlueB = clamp( ivBlueB, 0, 0x1f );

					//uvbgr_temp = uvec4( ( ivRedB << 0 ) | ( ivGreenB << 5 ) | ( ivBlueB << 10 ) );
					uvbgr_temp = uvec4( bitfieldInsert( bitfieldInsert( ivRedB, ivGreenB, 5, 5 ), ivBlueB, 10, 5 ) );

				}	// end if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )


				uvbgr_temp |= SetPixelMask;


				// select pixels to draw //

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


				// draw/store pixels //


				// store pixels //

#ifdef ENABLE_BUFFER_WRITE

				VRAM16 [ ivPtr.x ] = uint16_t( uvDestPixel.x );
				VRAM16 [ ivPtr.y ] = uint16_t( uvDestPixel.y );
				VRAM16 [ ivPtr.z ] = uint16_t( uvDestPixel.z );
				VRAM16 [ ivPtr.w ] = uint16_t( uvDestPixel.w );

#endif


					
				//ivPtr += iXInc;
				vx_across += iXInc;
				
				
			}	// end for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )

			
			
		}	// end if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		

	}	// end for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )


	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	

	}	// end if ( bDraw == 1 )


#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;

	// this was copied from texture gradient triangle - would need to fix
	//} while ( ( ( Comm >= 0x03 && Comm <= 0x39 ) || ( Comm >= 0x60 && Comm <= 0x79 ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif

}





#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Gradient ( uint uIndex )
#else
void vDrawTriangle_Gradient ( uint uIndex )
#endif
{
	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	
	int xid, yid;

	int idx, count;

	int yid1;
	int yoffset;
	int yoffset1;

	int iPtr;

	int iLoopMax;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	int Line;

	int h;
	int sh;
	ivec4 idx4;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;

	ivec4 Coff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;

	ivec4 Toff_left;
	
	
	int xoff_left, xoff_right;
	ivec4 xoff;

	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	
	int TexCoordX, TexCoordY;


	//uint bgr16;
	//uint bgr32;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	uint Command_TGE;

	//uint color_add;
	int clut_xoffset, clut_yoffset;
	int clut_x, clut_y, tpage_tx, tpage_ty;
	uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;
	int StartY1, EndY1;
	int StartY0, EndY0;

	uint PixelMask, SetPixelMask;


	ivec4 x, dx;

	ivec4 x1, dx1;

	ivec4 dR_across, dG_across, dB_across;


	ivec4 iC, dC_across, dCx_across;
	ivec4 C_left, dC_left;
	ivec4 C_left1, dC_left1;

	int Shift1, Shift2, And1, And2;
	int TextureOffset;
	int ClutOffset;

	int bTexture;

	int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	int TWX, TWY, TWW, TWH;

	ivec4 dU_across, dV_across;

	ivec4 iT, dT_across, dTx_across;

	ivec4 T_left, dT_left;
	ivec4 T_left1, dT_left1;

	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	uvec4 uvbgr, uvbgr2;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivTexCoordY;
	ivec4 ivTexCoordX;
	ivec4 ivU;
	ivec4 ivV;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;

	ivec4 ivLine;
	ivec4 vyid;
	int wl;

	int iXInc, iYInc;
	ivec4 ivEnable;

	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;


	int64_t iDitherValues64;

	ivec4 ivDitherValues32;

	const int iDitherValues32_0 = ( ( -4 & 0xf ) << 28 ) + ( ( 0 & 0xf ) << 24 ) + ( ( -3 & 0xf ) << 20 ) + ( ( 1 & 0xf ) << 16 ) +
									( ( 2 & 0xf ) << 12 ) + ( ( -2 & 0xf ) << 8 ) + ( ( 3 & 0xf ) << 4 ) + ( ( -1 & 0xf ) << 0 );

	const int iDitherValues32_1 = ( ( -3 & 0xf ) << 28 ) + ( ( 1 & 0xf ) << 24 ) + ( ( -4 & 0xf ) << 20 ) + ( ( 0 & 0xf ) << 16 ) +
									( ( 3 & 0xf ) << 12 ) + ( ( -1 & 0xf ) << 8 ) + ( ( 2 & 0xf ) << 4 ) + ( ( -2 & 0xf ) << 0 );


	//int64_t iDitherValues64 = ( int64_t( -4 & 0xf ) << 60 ) + ( int64_t( 0 ) << 56 ) + ( int64_t( -3 & 0xf ) << 52 ) + ( int64_t( 1 ) << 48 ) +
	//								( int64_t( 2 & 0xf ) << 44 ) + ( int64_t( -2 & 0xf ) << 40 ) + ( int64_t( 3 & 0xf ) << 36 ) + ( int64_t( -1 & 0xf ) << 32 ) +
	//								( int64_t( -3 & 0xf ) << 28 ) + ( int64_t( 1 & 0xf ) << 24 ) + ( int64_t( -4 & 0xf ) << 20 ) + ( int64_t( 0 & 0xf ) << 16 ) +
	//								( int64_t( 3 & 0xf ) << 12 ) + ( int64_t( -1 & 0xf ) << 8 ) + ( int64_t( 2 & 0xf ) << 4 ) + ( int64_t( -2 & 0xf ) << 0 );


	i64vec4 ivDitherValues64;
	
	
	//ivDitherValues64 = i64vec4( iDitherValues64 );



	iDitherValues64 = packInt2x32( ivec2( iDitherValues32_0, iDitherValues32_1 ) );
	ivDitherValues64 = i64vec4( iDitherValues64 );


		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
	do
	{
#endif
		

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		// this one needs to be 64 per element instead of 128 per element
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;


		bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw == 1 ) )
	{

		//if ( subgroupElect() )
		{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );

		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );

		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];

		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];

		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];

		//TextureOffset = data [ uIdx + 20 ];
		//ClutOffset = data [ uIdx + 21 ];
		//clut_xoffset = data [ uIdx + 22 ];
		//tpage_abr = data [ uIdx + 23 ];

		//iLoopMax = data [ uIdx + 62 ];
		//iLoopMax = 32;


		//dC_across.r = data [ uIdx + 24 ];
		//dC_across.g = data [ uIdx + 25 ];
		//dC_across.b = data [ uIdx + 26 ];
		dC_across = data32_4 [ uIndex + 6 ];

		//bTexture = data [ uIdx + 27 ];
		//bTexture = dC_across.w;

		//dT_across.s = data [ uIdx + 28 ];
		//dT_across.t = data [ uIdx + 29 ];
		dT_across = data32_4 [ uIndex + 7 ];
		iBShift = dT_across.z & 0xff;
		iFShift = ( dT_across.z >> 8 ) & 0xff;
		iFSign = ( dT_across.z >> 16 );


		//x.x = data [ uIdx + 32 + 0 ];
		//x.y = data [ uIdx + 33 + 0 ];
		//dx.x = data [ uIdx + 34 + 0 ];
		//dx.y = data [ uIdx + 35 + 0 ];
		x = data32_4 [ uIndex + 8 ];
		dx.xy = x.zw;

		//C_left.r = data [ uIdx + 36 + 0 ];
		//C_left.g = data [ uIdx + 37 + 0 ];
		//C_left.b = data [ uIdx + 38 + 0 ];
		C_left = data32_4 [ uIndex + 9 ];

		//StartY = data [ uIdx + 39 + 0 ];
		StartY = C_left.w;

		//dC_left.r = data [ uIdx + 40 + 0 ];
		//dC_left.g = data [ uIdx + 41 + 0 ];
		//dC_left.b = data [ uIdx + 42 + 0 ];
		dC_left = data32_4 [ uIndex + 10 ];

		//EndY = data [ uIdx + 43 + 0 ];
		EndY = dC_left.w;

		//T_left.s = data [ uIdx + 44 + 0 ];
		//T_left.t = data [ uIdx + 45 + 0 ];
		//dT_left.s = data [ uIdx + 46 + 0 ];
		//dT_left.t = data [ uIdx + 47 + 0 ];
		//T_left = data32_4 [ uIndex + 11 ];
		//dT_left.st = T_left.pq;


		//x1.x = data [ uIdx + 32 + 16 ];
		//x1.y = data [ uIdx + 33 + 16 ];
		//dx1.x = data [ uIdx + 34 + 16 ];
		//dx1.y = data [ uIdx + 35 + 16 ];
		x1 = data32_4 [ uIndex + 12 ];
		dx1.xy = x1.zw;

		//C_left1.r = data [ uIdx + 36 + 16 ];
		//C_left1.g = data [ uIdx + 37 + 16 ];
		//C_left1.b = data [ uIdx + 38 + 16 ];
		C_left1 = data32_4 [ uIndex + 13 ];

		//StartY1 = data [ uIdx + 39 + 16 ];
		StartY1 = C_left1.w;

		//dC_left1.r = data [ uIdx + 40 + 16 ];
		//dC_left1.g = data [ uIdx + 41 + 16 ];
		//dC_left1.b = data [ uIdx + 42 + 16 ];
		dC_left1 = data32_4 [ uIndex + 14 ];

		//EndY1 = data [ uIdx + 43 + 16 ];
		EndY1 = dC_left1.w;

		//T_left1.s = data [ uIdx + 44 + 16 ];
		//T_left1.t = data [ uIdx + 45 + 16 ];
		//dT_left1.s = data [ uIdx + 46 + 16 ];
		//dT_left1.t = data [ uIdx + 47 + 16 ];
		//T_left1 = data32_4 [ uIndex + 15 ];
		//dT_left1.st = T_left1.pq;


		}	// end if ( subgroupElect() )




		// only dither if dithering is enabled
		ivDitherValues64 = ( GPU_CTRL_Read_DTD != 0 ) ? ivDitherValues64 : i64vec4( 0 );

		//ivDitherValues32 = ivec4( iDitherValues32_0, iDitherValues32_0, iDitherValues32_1, iDitherValues32_1 );
		//ivDitherValues32 &= int( -GPU_CTRL_Read_DTD );


#ifdef ENABLE_RANGE_DRAW

	// adjust starty (here it is doing inclusive of window start)
	yid = max( StartY, ivDrawRange [ subgroup_local_id ].x ) - StartY;
	//StartY = max( StartY, ivDrawRange [ subgroup_local_id ].x );

	// adjust endy (here it is doing exclusive of window end since it is already exclusive of EndY1)
	EndY1 = min( EndY1, ivDrawRange [ subgroup_local_id ].y );

	// get height for subgroup (exclusive of EndY1)
	sh = EndY1 - StartY - yid;

#else

		yid = int( ( subgroup_global_id - StartY ) & subgroup_mask );

		// h - total height
		h = EndY1 - StartY;
	
		// sh - height for subgroup
		sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );

#endif

#ifdef ENABLE_TRIANGLE_SUBGROUP_SKIP

		// if nothing to draw, then done
		if ( subgroupAll( sh < 0 ) )
		{
			return;
		}

#endif

		idx = int( lxid ) << 2;
		idx4 = idx + ivec4( 0, 1, 2, 3 );
		xid = idx & SHADER_X_MASK;
		vxid = idx4 & SHADER_X_MASK;

		// number of pixels to go across is number of pixels being drawn across
		iXInc = SHADER_X_MASK + 1;

#ifdef ENABLE_RANGE_DRAW

		yoffset = ( idx >> SHADER_Y_SHIFT ) + yid;

		// the amount to loop down is the number of shader lines being drawn times global shader groups
		iYInc = ( int( lxinc << 2 ) >> SHADER_Y_SHIFT );
#else
		yoffset = ( idx >> SHADER_Y_SHIFT ) << subgroup_shift;
		yoffset = yoffset + yid;

		// the amount to loop down is the number of shader lines being drawn times global shader groups
		iYInc = ( int( lxinc << 2 ) >> SHADER_Y_SHIFT ) << subgroup_shift;
#endif


		dCx_across.rgb = dC_across.rgb * iXInc;
		//dTx_across.st = dT_across.st * iXInc;

		dR_across = dC_across.r * vxid;
		dG_across = dC_across.g * vxid;
		dB_across = dC_across.b * vxid;

		//dU_across = dT_across.s * vxid;
		//dV_across = dT_across.t * vxid;

		//for ( uLoop = ((yoffset + StartY) < EndY) ? 0 : 16; uLoop < iLoopMax; uLoop += 16 )
		{


	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yoffset; Line < EndY1; Line += iYInc )
	{
		if ( Line >= StartY1 )
		{
			StartY = StartY1;
			EndY = EndY1;

			x = x1;
			dx = dx1;
			C_left = C_left1;
			dC_left = dC_left1;
			//T_left = T_left1;
			//dT_left = dT_left1;
				
		}

		yoffset = Line - StartY;

		//xoff.xy = x.xy + ( dx.xy * (yid) );
		xoff.xy = x.xy + ( dx.xy * (yoffset) );
	
		//Coff_left.rgb = C_left.rgb + ( dC_left.rgb * (yid) );
		Coff_left.rgb = C_left.rgb + ( dC_left.rgb * (yoffset) );
	
		//Toff_left.st = T_left.st + ( dT_left.st * (yid) );
		//Toff_left.st = T_left.st + ( dT_left.st * (yoffset) );


		// left point is included if points are equal
		iStartX = ( xoff.x + 0xffff ) >> 16;
		iEndX = ( xoff.y - 1 ) >> 16;
		
		
		//if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			ivEnable = ivec4( iStartX <= DrawArea_BottomRightX ) & ivec4( iEndX >= DrawArea_TopLeftX ) & ivec4( iEndX >= iStartX );

			iC.rgb = Coff_left.rgb;
			
			//iT.st = Toff_left.st;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff.x;
			
			//if ( iStartX < DrawArea_TopLeftX )
			//{
			//	Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
			//	iStartX = DrawArea_TopLeftX;
			//}
			Temp += ( DrawArea_TopLeftX - min( iStartX, DrawArea_TopLeftX ) ) << 16;
			iStartX = max( iStartX, DrawArea_TopLeftX );
			
			iC.rgb += ( dC_across.rgb >> 8 ) * ( Temp >> 8 );
			
			//iT.st += ( dT_across.st >> 8 ) * ( Temp >> 8 );
			
			//if ( iEndX > DrawArea_BottomRightX )
			//{
			//	//EndX = DrawArea_BottomRightX + 1;
			//	iEndX = DrawArea_BottomRightX;
			//}
			iEndX = min( iEndX, DrawArea_BottomRightX );


			w = iEndX - iStartX + 1;

			

			//ivPtr = ( iStartX + vxid ) + ( Line << 10 );

			//ivR = iC.r + ( dC_across.r * vxid );
			//ivG = iC.g + ( dC_across.g * vxid );
			//ivB = iC.b + ( dC_across.b * vxid );
			ivR = iC.r + dR_across;
			ivG = iC.g + dG_across;
			ivB = iC.b + dB_across;

			//ivU = iT.s + ( dT_across.s * vxid );
			//ivV = iT.t + ( dT_across.t * vxid );
			//ivU = iT.s + dU_across;
			//ivV = iT.t + dV_across;



			
			// set bgr in case not a texture
			uvbgr = uvec4( 0xffff );
			
			// draw horizontal line
			vx_across = vxid;
			for ( x_across = xid; x_across < w; x_across += iXInc )
			{

				// check what pixels are enabled
				bvEnable = bvec4( ivec4( lessThan( uvec4( vx_across ), uvec4( w ) ) ) & ivEnable );

				// might want to wrap pixels around framebuffer ?
				ivPtr = ( iStartX + vx_across ) + ( Line << 10 );


				// dest pixels //

				// read pixel from frame buffer if we need to check mask bit


#ifdef ENABLE_BUFFER_READ

				uvDestPixel.x = uint( VRAM16 [ ivPtr.x ] );
				uvDestPixel.y = uint( VRAM16 [ ivPtr.y ] );
				uvDestPixel.z = uint( VRAM16 [ ivPtr.z ] );
				uvDestPixel.w = uint( VRAM16 [ ivPtr.w ] );

#endif


				
				// dithering //



#ifdef USE_MORE_JUMPS
					ivRedF = ivR >> 19;
					ivGreenF = ivG >> 19;
					ivBlueF = ivB >> 19;
					if ( subgroupAll( GPU_CTRL_Read_DTD != 0 ) )
#endif
					{

#ifdef USE_PRIVATE_DITHER

						ivDitherValue = ivec4( ( ivDitherValues64 << ( ( ( Line & 3 ) << 4 ) + ( ( ( vx_across + iStartX ) & 3 ) << 2 ) ) ) >> 60 );
						ivDitherValue <<= 16;
#else

						ivIndex = ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 );
						ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );

#ifdef USE_LOCAL_DITHER
						ivDitherValue.x = iDitherValues16 [ ivIndex.x ];
						ivDitherValue.y = iDitherValues16 [ ivIndex.y ];
						ivDitherValue.z = iDitherValues16 [ ivIndex.z ];
						ivDitherValue.w = iDitherValues16 [ ivIndex.w ];
#else
						ivDitherValue.x = c_iDitherValues16 [ ivIndex.x ];
						ivDitherValue.y = c_iDitherValues16 [ ivIndex.y ];
						ivDitherValue.z = c_iDitherValues16 [ ivIndex.z ];
						ivDitherValue.w = c_iDitherValues16 [ ivIndex.w ];

#endif	// end #ifdef USE_LOCAL_DITHER

#endif	// end #ifdef USE_PRIVATE_DITHER

						//ivDitherValue = ivec4( ( ivDitherValues64 << ( ( ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 ) ) << 2 ) ) >> 60 );
						//ivDitherValue.x = ( iDitherValues64 << ( ( ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 ) ) << 2 ) ) >> 60;

						// perform dither
						ivRedC = ivR + ivDitherValue;
						ivGreenC = ivG + ivDitherValue;
						ivBlueC = ivB + ivDitherValue;
				
						ivRedF = clamp ( ivRedC >> 19, 0, 31 );
						ivGreenF = clamp ( ivGreenC >> 19, 0, 31 );
						ivBlueF = clamp ( ivBlueC >> 19, 0, 31 );

					}	// end if ( subgroupAll( GPU_CTRL_Read_DTD != 0 ) )



				// blending //

#ifdef USE_MORE_JUMPS
				//if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )
				if ( ( Command_ABE != 0 ) )
#endif
				{

					// semi-transparency
					//if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					//}
					//ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					//ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					//ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;
					ivRedB = ivec4( bitfieldExtract( uvDestPixel, 0, 5 ) );
					ivGreenB = ivec4( bitfieldExtract( uvDestPixel, 5, 5 ) );
					ivBlueB = ivec4( bitfieldExtract( uvDestPixel, 10, 5 ) );

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 31 );
					ivGreenF = clamp( ivGreenB, 0, 31 );
					ivBlueF = clamp( ivBlueB, 0, 31 );

				}	// end if ( ( Command_ABE != 0 ) )


				//uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );
				uvbgr_temp = uvec4( bitfieldInsert( bitfieldInsert( ivRedF, ivGreenF, 5, 5 ), ivBlueF, 10, 5 ) );


				uvbgr_temp |= SetPixelMask;


				// select pixels to draw //


				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;
				// draw pixel if we can draw to mask pixels or mask bit not set
				//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


				// draw/store pixels //


				// store pixels //

#ifdef ENABLE_BUFFER_WRITE

				VRAM16 [ ivPtr.x ] = uint16_t( uvDestPixel.x );
				VRAM16 [ ivPtr.y ] = uint16_t( uvDestPixel.y );
				VRAM16 [ ivPtr.z ] = uint16_t( uvDestPixel.z );
				VRAM16 [ ivPtr.w ] = uint16_t( uvDestPixel.w );

#endif

				
				ivR += ( dCx_across.r );
				ivG += ( dCx_across.g );
				ivB += ( dCx_across.b );
			
				//ivU += ( dTx_across.s );
				//ivV += ( dTx_across.t );
					
				//ivPtr += iXInc;
				vx_across += iXInc;
				
				
			}	// end for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )

			
			
		}	// end if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		

	}	// end for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )


	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	

	}	// end if ( bDraw == 1 )


#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x30 && Comm <= 0x33 ) || ( Comm >= 0x38 && Comm <= 0x3b ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}







#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
uint vDrawTriangle_TextureGradient ( uint uIndex )
#else
void vDrawTriangle_TextureGradient ( uint uIndex )
#endif
{
	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	
	int xid, yid;

	int idx, count;

	int yid1;
	int yoffset;
	int yoffset1;

	int iPtr;

	int iLoopMax;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	int Line;

	int h;
	int sh;
	ivec4 idx4;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;

	ivec4 Coff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;

	ivec4 Toff_left;
	
	
	int xoff_left, xoff_right;
	ivec4 xoff;

	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	
	int TexCoordX, TexCoordY;


	//uint bgr16;
	//uint bgr32;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	uint Command_TGE;

	//uint color_add;
	int clut_xoffset, clut_yoffset;
	int clut_x, clut_y, tpage_tx, tpage_ty;
	uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;
	int StartY1, EndY1;
	int StartY0, EndY0;

	uint PixelMask, SetPixelMask;


	ivec4 x, dx;

	ivec4 x1, dx1;

	ivec4 dR_across, dG_across, dB_across;


	ivec4 iC, dC_across, dCx_across;
	ivec4 C_left, dC_left;
	ivec4 C_left1, dC_left1;

	int Shift1, Shift2, And1, And2;
	int TextureOffset;
	int ClutOffset;

	int bTexture;

	int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	int TWX, TWY, TWW, TWH;

	ivec4 dU_across, dV_across;

	ivec4 iT, dT_across, dTx_across;

	ivec4 T_left, dT_left;
	ivec4 T_left1, dT_left1;

	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	uvec4 uvbgr, uvbgr2;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivTexCoordY;
	ivec4 ivTexCoordX;
	ivec4 ivU;
	ivec4 ivV;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;

	ivec4 ivLine;
	ivec4 vyid;
	int wl;

	int iXInc, iYInc;
	ivec4 ivEnable;

	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;

	ivec4 ivDitherValues32;

	int64_t iDitherValues64;

	const int iDitherValues32_0 = ( ( -4 & 0xf ) << 28 ) + ( ( 0 & 0xf ) << 24 ) + ( ( -3 & 0xf ) << 20 ) + ( ( 1 & 0xf ) << 16 ) +
									( ( 2 & 0xf ) << 12 ) + ( ( -2 & 0xf ) << 8 ) + ( ( 3 & 0xf ) << 4 ) + ( ( -1 & 0xf ) << 0 );

	const int iDitherValues32_1 = ( ( -3 & 0xf ) << 28 ) + ( ( 1 & 0xf ) << 24 ) + ( ( -4 & 0xf ) << 20 ) + ( ( 0 & 0xf ) << 16 ) +
									( ( 3 & 0xf ) << 12 ) + ( ( -1 & 0xf ) << 8 ) + ( ( 2 & 0xf ) << 4 ) + ( ( -2 & 0xf ) << 0 );


	//int64_t iDitherValues64 = ( int64_t( -4 & 0xf ) << 60 ) + ( int64_t( 0 ) << 56 ) + ( int64_t( -3 & 0xf ) << 52 ) + ( int64_t( 1 ) << 48 ) +
	//								( int64_t( 2 & 0xf ) << 44 ) + ( int64_t( -2 & 0xf ) << 40 ) + ( int64_t( 3 & 0xf ) << 36 ) + ( int64_t( -1 & 0xf ) << 32 ) +
	//								( int64_t( -3 & 0xf ) << 28 ) + ( int64_t( 1 & 0xf ) << 24 ) + ( int64_t( -4 & 0xf ) << 20 ) + ( int64_t( 0 & 0xf ) << 16 ) +
	//								( int64_t( 3 & 0xf ) << 12 ) + ( int64_t( -1 & 0xf ) << 8 ) + ( int64_t( 2 & 0xf ) << 4 ) + ( int64_t( -2 & 0xf ) << 0 );


	i64vec4 ivDitherValues64;
	
	
	//ivDitherValues64 = i64vec4( iDitherValues64 );



	iDitherValues64 = packInt2x32( ivec2( iDitherValues32_0, iDitherValues32_1 ) );
	ivDitherValues64 = i64vec4( iDitherValues64 );



		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
	do
	{
#endif
		

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		// this one needs to be 64 per element instead of 128 per element
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;


		bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw == 1 ) )
	{

		//if ( subgroupElect() )
		{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );

		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );

		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];

		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];

		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];

		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];

		//iLoopMax = data [ uIdx + 62 ];
		//iLoopMax = 32;


		//dC_across.r = data [ uIdx + 24 ];
		//dC_across.g = data [ uIdx + 25 ];
		//dC_across.b = data [ uIdx + 26 ];
		dC_across = data32_4 [ uIndex + 6 ];

		//bTexture = data [ uIdx + 27 ];
		bTexture = dC_across.w;

		//dT_across.s = data [ uIdx + 28 ];
		//dT_across.t = data [ uIdx + 29 ];
		dT_across = data32_4 [ uIndex + 7 ];
		iBShift = dT_across.z & 0xff;
		iFShift = ( dT_across.z >> 8 ) & 0xff;
		iFSign = ( dT_across.z >> 16 );


		//x.x = data [ uIdx + 32 + 0 ];
		//x.y = data [ uIdx + 33 + 0 ];
		//dx.x = data [ uIdx + 34 + 0 ];
		//dx.y = data [ uIdx + 35 + 0 ];
		x = data32_4 [ uIndex + 8 ];
		dx.xy = x.zw;

		//C_left.r = data [ uIdx + 36 + 0 ];
		//C_left.g = data [ uIdx + 37 + 0 ];
		//C_left.b = data [ uIdx + 38 + 0 ];
		C_left = data32_4 [ uIndex + 9 ];

		//StartY = data [ uIdx + 39 + 0 ];
		StartY = C_left.w;

		//dC_left.r = data [ uIdx + 40 + 0 ];
		//dC_left.g = data [ uIdx + 41 + 0 ];
		//dC_left.b = data [ uIdx + 42 + 0 ];
		dC_left = data32_4 [ uIndex + 10 ];

		//EndY = data [ uIdx + 43 + 0 ];
		EndY = dC_left.w;

		//T_left.s = data [ uIdx + 44 + 0 ];
		//T_left.t = data [ uIdx + 45 + 0 ];
		//dT_left.s = data [ uIdx + 46 + 0 ];
		//dT_left.t = data [ uIdx + 47 + 0 ];
		T_left = data32_4 [ uIndex + 11 ];
		dT_left.st = T_left.pq;


		//x1.x = data [ uIdx + 32 + 16 ];
		//x1.y = data [ uIdx + 33 + 16 ];
		//dx1.x = data [ uIdx + 34 + 16 ];
		//dx1.y = data [ uIdx + 35 + 16 ];
		x1 = data32_4 [ uIndex + 12 ];
		dx1.xy = x1.zw;

		//C_left1.r = data [ uIdx + 36 + 16 ];
		//C_left1.g = data [ uIdx + 37 + 16 ];
		//C_left1.b = data [ uIdx + 38 + 16 ];
		C_left1 = data32_4 [ uIndex + 13 ];

		//StartY1 = data [ uIdx + 39 + 16 ];
		StartY1 = C_left1.w;

		//dC_left1.r = data [ uIdx + 40 + 16 ];
		//dC_left1.g = data [ uIdx + 41 + 16 ];
		//dC_left1.b = data [ uIdx + 42 + 16 ];
		dC_left1 = data32_4 [ uIndex + 14 ];

		//EndY1 = data [ uIdx + 43 + 16 ];
		EndY1 = dC_left1.w;

		//T_left1.s = data [ uIdx + 44 + 16 ];
		//T_left1.t = data [ uIdx + 45 + 16 ];
		//dT_left1.s = data [ uIdx + 46 + 16 ];
		//dT_left1.t = data [ uIdx + 47 + 16 ];
		T_left1 = data32_4 [ uIndex + 15 ];
		dT_left1.st = T_left1.pq;



		//dCx_across.rgb = dC_across.rgb * group_vxinc;
		//dTx_across.st = dT_across.st * group_vxinc;


	//if ( Command_TGE != 0 )
	//{
	//	color_add = 0x00808080;
	//}




		}	// end if ( subgroupElect() )




		// only dither if dithering is enabled
		ivDitherValues64 = ( GPU_CTRL_Read_DTD != 0 ) ? ivDitherValues64 : i64vec4( 0 );

		//ivDitherValues32 = ivec4( iDitherValues32_0, iDitherValues32_0, iDitherValues32_1, iDitherValues32_1 );
		//ivDitherValues32 &= int( -GPU_CTRL_Read_DTD );


#ifdef USE_LOCAL_CLUT
		// load palette if there is one
		if ( subgroupAll( Shift1 != 0 ) )
		{
			// get palette offset
			// ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask )

			count = And2 + 1;
			//for ( idx = int( lxid ); idx < int( count ); idx += int( lxinc ) )
			for ( idx = int( lxid ) << 2; idx < int( count ); idx += int( lxinc ) << 2 )
			{
				//ulocal_data32 [ ( subgroup_id << 8 ) + idx ] = uint( VRAM16 [ ClutOffset + ( ( clut_xoffset + idx ) & c_lFrameBuffer_Width_Mask ) ] );

				ivPtr = ivec4( ( subgroup_local_id << 8 ) + idx + ivec4( 0, 1, 2, 3 ) );
				uvbgr = uvec4( VRAM16_4 [ ( ClutOffset + ( ( clut_xoffset + idx ) & c_lFrameBuffer_Width_Mask ) ) >> 2 ] );
				ulocal_data32 [ ivPtr.x ] = uvbgr.x;
				ulocal_data32 [ ivPtr.y ] = uvbgr.y;
				ulocal_data32 [ ivPtr.z ] = uvbgr.z;
				ulocal_data32 [ ivPtr.w ] = uvbgr.w;

			}
		}
#endif


#ifdef ENABLE_RANGE_DRAW

	// adjust starty (here it is doing inclusive of window start)
	yid = max( StartY, ivDrawRange [ subgroup_local_id ].x ) - StartY;
	//StartY = max( StartY, ivDrawRange [ subgroup_local_id ].x );

	// adjust endy (here it is doing exclusive of window end since it is already exclusive of EndY1)
	EndY1 = min( EndY1, ivDrawRange [ subgroup_local_id ].y );

	// get height for subgroup (exclusive of EndY1)
	sh = EndY1 - StartY - yid;

#else
		yid = int( ( subgroup_global_id - StartY ) & subgroup_mask );

		// h - total height
		h = EndY1 - StartY;
	
		// sh - height for subgroup
		sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );
#endif

#ifdef ENABLE_TRIANGLE_SUBGROUP_SKIP

		// if nothing to draw, then done
		if ( subgroupAll( sh < 0 ) )
		{
			return;
		}

#endif

		idx = int( lxid ) << 2;
		idx4 = idx + ivec4( 0, 1, 2, 3 );
		xid = idx & SHADER_X_MASK;
		vxid = idx4 & SHADER_X_MASK;

		// number of pixels to go across is number of pixels being drawn across
		iXInc = SHADER_X_MASK + 1;

#ifdef ENABLE_RANGE_DRAW

		yoffset = ( idx >> SHADER_Y_SHIFT ) + yid;

		// the amount to loop down is the number of shader lines being drawn times global shader groups
		iYInc = ( int( lxinc << 2 ) >> SHADER_Y_SHIFT );
#else
		yoffset = ( idx >> SHADER_Y_SHIFT ) << subgroup_shift;
		yoffset = yoffset + yid;

		// the amount to loop down is the number of shader lines being drawn times global shader groups
		iYInc = ( int( lxinc << 2 ) >> SHADER_Y_SHIFT ) << subgroup_shift;
#endif

		dCx_across.rgb = dC_across.rgb * iXInc;
		dTx_across.st = dT_across.st * iXInc;

		dR_across = dC_across.r * vxid;
		dG_across = dC_across.g * vxid;
		dB_across = dC_across.b * vxid;

		dU_across = dT_across.s * vxid;
		dV_across = dT_across.t * vxid;

		//for ( uLoop = ((yoffset + StartY) < EndY) ? 0 : 16; uLoop < iLoopMax; uLoop += 16 )
		{


	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yoffset; Line < EndY1; Line += iYInc )
	{
		if ( Line >= StartY1 )
		{
			StartY = StartY1;
			EndY = EndY1;

			x = x1;
			dx = dx1;
			C_left = C_left1;
			dC_left = dC_left1;
			T_left = T_left1;
			dT_left = dT_left1;
				
		}

		yoffset = Line - StartY;

		//xoff.xy = x.xy + ( dx.xy * (yid) );
		xoff.xy = x.xy + ( dx.xy * (yoffset) );
	
		//Coff_left.rgb = C_left.rgb + ( dC_left.rgb * (yid) );
		Coff_left.rgb = C_left.rgb + ( dC_left.rgb * (yoffset) );
	
		//Toff_left.st = T_left.st + ( dT_left.st * (yid) );
		Toff_left.st = T_left.st + ( dT_left.st * (yoffset) );


		// left point is included if points are equal
		iStartX = ( xoff.x + 0xffff ) >> 16;
		iEndX = ( xoff.y - 1 ) >> 16;
		
		
		//if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			ivEnable = ivec4( iStartX <= DrawArea_BottomRightX ) & ivec4( iEndX >= DrawArea_TopLeftX ) & ivec4( iEndX >= iStartX );

			iC.rgb = Coff_left.rgb;
			
			iT.st = Toff_left.st;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff.x;
			
			//if ( iStartX < DrawArea_TopLeftX )
			//{
			//	Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
			//	iStartX = DrawArea_TopLeftX;
			//}
			Temp += ( DrawArea_TopLeftX - min( iStartX, DrawArea_TopLeftX ) ) << 16;
			iStartX = max( iStartX, DrawArea_TopLeftX );
			
			iC.rgb += ( dC_across.rgb >> 8 ) * ( Temp >> 8 );
			
			iT.st += ( dT_across.st >> 8 ) * ( Temp >> 8 );
			
			//if ( iEndX > DrawArea_BottomRightX )
			//{
			//	//EndX = DrawArea_BottomRightX + 1;
			//	iEndX = DrawArea_BottomRightX;
			//}
			iEndX = min( iEndX, DrawArea_BottomRightX );


			w = iEndX - iStartX + 1;

			

			//ivPtr = ( iStartX + vxid ) + ( Line << 10 );

			ivR = iC.r + dR_across;
			ivG = iC.g + dG_across;
			ivB = iC.b + dB_across;

			ivU = iT.s + dU_across;
			ivV = iT.t + dV_across;



			
			// set bgr in case not a texture
			uvbgr = uvec4( 0xffff );
			
			// draw horizontal line
			vx_across = vxid;
			for ( x_across = xid; x_across < w; x_across += iXInc )
			{

				// check what pixels are enabled
				bvEnable = bvec4( ivec4( lessThan( uvec4( vx_across ), uvec4( w ) ) ) & ivEnable );

				// might want to wrap pixels around framebuffer ?
				ivPtr = ( iStartX + vx_across ) + ( Line << 10 );


				// dest pixels //

				// read pixel from frame buffer if we need to check mask bit


#ifdef ENABLE_BUFFER_READ

				uvDestPixel.x = uint( VRAM16 [ ivPtr.x ] );
				uvDestPixel.y = uint( VRAM16 [ ivPtr.y ] );
				uvDestPixel.z = uint( VRAM16 [ ivPtr.z ] );
				uvDestPixel.w = uint( VRAM16 [ ivPtr.w ] );

#endif

				ivRedF = ivec4( 0x10 );
				ivGreenF = ivec4( 0x10 );
				ivBlueF = ivec4( 0x10 );

				// texture mapping //

				if ( subgroupAll( bTexture != 0 ) )
				{
				//TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				//TexCoordY <<= 10;
				//TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				ivTexCoordY = ( ( ( ivV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				ivTexCoordY <<= 10;
				ivTexCoordX = ( ( ( ivU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				// x-component should be shifted right 1 again since 2 pixels per?
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + ivTexCoordY;

#ifdef ENABLE_BUFFER_READ

				uvbgr.x = uint( VRAM16 [ ivIndex.x ] );
				uvbgr.y = uint( VRAM16 [ ivIndex.y ] );
				uvbgr.z = uint( VRAM16 [ ivIndex.z ] );
				uvbgr.w = uint( VRAM16 [ ivIndex.w ] );

#endif


#ifdef USE_MORE_JUMPS
				if ( subgroupAll( Shift1 != 0 ) )
#endif
				{
					//if ( Shift1 != 0 )
					//{
					//	//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
					//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
					//}

#ifdef USE_LOCAL_CLUT
					ivIndex = ivec4( ( subgroup_local_id << 8 ) + ( ( ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) ) );
					uvbgr2.x = ulocal_data32 [ ivIndex.x ];
					uvbgr2.y = ulocal_data32 [ ivIndex.y ];
					uvbgr2.z = ulocal_data32 [ ivIndex.z ];
					uvbgr2.w = ulocal_data32 [ ivIndex.w ];

#else

					ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );

#ifdef ENABLE_BUFFER_READ
					uvbgr2.x = uint( VRAM16 [ ivIndex.x ] );
					uvbgr2.y = uint( VRAM16 [ ivIndex.y ] );
					uvbgr2.z = uint( VRAM16 [ ivIndex.z ] );
					uvbgr2.w = uint( VRAM16 [ ivIndex.w ] );
#endif

#endif

					uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;

				}	// end if ( subgroupAll( Shift1 != 0 ) )
				
				//ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
				//ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
				//ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;
				ivRedF = ivec4( bitfieldExtract( uvbgr, 0, 5 ) );
				ivGreenF = ivec4( bitfieldExtract( uvbgr, 5, 5 ) );
				ivBlueF = ivec4( bitfieldExtract( uvbgr, 10, 5 ) );

				}	// end if ( subgroupAll( bTexture != 0 ) )


				// color gradient //

				// shade pixel color
					
					
				//bgr_temp = bgr;


#ifdef USE_MORE_JUMPS
				if ( subgroupAll( Command_TGE == 0 ) )
#endif
				{


#ifdef USE_MORE_JUMPS
					if ( subgroupAll( GPU_CTRL_Read_DTD != 0 ) )
#endif
					{


#ifdef USE_PRIVATE_DITHER

						ivDitherValue = ivec4( ( ivDitherValues64 << ( ( ( Line & 3 ) << 4 ) + ( ( ( vx_across + iStartX ) & 3 ) << 2 ) ) ) >> 60 );
						ivDitherValue <<= 16;
						
#else

						ivIndex = ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 );
						ivIndex = ( GPU_CTRL_Read_DTD != 0 ) ? ivIndex : ivec4( 1 );

#ifdef USE_LOCAL_DITHER
						ivDitherValue.x = iDitherValues16 [ ivIndex.x ];
						ivDitherValue.y = iDitherValues16 [ ivIndex.y ];
						ivDitherValue.z = iDitherValues16 [ ivIndex.z ];
						ivDitherValue.w = iDitherValues16 [ ivIndex.w ];
#else
						ivDitherValue.x = c_iDitherValues16 [ ivIndex.x ];
						ivDitherValue.y = c_iDitherValues16 [ ivIndex.y ];
						ivDitherValue.z = c_iDitherValues16 [ ivIndex.z ];
						ivDitherValue.w = c_iDitherValues16 [ ivIndex.w ];
#endif	// end #ifdef USE_LOCAL_DITHER

#endif	// end #ifdef USE_PRIVATE_DITHER

						//ivDitherValue = ivec4( ( ivDitherValues64 << ( ( ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 ) ) << 2 ) ) >> 60 );
						//ivDitherValue.x = ( iDitherValues64 << ( ( ( ( vx_across + iStartX ) & 3 ) + ( ( Line & 3 ) << 2 ) ) << 2 ) ) >> 60;

						// perform dither
						ivRedC = ivR + ivDitherValue;
						ivGreenC = ivG + ivDitherValue;
						ivBlueC = ivB + ivDitherValue;
				
						ivRedC = clamp ( ivRedC, 0, 255 << 16 );
						ivGreenC = clamp ( ivGreenC, 0, 255 << 16 );
						ivBlueC = clamp ( ivBlueC, 0, 255 << 16 );

					}	// end if ( subgroupAll( GPU_CTRL_Read_DTD != 0 ) )

					// perform shift
					ivRedC >>= ( 16 );
					ivGreenC >>= ( 16 );
					ivBlueC >>= ( 16 );

					ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
					ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
					ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );

				}	// end if ( subgroupAll( Command_TGE == 0 ) )

				// needs a pixel to select here in case it selects the non-alpha blended pixel below
				uvbgr2 = uvec4( bitfieldInsert( bitfieldInsert( ivRedF, ivGreenF, 5, 5 ), ivBlueF, 10, 5 ) );

				// blending //

#ifdef USE_MORE_JUMPS
				if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )
#endif
				{

					// semi-transparency
					//if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					//}
					//ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					//ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					//ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;
					ivRedB = ivec4( bitfieldExtract( uvDestPixel, 0, 5 ) );
					ivGreenB = ivec4( bitfieldExtract( uvDestPixel, 5, 5 ) );
					ivBlueB = ivec4( bitfieldExtract( uvDestPixel, 10, 5 ) );

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 0x1f );
					ivGreenF = clamp( ivGreenB, 0, 0x1f );
					ivBlueF = clamp( ivBlueB, 0, 0x1f );

				}	// end if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )


				//uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );
				uvbgr_temp = uvec4( bitfieldInsert( bitfieldInsert( ivRedF, ivGreenF, 5, 5 ), ivBlueF, 10, 5 ) );


				if ( subgroupAll( bTexture != 0 ) )
				{

				// no need to select based on command_abe since can just set shift to 16 and sign to zero
				//uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
				uvbgr_temp = mix( uvbgr_temp, uvbgr2, equal( uvbgr & 0x8000, vZero ) );
					
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
				uvbgr_temp |= ( uvbgr & 0x8000 );

				}	// end if ( subgroupAll( bTexture != 0 ) )


				uvbgr_temp |= SetPixelMask;


				// select pixels to draw //

				// only draw pixel if not key color (zero)
				uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;
				// draw pixel if we can draw to mask pixels or mask bit not set
				//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


				// draw/store pixels //

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );

				// store pixels //

#ifdef ENABLE_BUFFER_WRITE

				VRAM16 [ ivPtr.x ] = uint16_t( uvDestPixel.x );
				VRAM16 [ ivPtr.y ] = uint16_t( uvDestPixel.y );
				VRAM16 [ ivPtr.z ] = uint16_t( uvDestPixel.z );
				VRAM16 [ ivPtr.w ] = uint16_t( uvDestPixel.w );

#endif

				
				ivR += ( dCx_across.r );
				ivG += ( dCx_across.g );
				ivB += ( dCx_across.b );
			
				ivU += ( dTx_across.s );
				ivV += ( dTx_across.t );
					
				//ivPtr += iXInc;
				vx_across += iXInc;
				
				
			}	// end for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )

			
			
		}	// end if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		

	}	// end for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )


	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	

	}	// end if ( bDraw == 1 )


#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;

	} while ( ( ( Comm >= 0x03 && Comm <= 0x39 ) || ( Comm >= 0x60 && Comm <= 0x79 ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
	//} while ( ( ( Comm >= 0x34 && Comm <= 0x37 ) || ( Comm >= 0x3c && Comm <= 0x3f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif

	//barrier ();

#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
		
}







#ifdef ENABLE_PRIMITIVE_LOOP
uint vDrawTriangle_Texture ( uint uIndex )
#else
void vDrawTriangle_Texture ( uint uIndex )
#endif
{
	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	
	int xid, yid;

	int idx, count;

	int yid1;
	int yoffset;
	int yoffset1;

	int iPtr;

	int iLoopMax;

	
	int Temp;
	
	int iStartX, iEndX;

	int DitherValue;

	// new variables
	int x_across;
	uint bgr, bgr_temp;
	uint bgr32, bgr16;
	int Line;

	int h;
	int sh;
	ivec4 idx4;

	// more variables for gradient triangle
	int iR, iG, iB;
	int Roff_left, Goff_left, Boff_left;

	ivec4 Coff_left;
	
	// variables for texture triangle
	int iU, iV;
	int Uoff_left, Voff_left;

	ivec4 Toff_left;
	
	
	int xoff_left, xoff_right;
	ivec4 xoff;

	
	int Red, Green, Blue;
	uint DestPixel;


	uint ucolor_add;
	
	
	int TexCoordX, TexCoordY;


	//uint bgr16;
	//uint bgr32;


	uint GPU_CTRL_Read, GPU_CTRL_Read_ABR;
	int DrawArea_BottomRightX, DrawArea_TopLeftX, DrawArea_BottomRightY, DrawArea_TopLeftY;
	uint Command_ABE;
	uint GPU_CTRL_Read_DTD;
	uint Command_TGE;

	//uint color_add;
	int clut_xoffset, clut_yoffset;
	int clut_x, clut_y, tpage_tx, tpage_ty;
	uint tpage_abr, tpage_tp, command_abr;

	int StartX, EndX, StartY, EndY;
	int StartY1, EndY1;
	int StartY0, EndY0;

	uint PixelMask, SetPixelMask;


	ivec4 x, dx;

	ivec4 x1, dx1;

	ivec4 dR_across, dG_across, dB_across;


	ivec4 iC, dC_across, dCx_across;
	ivec4 C_left, dC_left;
	ivec4 C_left1, dC_left1;

	int Shift1, Shift2, And1, And2;
	int TextureOffset;
	int ClutOffset;

	int bTexture;

	int TWYTWH, TWXTWW, Not_TWH, Not_TWW;
	int TWX, TWY, TWW, TWH;

	ivec4 dU_across, dV_across;

	ivec4 iT, dT_across, dTx_across;

	ivec4 T_left, dT_left;
	ivec4 T_left1, dT_left1;

	int w;
	ivec4 ivR, ivG, ivB;
	ivec4 ivDitherValue;

	ivec4 vxid;
	ivec4 vx_across;
	ivec4 ivPtr;
	uvec4 uvDestPixel;
	uvec4 uvbgr16, uvbgr_temp;
	bvec4 bvEnable;
	ivec4 ivIndex;

	uvec4 uvbgr, uvbgr2;

	const ivec4 vZero = ivec4( 0 );


	ivec4 ivRedB, ivGreenB, ivBlueB;
	ivec4 ivRedF, ivGreenF, ivBlueF;
	int iBShift, iFShift, iFSign;

	ivec4 ivTexCoordY;
	ivec4 ivTexCoordX;
	ivec4 ivU;
	ivec4 ivV;
	uvec4 uvcolor_add;
	ivec4 ivRedC, ivGreenC, ivBlueC;

	ivec4 ivLine;
	ivec4 vyid;
	int wl;

	int iXInc, iYInc;
	ivec4 ivEnable;

	uint Comm;
	int bDraw;

	uint uIdx;
	uint uLoop;




		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP_TEXTURE_GRADIENT
	do
	{
#endif
		

	
	/////////////////////////////////////////////
	// init x on the left and right
	
		// this one needs to be 64 per element instead of 128 per element
		//uIdx = uIndex << 3;
		uIdx = uIndex << 2;


		bDraw = data [ uIdx + 0 ];

	if ( subgroupAll( bDraw == 1 ) )
	{

		//if ( subgroupElect() )
		{
		PixelMask = uint( data [ uIdx + 1 ] );
		SetPixelMask = uint( data [ uIdx + 2 ] );
		GPU_CTRL_Read_ABR = uint( data [ uIdx + 3 ] );

		Command_ABE = uint( data [ uIdx + 4 ] );
		Command_TGE = uint( data [ uIdx + 5 ] );
		//bgr32 = uint( data [ uIdx + 6 ] );
		//bgr16 = uint( data [ uIdx + 7 ] );

		GPU_CTRL_Read_DTD = uint( data [ uIdx + 8 ] );
		DrawArea_TopLeftX = data [ uIdx + 9 ];
		DrawArea_BottomRightX = data [ uIdx + 10 ];
		//EndY = data [ uIdx + 11 ];

		Shift1 = data [ uIdx + 12 ];
		Shift2 = data [ uIdx + 13 ];
		And1 = data [ uIdx + 14 ];
		And2 = data [ uIdx + 15 ];

		TWYTWH = data [ uIdx + 16 ];
		TWXTWW = data [ uIdx + 17 ];
		Not_TWH = data [ uIdx + 18 ];
		Not_TWW = data [ uIdx + 19 ];

		TextureOffset = data [ uIdx + 20 ];
		ClutOffset = data [ uIdx + 21 ];
		clut_xoffset = data [ uIdx + 22 ];
		tpage_abr = data [ uIdx + 23 ];

		//iLoopMax = data [ uIdx + 62 ];
		//iLoopMax = 32;


		//dC_across.r = data [ uIdx + 24 ];
		//dC_across.g = data [ uIdx + 25 ];
		//dC_across.b = data [ uIdx + 26 ];
		dC_across = data32_4 [ uIndex + 6 ];

		//bTexture = data [ uIdx + 27 ];
		bTexture = dC_across.w;

		//dT_across.s = data [ uIdx + 28 ];
		//dT_across.t = data [ uIdx + 29 ];
		dT_across = data32_4 [ uIndex + 7 ];
		iBShift = dT_across.z & 0xff;
		iFShift = ( dT_across.z >> 8 ) & 0xff;
		iFSign = ( dT_across.z >> 16 );


		//x.x = data [ uIdx + 32 + 0 ];
		//x.y = data [ uIdx + 33 + 0 ];
		//dx.x = data [ uIdx + 34 + 0 ];
		//dx.y = data [ uIdx + 35 + 0 ];
		x = data32_4 [ uIndex + 8 ];
		dx.xy = x.zw;

		//C_left.r = data [ uIdx + 36 + 0 ];
		//C_left.g = data [ uIdx + 37 + 0 ];
		//C_left.b = data [ uIdx + 38 + 0 ];
		C_left = data32_4 [ uIndex + 9 ];

		//StartY = data [ uIdx + 39 + 0 ];
		StartY = C_left.w;

		//dC_left.r = data [ uIdx + 40 + 0 ];
		//dC_left.g = data [ uIdx + 41 + 0 ];
		//dC_left.b = data [ uIdx + 42 + 0 ];
		dC_left = data32_4 [ uIndex + 10 ];

		//EndY = data [ uIdx + 43 + 0 ];
		EndY = dC_left.w;

		//T_left.s = data [ uIdx + 44 + 0 ];
		//T_left.t = data [ uIdx + 45 + 0 ];
		//dT_left.s = data [ uIdx + 46 + 0 ];
		//dT_left.t = data [ uIdx + 47 + 0 ];
		T_left = data32_4 [ uIndex + 11 ];
		dT_left.st = T_left.pq;


		//x1.x = data [ uIdx + 32 + 16 ];
		//x1.y = data [ uIdx + 33 + 16 ];
		//dx1.x = data [ uIdx + 34 + 16 ];
		//dx1.y = data [ uIdx + 35 + 16 ];
		x1 = data32_4 [ uIndex + 12 ];
		dx1.xy = x1.zw;

		//C_left1.r = data [ uIdx + 36 + 16 ];
		//C_left1.g = data [ uIdx + 37 + 16 ];
		//C_left1.b = data [ uIdx + 38 + 16 ];
		C_left1 = data32_4 [ uIndex + 13 ];

		//StartY1 = data [ uIdx + 39 + 16 ];
		StartY1 = C_left1.w;

		//dC_left1.r = data [ uIdx + 40 + 16 ];
		//dC_left1.g = data [ uIdx + 41 + 16 ];
		//dC_left1.b = data [ uIdx + 42 + 16 ];
		dC_left1 = data32_4 [ uIndex + 14 ];

		//EndY1 = data [ uIdx + 43 + 16 ];
		EndY1 = dC_left1.w;

		//T_left1.s = data [ uIdx + 44 + 16 ];
		//T_left1.t = data [ uIdx + 45 + 16 ];
		//dT_left1.s = data [ uIdx + 46 + 16 ];
		//dT_left1.t = data [ uIdx + 47 + 16 ];
		T_left1 = data32_4 [ uIndex + 15 ];
		dT_left1.st = T_left1.pq;


	//if ( Command_TGE != 0 )
	//{
	//	color_add = 0x00808080;
	//}




		}	// end if ( subgroupElect() )






#ifdef USE_LOCAL_CLUT
		// load palette if there is one
		if ( subgroupAll( Shift1 != 0 ) )
		{
			// get palette offset
			// ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask )

			count = And2 + 1;
			//for ( idx = int( lxid ); idx < int( count ); idx += int( lxinc ) )
			for ( idx = int( lxid ) << 2; idx < int( count ); idx += int( lxinc ) << 2 )
			{
				//ulocal_data32 [ ( subgroup_id << 8 ) + idx ] = uint( VRAM16 [ ClutOffset + ( ( clut_xoffset + idx ) & c_lFrameBuffer_Width_Mask ) ] );

				ivPtr = ivec4( ( subgroup_local_id << 8 ) + idx + ivec4( 0, 1, 2, 3 ) );
				uvbgr = uvec4( VRAM16_4 [ ( ClutOffset + ( ( clut_xoffset + idx ) & c_lFrameBuffer_Width_Mask ) ) >> 2 ] );
				ulocal_data32 [ ivPtr.x ] = uvbgr.x;
				ulocal_data32 [ ivPtr.y ] = uvbgr.y;
				ulocal_data32 [ ivPtr.z ] = uvbgr.z;
				ulocal_data32 [ ivPtr.w ] = uvbgr.w;

			}
		}
#endif


#ifdef ENABLE_RANGE_DRAW

	// adjust starty (here it is doing inclusive of window start)
	yid = max( StartY, ivDrawRange [ subgroup_local_id ].x ) - StartY;
	//StartY = max( StartY, ivDrawRange [ subgroup_local_id ].x );

	// adjust endy (here it is doing exclusive of window end since it is already exclusive of EndY1)
	EndY1 = min( EndY1, ivDrawRange [ subgroup_local_id ].y );

	// get height for subgroup (exclusive of EndY1)
	sh = EndY1 - StartY - yid;

#else
		yid = int( ( subgroup_global_id - StartY ) & subgroup_mask );

		// h - total height
		h = EndY1 - StartY;
	
		// sh - height for subgroup
		sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );
#endif

#ifdef ENABLE_TRIANGLE_SUBGROUP_SKIP

		// if nothing to draw, then done
		if ( subgroupAll( sh < 0 ) )
		{
			return;
		}

#endif

		idx = int( lxid ) << 2;
		idx4 = idx + ivec4( 0, 1, 2, 3 );
		xid = idx & SHADER_X_MASK;
		vxid = idx4 & SHADER_X_MASK;

		// number of pixels to go across is number of pixels being drawn across
		iXInc = SHADER_X_MASK + 1;

#ifdef ENABLE_RANGE_DRAW

		yoffset = ( idx >> SHADER_Y_SHIFT ) + yid;

		// the amount to loop down is the number of shader lines being drawn times global shader groups
		iYInc = ( int( lxinc << 2 ) >> SHADER_Y_SHIFT );
#else
		yoffset = ( idx >> SHADER_Y_SHIFT ) << subgroup_shift;
		yoffset = yoffset + yid;

		// the amount to loop down is the number of shader lines being drawn times global shader groups
		iYInc = ( int( lxinc << 2 ) >> SHADER_Y_SHIFT ) << subgroup_shift;
#endif

		//dCx_across.rgb = dC_across.rgb * iXInc;
		dTx_across.st = dT_across.st * iXInc;

		//dR_across = dC_across.r * vxid;
		//dG_across = dC_across.g * vxid;
		//dB_across = dC_across.b * vxid;

		dU_across = dT_across.s * vxid;
		dV_across = dT_across.t * vxid;


		ivRedC = ivec4( bitfieldExtract( bgr32, 0, 8 ) );
		ivGreenC = ivec4( bitfieldExtract( bgr32, 8, 8 ) );
		ivBlueC = ivec4( bitfieldExtract( bgr32, 16, 8 ) );

		//for ( uLoop = ((yoffset + StartY) < EndY) ? 0 : 16; uLoop < iLoopMax; uLoop += 16 )
		{


	//////////////////////////////////////////////
	// draw down to y1
	for ( Line = StartY + yoffset; Line < EndY1; Line += iYInc )
	{
		if ( Line >= StartY1 )
		{
			StartY = StartY1;
			EndY = EndY1;

			x = x1;
			dx = dx1;
			//C_left = C_left1;
			//dC_left = dC_left1;
			T_left = T_left1;
			dT_left = dT_left1;
				
		}

		yoffset = Line - StartY;

		//xoff.xy = x.xy + ( dx.xy * (yid) );
		xoff.xy = x.xy + ( dx.xy * (yoffset) );
	
		//Coff_left.rgb = C_left.rgb + ( dC_left.rgb * (yid) );
		//Coff_left.rgb = C_left.rgb + ( dC_left.rgb * (yoffset) );
	
		//Toff_left.st = T_left.st + ( dT_left.st * (yid) );
		Toff_left.st = T_left.st + ( dT_left.st * (yoffset) );


		// left point is included if points are equal
		iStartX = ( xoff.x + 0xffff ) >> 16;
		iEndX = ( xoff.y - 1 ) >> 16;
		
		
		//if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		{
			ivEnable = ivec4( iStartX <= DrawArea_BottomRightX ) & ivec4( iEndX >= DrawArea_TopLeftX ) & ivec4( iEndX >= iStartX );

			//iC.rgb = Coff_left.rgb;
			
			iT.st = Toff_left.st;
			
			// get the difference between x_left and StartX
			Temp = ( iStartX << 16 ) - xoff.x;
			
			//if ( iStartX < DrawArea_TopLeftX )
			//{
			//	Temp += ( DrawArea_TopLeftX - iStartX ) << 16;
			//	iStartX = DrawArea_TopLeftX;
			//}
			Temp += ( DrawArea_TopLeftX - min( iStartX, DrawArea_TopLeftX ) ) << 16;
			iStartX = max( iStartX, DrawArea_TopLeftX );
			
			//iC.rgb += ( dC_across.rgb >> 8 ) * ( Temp >> 8 );
			
			iT.st += ( dT_across.st >> 8 ) * ( Temp >> 8 );
			
			//if ( iEndX > DrawArea_BottomRightX )
			//{
			//	//EndX = DrawArea_BottomRightX + 1;
			//	iEndX = DrawArea_BottomRightX;
			//}
			iEndX = min( iEndX, DrawArea_BottomRightX );


			w = iEndX - iStartX + 1;

			

			//ivPtr = ( iStartX + vxid ) + ( Line << 10 );

			//ivR = iC.r + ( dC_across.r * vxid );
			//ivG = iC.g + ( dC_across.g * vxid );
			//ivB = iC.b + ( dC_across.b * vxid );
			//ivR = iC.r + dR_across;
			//ivG = iC.g + dG_across;
			//ivB = iC.b + dB_across;

			//ivU = iT.s + ( dT_across.s * vxid );
			//ivV = iT.t + ( dT_across.t * vxid );
			ivU = iT.s + dU_across;
			ivV = iT.t + dV_across;



			
			// set bgr in case not a texture
			//uvbgr = uvec4( 0xffff );
			
			// draw horizontal line
			vx_across = vxid;
			for ( x_across = xid; x_across < w; x_across += iXInc )
			{

				// check what pixels are enabled
				bvEnable = bvec4( ivec4( lessThan( uvec4( vx_across ), uvec4( w ) ) ) & ivEnable );

				// might want to wrap pixels around framebuffer ?
				ivPtr = ( iStartX + vx_across ) + ( Line << 10 );


				// dest pixels //

				// read pixel from frame buffer if we need to check mask bit


#ifdef ENABLE_BUFFER_READ

				uvDestPixel.x = uint( VRAM16 [ ivPtr.x ] );
				uvDestPixel.y = uint( VRAM16 [ ivPtr.y ] );
				uvDestPixel.z = uint( VRAM16 [ ivPtr.z ] );
				uvDestPixel.w = uint( VRAM16 [ ivPtr.w ] );

#endif

				//ivRedF = ivec4( 0x10 );
				//ivGreenF = ivec4( 0x10 );
				//ivBlueF = ivec4( 0x10 );

				// texture mapping //

				//if ( subgroupAll( bTexture != 0 ) )
				{
				//TexCoordY = ( ( ( iV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				//TexCoordY <<= 10;
				//TexCoordX = ( ( ( iU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				ivTexCoordY = ( ( ( ivV >> 16 ) & Not_TWH ) | ( TWYTWH ) ) & 0xff;
				ivTexCoordY <<= 10;
				ivTexCoordX = ( ( ( ivU >> 16 ) & Not_TWW ) | ( TWXTWW ) ) & 0xff;
				
				// x-component should be shifted right 1 again since 2 pixels per?
				//bgr = ptr_texture [ ( TexCoordX >> Shift1 ) + TexCoordY ];
				//bgr = VRAM [ TextureOffset + ( TexCoordX >> Shift1 ) + TexCoordY ];
				ivIndex = TextureOffset + ( ivTexCoordX >> Shift1 ) + ivTexCoordY;

#ifdef ENABLE_BUFFER_READ

				uvbgr.x = uint( VRAM16 [ ivIndex.x ] );
				uvbgr.y = uint( VRAM16 [ ivIndex.y ] );
				uvbgr.z = uint( VRAM16 [ ivIndex.z ] );
				uvbgr.w = uint( VRAM16 [ ivIndex.w ] );

#endif


#ifdef USE_MORE_JUMPS
				if ( subgroupAll( Shift1 != 0 ) )
#endif
				{
					//if ( Shift1 != 0 )
					//{
					//	//bgr = ptr_clut [ ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ];
					//	bgr = VRAM [ ClutOffset + ( ( clut_xoffset + ( ( bgr >> ( ( TexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask ) ];
					//}

#ifdef USE_LOCAL_CLUT
					ivIndex = ivec4( ( subgroup_local_id << 8 ) + ( ( ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) ) );
					uvbgr2.x = ulocal_data32 [ ivIndex.x ];
					uvbgr2.y = ulocal_data32 [ ivIndex.y ];
					uvbgr2.z = ulocal_data32 [ ivIndex.z ];
					uvbgr2.w = ulocal_data32 [ ivIndex.w ];

#else

					ivIndex = ClutOffset + ( ( clut_xoffset + ( ( ivec4( uvbgr ) >> ( ( ivTexCoordX & And1 ) << Shift2 ) ) & And2 ) ) & c_lFrameBuffer_Width_Mask );

#ifdef ENABLE_BUFFER_READ
					uvbgr2.x = uint( VRAM16 [ ivIndex.x ] );
					uvbgr2.y = uint( VRAM16 [ ivIndex.y ] );
					uvbgr2.z = uint( VRAM16 [ ivIndex.z ] );
					uvbgr2.w = uint( VRAM16 [ ivIndex.w ] );
#endif

#endif

					uvbgr = ( Shift1 != 0 ) ? uvbgr2 : uvbgr;

				}	// end if ( subgroupAll( Shift1 != 0 ) )
				
				//ivRedF = ivec4( uvbgr >> 0 ) & 0x1f;
				//ivGreenF = ivec4( uvbgr >> 5 ) & 0x1f;
				//ivBlueF = ivec4( uvbgr >> 10 ) & 0x1f;
				ivRedF = ivec4( bitfieldExtract( uvbgr, 0, 5 ) );
				ivGreenF = ivec4( bitfieldExtract( uvbgr, 5, 5 ) );
				ivBlueF = ivec4( bitfieldExtract( uvbgr, 10, 5 ) );

				}	// end if ( subgroupAll( bTexture != 0 ) )


				// color gradient //

				// shade pixel color
					
					
				//bgr_temp = bgr;


#ifdef USE_MORE_JUMPS
				if ( subgroupAll( Command_TGE == 0 ) )
#endif
				{
					// perform shift
					//ivRedC >>= ( 16 );
					//ivGreenC >>= ( 16 );
					//ivBlueC >>= ( 16 );

					ivRedF = clamp( ( ivRedC * ivRedF ) >> 7, 0, 31 );
					ivGreenF = clamp( ( ivGreenC * ivGreenF ) >> 7, 0, 31 );
					ivBlueF = clamp( ( ivBlueC * ivBlueF ) >> 7, 0, 31 );

				}	// end if ( subgroupAll( Command_TGE == 0 ) )


				// blending //

#ifdef USE_MORE_JUMPS
				if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )
#endif
				{

					// semi-transparency
					//if ( ( Command_ABE != 0 ) && ( ( bgr & 0x8000 ) != 0 ) )
					//{
					//	bgr_temp = SemiTransparency16 ( DestPixel, bgr_temp, tpage_abr );
					//}
					//ivRedB = ivec4( uvDestPixel >> 0 ) & 0x1f;
					//ivGreenB = ivec4( uvDestPixel >> 5 ) & 0x1f;
					//ivBlueB = ivec4( uvDestPixel >> 10 ) & 0x1f;
					ivRedB = ivec4( bitfieldExtract( uvDestPixel, 0, 5 ) );
					ivGreenB = ivec4( bitfieldExtract( uvDestPixel, 5, 5 ) );
					ivBlueB = ivec4( bitfieldExtract( uvDestPixel, 10, 5 ) );

					ivRedB = ( ivRedB >> iBShift ) + ( ( ( ivRedF >> iFShift ) ^ iFSign ) - iFSign );
					ivGreenB = ( ivGreenB >> iBShift ) + ( ( ( ivGreenF >> iFShift ) ^ iFSign ) - iFSign );
					ivBlueB = ( ivBlueB >> iBShift ) + ( ( ( ivBlueF >> iFShift ) ^ iFSign ) - iFSign );

					ivRedF = clamp( ivRedB, 0, 0x1f );
					ivGreenF = clamp( ivGreenB, 0, 0x1f );
					ivBlueF = clamp( ivBlueB, 0, 0x1f );

				}	// end if ( ( Command_ABE != 0 ) && any( notEqual( uvbgr & 0x8000, vZero ) ) )


				//uvbgr_temp = uvec4( ( ivRedF << 0 ) | ( ivGreenF << 5 ) | ( ivBlueF << 10 ) );
				uvbgr_temp = uvec4( bitfieldInsert( bitfieldInsert( ivRedF, ivGreenF, 5, 5 ), ivBlueF, 10, 5 ) );


				//if ( subgroupAll( bTexture != 0 ) )
				{

				// no need to select based on command_abe since can just set shift to 16 and sign to zero
				uvbgr_temp = mix( uvbgr_temp, uvbgr, equal( uvbgr & 0x8000, vZero ) );
					
				// check if we should set mask bit when drawing
				//bgr_temp |= SetPixelMask | ( bgr & 0x8000 );
				uvbgr_temp |= ( uvbgr & 0x8000 );

				}	// end if ( subgroupAll( bTexture != 0 ) )


				uvbgr_temp |= SetPixelMask;


				// select pixels to draw //

				// only draw pixel if not key color (zero)
				uvbgr_temp = mix( uvbgr_temp, uvDestPixel, equal( uvbgr, vZero ) );

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp;
				// draw pixel if we can draw to mask pixels or mask bit not set
				//DestPixel = ( ( DestPixel & PixelMask ) == 0 ) ? bgr_temp : DestPixel;
				uvbgr_temp = mix( uvDestPixel, uvbgr_temp, equal( ( uvDestPixel & PixelMask ), vZero ) );

				// only enabled pixels should be active
				uvDestPixel = mix( uvDestPixel, uvbgr_temp, bvEnable );


				// draw/store pixels //

				// draw pixel if we can draw to mask pixels or mask bit not set
				//if ( ! ( DestPixel & PixelMask ) ) *ptr = bgr_temp | SetPixelMask | ( bgr & 0x8000 );
				//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = bgr_temp | SetPixelMask | ( bgr & 0x8000 );

				// store pixels //

#ifdef ENABLE_BUFFER_WRITE

				VRAM16 [ ivPtr.x ] = uint16_t( uvDestPixel.x );
				VRAM16 [ ivPtr.y ] = uint16_t( uvDestPixel.y );
				VRAM16 [ ivPtr.z ] = uint16_t( uvDestPixel.z );
				VRAM16 [ ivPtr.w ] = uint16_t( uvDestPixel.w );

#endif

				
				//ivR += ( dCx_across.r );
				//ivG += ( dCx_across.g );
				//ivB += ( dCx_across.b );
			
				ivU += ( dTx_across.s );
				ivV += ( dTx_across.t );
					
				//ivPtr += iXInc;
				vx_across += iXInc;
				
				
			}	// end for ( vx_across = vxid; any( lessThan( uvec4( vx_across ), uvec4( w ) ) ); vx_across += group_vxinc )

			
			
		}	// end if ( iStartX <= DrawArea_BottomRightX && iEndX >= DrawArea_TopLeftX && iEndX >= iStartX )
		

	}	// end for ( Line = StartY + yid; Line < EndY; Line += group_vyinc )


	}	// for ( uLoop = 0; uLoop < 32; uLoop += 16 )

	

	
	////////////////////////////////////////////////
	// draw bottom part of triangle

	/////////////////////////////////////////////
	// init x on the left and right
	

	}	// end if ( bDraw == 1 )


#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( ( Comm >= 0x34 && Comm <= 0x37 ) || ( Comm >= 0x3c && Comm <= 0x3f ) ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}






#ifdef ENABLE_PRIMITIVE_LOOP
uint Transfer_MoveImage_80 ( uint uIndex )
#else
void Transfer_MoveImage_80 ( uint uIndex )
#endif
{
	// note: this xxid is needed for synchronization across workgroups
	int xxid = int( gl_LocalInvocationIndex );

	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	uint CurBarrierSync;
	//uint NextBarrierSync;

	//int xid = int( gl_GlobalInvocationID.x );
	//int yid = int( gl_GlobalInvocationID.y );
	int yid;

	uint SrcPixel, DstPixel;
	uint DestPixel;
	
	int CurX, CurY;
	int iSrcPtr;
	int iDstPtr;
	int iSrcLinePtr;
	int iDstLinePtr;


	uvec4 SrcPixel4, DstPixel4;
	ivec4 idx4;
	ivec4 CurX4, CurY4;
	ivec4 iSrcPtr4;
	ivec4 iDstPtr4;
	ivec4 iSrcLinePtr4;
	ivec4 iDstLinePtr4;


	uint GPU_CTRL_Read;
	int w;
	int h;
	int Width;
	int Height;
	int sX;
	int sY;
	int dX;
	int dY;

	int bOverlap;

	uint PixelMask;
	uint SetPixelMask;
	int SrcStartX;
	int DstStartX;
	int SrcStartY;
	int DstStartY;

	int SrcEndX;
	int SrcEndY;
	int DstEndX;
	int DstEndY;

	int idx, count;
	int yid2;
	int sh;

	uint Comm;
	
	//if ( (xid + yid) == 0 )
	//{
		uIndex <<= 4;

#ifdef ENABLE_PRIMITIVE_LOOP
	do
	{
#endif

		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		w = int( inputdata [ uIndex + 10 ] );
		h = w >> 16;

		// Xsiz=((Xsiz-1) AND 3FFh)+1
		Width = ( ( w - 1 ) & 0x3ff ) + 1;
		
		// Ysiz=((Ysiz-1) AND 1FFh)+1
		Height = ( ( h - 1 ) & 0x1ff ) + 1;

		
		sX = int( inputdata [ uIndex + 8 ] );
		sY = sX >> 16;
		dX = int( inputdata [ uIndex + 9 ] );
		dY = dX >> 16;

		// nocash psx specifications: transfer/move vram-to-vram use masking
		// ME is bit 12
		//if ( GPU_CTRL_Read.ME ) PixelMask = 0x8000;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		//if ( GPU_CTRL_Read.MD ) SetPixelMask = 0x8000;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;
		
		// xpos & 0x3ff
		//sX &= 0x3ff;
		SrcStartX = sX & 0x3ff;
		//dX &= 0x3ff;
		DstStartX = dX & 0x3ff;
		
		// ypos & 0x1ff
		//sY &= 0x1ff;
		SrcStartY = sY & 0x1ff;
		//dY &= 0x1ff;
		DstStartY = dY & 0x1ff;
		

		count = Width * Height;


#ifdef USE_NEW_SCANLINE_DRAW_MOVE
		// get yoffset to draw at from starting point
		yid = int( ( subgroup_global_id - SrcStartY ) & subgroup_mask );
		yid2 = int( ( subgroup_global_id - DstStartY ) & subgroup_mask );
#endif

		
		// *** NOTE: coordinates wrap *** //
		

		// check for over lap
		SrcEndX = SrcStartX + Width;
		SrcEndY = SrcStartY + Height;
		DstEndX = DstStartX + Width;
		DstEndY = DstStartY + Height;

		bOverlap = 1;
		if ( DstStartX >= SrcEndX || DstEndX <= SrcStartX || DstStartY >= SrcEndY || DstEndY <= DstStartY )
		{
			bOverlap = 0;
		}
	
	//}

	
#ifdef SYNC_BEFORE_MOVE

	barrier ();

#endif




#ifdef ENABLE_MOVE_OVERLAP_SKIP

#ifdef USE_NEW_SCANLINE_DRAW_MOVE
	if ( subgroupAll( yid == yid2 ) )
#else
	if ( subgroupAll( bOverlap == 0 ) )
#endif
	{
#ifdef USE_NEW_SCANLINE_DRAW_MOVE

		// h - total height
		//h = EndY - StartY;
	
		// sh - height for subgroup
		sh = int( Height >> subgroup_shift ) + max( sign( int( Height & subgroup_mask ) - yid ), 0 );

#ifdef ENABLE_MOVE_SUBGROUP_SKIP
		// if nothing to move and no overlap, then done
		if ( subgroupAll( sh <= 0 ) )
		{
			return;
		}
#endif

		// count - count of pixels to draw for the subgroup
		count = Width * sh;

		for ( idx = int( lxid << 2 ); idx < count; idx += int( lxinc << 2 ) )
#else
		for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
#endif
		{
			idx4 = idx + ivec4( 0, 1, 2, 3 );

			CurX4 = idx4 % Width;
			CurY4 = idx4 / Width;

#ifdef USE_NEW_SCANLINE_DRAW_MOVE
			CurY4 = ( CurY4 << subgroup_shift ) + yid;
#endif

			iSrcLinePtr4 = ( ( SrcStartY + CurY4 ) & c_lFrameBuffer_Height_Mask ) << 10;
			iDstLinePtr4 = ( ( DstStartY + CurY4 ) & c_lFrameBuffer_Height_Mask ) << 10;

			iSrcPtr4 = iSrcLinePtr4 + ( ( SrcStartX + CurX4 ) & c_lFrameBuffer_Width_Mask );
			iDstPtr4 = iDstLinePtr4 + ( ( DstStartX + CurX4 ) & c_lFrameBuffer_Width_Mask );

			SrcPixel4.x = uint( VRAM16 [ iSrcPtr4.x ] );
			SrcPixel4.y = uint( VRAM16 [ iSrcPtr4.y ] );
			SrcPixel4.z = uint( VRAM16 [ iSrcPtr4.z ] );
			SrcPixel4.w = uint( VRAM16 [ iSrcPtr4.w ] );

			DstPixel4.x = uint( VRAM16 [ iDstPtr4.x ] );
			DstPixel4.y = uint( VRAM16 [ iDstPtr4.y ] );
			DstPixel4.z = uint( VRAM16 [ iDstPtr4.z ] );
			DstPixel4.w = uint( VRAM16 [ iDstPtr4.w ] );

			SrcPixel4 |= SetPixelMask;

			SrcPixel4 = mix( DstPixel4, SrcPixel4, equal( DstPixel4 & PixelMask, uvec4( 0 ) ) );

			// in addition, need to make sure idx < count
			SrcPixel4 = mix( DstPixel4, SrcPixel4, lessThan( idx4, ivec4( count ) ) );

			VRAM16 [ iDstPtr4.x ] = uint16_t( SrcPixel4.x );
			VRAM16 [ iDstPtr4.y ] = uint16_t( SrcPixel4.y );
			VRAM16 [ iDstPtr4.z ] = uint16_t( SrcPixel4.z );
			VRAM16 [ iDstPtr4.w ] = uint16_t( SrcPixel4.w );

		}
	}
	else
#endif	// end #ifdef ENABLE_MOVE_OVERLAP_SKIP
	{
	
#ifdef USE_NEW_SCANLINE_DRAW_MOVE

	// sh - height for subgroup
	sh = int( Height >> subgroup_shift ) + max( sign( int( Height & subgroup_mask ) - yid ), 0 );

	// count - count of pixels to draw for the subgroup
	count = Width * sh;

	// note: there is some type of overlap here so there is a barrier, so unable to skip

	for ( idx = int( lxid << 2 ); idx < count; idx += int( lxinc << 2 ) )
#else
	for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
#endif
	{
		idx4 = idx + ivec4( 0, 1, 2, 3 );

		CurX4 = idx4 % Width;
		CurY4 = idx4 / Width;

#ifdef USE_NEW_SCANLINE_DRAW_MOVE
		CurY4 = ( CurY4 << subgroup_shift ) + yid;
#endif

		iSrcLinePtr4 = ( ( SrcStartY + CurY4 ) & c_lFrameBuffer_Height_Mask ) << 10;
		iDstLinePtr4 = ( ( DstStartY + CurY4 ) & c_lFrameBuffer_Height_Mask ) << 10;

		iSrcPtr4 = iSrcLinePtr4 + ( ( SrcStartX + CurX4 ) & c_lFrameBuffer_Width_Mask );
		iDstPtr4 = iDstLinePtr4 + ( ( DstStartX + CurX4 ) & c_lFrameBuffer_Width_Mask );

		sVRAM16 [ iDstPtr4.x ] = VRAM16 [ iSrcPtr4.x ];
		sVRAM16 [ iDstPtr4.y ] = VRAM16 [ iSrcPtr4.y ];
		sVRAM16 [ iDstPtr4.z ] = VRAM16 [ iSrcPtr4.z ];
		sVRAM16 [ iDstPtr4.w ] = VRAM16 [ iSrcPtr4.w ];
	}

#ifdef USE_MEMORY_BARRIER_BUFFER

	memoryBarrierBuffer ();
	memoryBarrierShared ();
	groupMemoryBarrier ();
	memoryBarrier ();

#endif

#ifdef ENABLE_MULTIPLE_WORKGROUPS

	// need to do subgroupElect because all subgroups need to synchronize globally before they synchronize locally
	if ( subgroupElect() )
	{

		// count global subgroups that have completed the work
		CurBarrierSync = atomicAdd( auCounter, 1 );
		//atomicAdd( auCounter, 1 );

		// only need the first shader of the entire workgroup to spin wait though
		if ( xxid == 0 )
		{
			CurBarrierSync++;

			// would probably need to be a less than comparison due to possible race conditions
			//while ( atomicAdd( auCounter, 0 ) < NextBarrierSync )
			while ( CurBarrierSync < NextBarrierSync )
			{
				//CurBarrierSync = atomicAdd( auCounter, 0 );
				CurBarrierSync = atomicCompSwap( auCounter, 0, 0 );
			}
		
			// at the next sync point, need all subgroups
			NextBarrierSync += subgroup_global_count;

		}	// end if ( xxid == 0 )

	}	// end if ( subgroupElect() )

#endif	// end ENABLE_MULTIPLE_WORKGROUPS

	// this barrier needs to work across multiple workgroups
	barrier ();




#ifdef USE_NEW_SCANLINE_DRAW_MOVE

	// sh - height for subgroup
	sh = int( Height >> subgroup_shift ) + max( sign( int( Height & subgroup_mask ) - yid2 ), 0 );

	// count - count of pixels to draw for the subgroup
	count = Width * sh;

	for ( idx = int( lxid << 2 ); idx < count; idx += int( lxinc << 2 ) )
#else
	for ( idx = xxid << 2; idx < count; idx += xxinc << 2 )
#endif
	{
		idx4 = idx + ivec4( 0, 1, 2, 3 );

		CurX4 = idx4 % Width;
		CurY4 = idx4 / Width;

#ifdef USE_NEW_SCANLINE_DRAW_MOVE
		CurY4 = ( CurY4 << subgroup_shift ) + yid2;
#endif

		iDstLinePtr4 = ( ( DstStartY + CurY4 ) & c_lFrameBuffer_Height_Mask ) << 10;

		iDstPtr4 = iDstLinePtr4 + ( ( DstStartX + CurX4 ) & c_lFrameBuffer_Width_Mask );

		SrcPixel4.x = uint( sVRAM16 [ iDstPtr4.x ] );
		SrcPixel4.y = uint( sVRAM16 [ iDstPtr4.y ] );
		SrcPixel4.z = uint( sVRAM16 [ iDstPtr4.z ] );
		SrcPixel4.w = uint( sVRAM16 [ iDstPtr4.w ] );

		DstPixel4.x = uint( VRAM16 [ iDstPtr4.x ] );
		DstPixel4.y = uint( VRAM16 [ iDstPtr4.y ] );
		DstPixel4.z = uint( VRAM16 [ iDstPtr4.z ] );
		DstPixel4.w = uint( VRAM16 [ iDstPtr4.w ] );

		SrcPixel4 |= SetPixelMask;

		SrcPixel4 = mix( DstPixel4, SrcPixel4, equal( DstPixel4 & PixelMask, uvec4( 0 ) ) );

		// in addition, need to make sure idx < count
		SrcPixel4 = mix( DstPixel4, SrcPixel4, lessThan( idx4, ivec4( count ) ) );

		VRAM16 [ iDstPtr4.x ] = uint16_t( SrcPixel4.x );
		VRAM16 [ iDstPtr4.y ] = uint16_t( SrcPixel4.y );
		VRAM16 [ iDstPtr4.z ] = uint16_t( SrcPixel4.z );
		VRAM16 [ iDstPtr4.w ] = uint16_t( SrcPixel4.w );
	}

	}
	


	//}	// end if local_id

#ifdef ENABLE_PRIMITIVE_LOOP
		uIndex += 16;
		Comm = inputdata [ uIndex + 7 ] >> 24;
	} while ( ( Comm == 0x80 ) && ( uIndex < ( ( 1 << 16 ) << 4 ) ) );
#endif


#ifdef SYNC_AFTER_MOVE

	// this need to be complete first before proceeding
	barrier ();

#endif

#ifdef ENABLE_PRIMITIVE_LOOP
	return ( uIndex >> 4 ) - 1;
#else
	return;
#endif
}







void TransferPixelPacketIn ( uint uIndex )
{
	int xxid = int( gl_LocalInvocationIndex );

	uint lxid = gl_SubgroupInvocationID;
	uint lxinc = subgroup_size;

	uint subgroup_local_id = gl_SubgroupID;
	uint subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );

	//int xid = int( gl_GlobalInvocationID.x );
	//int yid = int( gl_GlobalInvocationID.y );
	

	int yid;

	uint bgr2;
	uint pix0, pix1;
	uint DestPixel;
	uint Data;


	
	//int iX, iY;
	int CurX, CurY;

	int iPtr;
	int iCount;
	
	int xxpixel;
	int xximagepixel;

	ivec4 idx4;
	uvec4 pix4;
	uvec4 DestPixel4;
	ivec4 CurX4, CurY4;
	ivec4 iPtr4;
	ivec4 xximagepixel4;

	ivec4 pidx4;

	uint GPU_CTRL_Read;
	int dX;
	int dY;
	int w;
	int h;
	int sX;
	int sY;
	
	int BS;

	uint uStartIndex;

	uint uStartCount;
	uint uTotalCount;

	int xximagepixelstart;
	uint PixelMask;
	uint SetPixelMask;
	uint Comm;

	int sh;
	int idx, count;


	uIndex <<= 4;

	
	//if ( xxid == 0 )
	//{

		//Count = 0;

		GPU_CTRL_Read = inputdata [ uIndex + 0 ];
		dX = int( inputdata [ uIndex + 1 ] );
		dY = int( inputdata [ uIndex + 2 ] );
		w = int( inputdata [ uIndex + 3 ] );
		h = int( inputdata [ uIndex + 4 ] );
		//iX = int( inputdata [ uIndex + 5 ] );
		//iY = int( inputdata [ uIndex + 6 ] );
		sX = int( inputdata [ uIndex + 5 ] );
		sY = int( inputdata [ uIndex + 6 ] );
		
		BS = int( inputdata [ uIndex + 7 ] & 0xf );

		// count is per 2 pixels
		BS <<= 1;
		
		xximagepixelstart = sX + sY * w;

		// nocash psx specifications: transfer/move vram-to-vram use masking
		// ME is bit 12
		//if ( GPU_CTRL_Read.ME ) PixelMask = 0x8000;
		PixelMask = ( GPU_CTRL_Read & 0x1000 ) << 3;
		
		// MD is bit 11
		//if ( GPU_CTRL_Read.MD ) SetPixelMask = 0x8000;
		SetPixelMask = ( GPU_CTRL_Read & 0x0800 ) << 4;


		uStartIndex = inputdata [ uIndex + 9 ];

		BS = int( inputdata [ uIndex + 10 ] );

		// count is per 2 pixels
		BS <<= 1;



#ifdef SYNC_BEFORE_TRANSFER

	barrier ();

#endif


#ifdef USE_NEW_SCANLINE_DRAW_TRANSFER

	// get yoffset to draw at from starting point
	yid = int( ( subgroup_global_id - dY ) & subgroup_mask );

	// h - total height
	//h = EndY - StartY;
	
	// sh - height for subgroup
	sh = int( h >> subgroup_shift ) + max( sign( int( h & subgroup_mask ) - yid ), 0 );

#ifdef ENABLE_TRANSFER_SUBGROUP_SKIP
	// if nothing to transfer, then done
	if ( subgroupAll( sh <= 0 ) )
	{
		return;
	}
#endif

	// count - count of pixels to draw for the subgroup
	count = w * sh;

	uStartCount = sX + ( sY * w );
	uTotalCount = w * h;

	for ( idx = int( lxid << 2 ); idx < count; idx += int( lxinc << 2 ) )
	{
		idx4 = idx + ivec4( 0, 1, 2, 3 );
		CurX4 = idx4 % w;
		CurY4 = idx4 / w;
		
		CurY4 = ( CurY4 << subgroup_shift ) + yid;

		// get the true pixel count we are on in the entire transfer
		idx4 = CurX4 + ( CurY4 * w );

		// get the index for the pixel
		pidx4 = idx4 - ivec4( uStartCount );

		//pix4.x = PixelInput32 [ uStartIndex + ( idx4.x >> 1 ) ];
		//pix4.y = PixelInput32 [ uStartIndex + ( idx4.y >> 1 ) ];
		//pix4.z = PixelInput32 [ uStartIndex + ( idx4.z >> 1 ) ];
		//pix4.w = PixelInput32 [ uStartIndex + ( idx4.w >> 1 ) ];
		pix4.x = PixelInput32 [ ( uStartIndex + ( pidx4.x >> 1 ) ) & PIXEL_INPUT_MASK32 ];
		pix4.y = PixelInput32 [ ( uStartIndex + ( pidx4.y >> 1 ) ) & PIXEL_INPUT_MASK32 ];
		pix4.z = PixelInput32 [ ( uStartIndex + ( pidx4.z >> 1 ) ) & PIXEL_INPUT_MASK32 ];
		pix4.w = PixelInput32 [ ( uStartIndex + ( pidx4.w >> 1 ) ) & PIXEL_INPUT_MASK32 ];

		pix4 >>= ( ( pidx4 & 1 ) << 4 );
		pix4 &= 0xffff;

		pix4 |= SetPixelMask;

		iPtr4 = ( ( dX + CurX4 ) & 0x3ff ) + ( ( ( dY + CurY4 ) & 0x1ff ) << 10 );

		DestPixel4.x = uint( VRAM16[ iPtr4.x ] );
		DestPixel4.y = uint( VRAM16[ iPtr4.y ] );
		DestPixel4.z = uint( VRAM16[ iPtr4.z ] );
		DestPixel4.w = uint( VRAM16[ iPtr4.w ] );

		pix4 = mix( DestPixel4, pix4, equal( DestPixel4 & PixelMask, uvec4( 0 ) ) );

		// make sure we don't transfer more pixels than in the transfer
		pix4 = mix( DestPixel4, pix4, lessThan( uvec4( pidx4 ), uvec4( BS ) ) );

		// in addition, need to make sure iCount < number of pixels in the image
		pix4 = mix( DestPixel4, pix4, lessThan( idx4, ivec4( uTotalCount ) ) );

		// also make sure that the pixels are past or equal to the starting count (like if it is a partial transfer)
		//pix4 = mix( DestPixel4, pix4, greaterThanEqual( idx4, ivec4( uStartCount ) ) );

		// write back pixels
		VRAM16[ iPtr4.x ] = uint16_t( pix4.x );
		VRAM16[ iPtr4.y ] = uint16_t( pix4.y );
		VRAM16[ iPtr4.z ] = uint16_t( pix4.z );
		VRAM16[ iPtr4.w ] = uint16_t( pix4.w );
	}

#else

#ifdef USE_NEW_TRANSFER4
	for ( iCount = xxid << 2; iCount < BS; iCount += xxinc << 2 )
#else
	for ( iCount = xxid; iCount < BS; iCount += xxinc )
#endif
	{
#ifdef USE_NEW_TRANSFER4


		pix4.x = PixelInput32 [ uStartIndex + ( iCount >> 1 ) ];
		pix4.z = PixelInput32 [ uStartIndex + ( iCount >> 1 ) + 1 ];
		pix4.yw = ( pix4.xz >> 16 );
		pix4 |= SetPixelMask;

		idx4 = iCount + ivec4( 0, 1, 2, 3 );
		xximagepixel4 = idx4 + xximagepixelstart;

		CurX4 = xximagepixel4 % w;
		CurY4 = xximagepixel4 / w;

		iPtr4 = ( ( dX + CurX4 ) & 0x3ff ) + ( ( ( dY + CurY4 ) & 0x1ff ) << 10 );

		DestPixel4.x = uint( VRAM16[ iPtr4.x ] );
		DestPixel4.y = uint( VRAM16[ iPtr4.y ] );
		DestPixel4.z = uint( VRAM16[ iPtr4.z ] );
		DestPixel4.w = uint( VRAM16[ iPtr4.w ] );

		pix4 = mix( DestPixel4, pix4, equal( DestPixel4 & PixelMask, uvec4( 0 ) ) );

		// in addition, need to make sure iCount < BS
		pix4 = mix( DestPixel4, pix4, lessThan( idx4, ivec4( BS ) ) );

		// write back pixels
		VRAM16[ iPtr4.x ] = uint16_t( pix4.x );
		VRAM16[ iPtr4.y ] = uint16_t( pix4.y );
		VRAM16[ iPtr4.z ] = uint16_t( pix4.z );
		VRAM16[ iPtr4.w ] = uint16_t( pix4.w );

#else

		//pix0 = inputdata [ uIndex + ( iCount & ~0xf ) + 8 + ( ( iCount & 0xf ) >> 1 ) ];
		pix0 = PixelInput32 [ uStartIndex + ( iCount >> 1 ) ];
		pix0 = ( pix0 >> ( ( iCount & 1 ) << 4 ) ) & 0xffff;
		pix0 |= SetPixelMask;

		// need the pixel count in the image ( sX + sY * w )
		xximagepixel = iCount + xximagepixelstart;

		CurX = xximagepixel % w;
		CurY = xximagepixel / w;

		iPtr = ( (dX + CurX) & 0x3ff ) + ( ( (dY + CurY) & 0x1ff ) << 10 );

		DestPixel = uint( VRAM16 [ iPtr ] );

		//if ( ( DestPixel & PixelMask ) == 0 ) VRAM [ iPtr ] = ( pix0 | SetPixelMask );
		VRAM16 [ iPtr ] = uint16_t( ( ( DestPixel & PixelMask ) == 0 ) ? pix0 : DestPixel );

#endif

	}

#endif	// end #ifdef USE_NEW_SCANLINE_DRAW_TRANSFER


#ifdef SYNC_AFTER_TRANSFER

	// this needs to be complete before proceeding
	barrier ();

#endif

	
	return;
}





void main ()
{
	uint uIdx;
	uint uIdx2;
	uint uCommand;
	uint uIndex;

	//uint subgroup_local_count, subgroup_global_count;
	uint subgroup_id;
	uint workgroup_id;

	uint CurBarrierSync;

	uint uStartIdx, uEndIdx;


	// sometimes want to arrange things in the x direction only
	uint xxid = gl_LocalInvocationIndex;

	// global invocation index
	int gxxid;


	//uint xid = gl_GlobalInvocationID.x;
	//uint yid = gl_GlobalInvocationID.y;


	// variables for drawing //

	//uint uIdx;

	// local subgroup invocation id and increment
	uint lxid, lxinc;

	// local and global subgroup id
	uint subgroup_local_id, subgroup_global_id;

	int yid;


	//int x, y;
	int w, h;
	
	int StartX;
	int EndX;
	int StartY;
	int EndY;



	uint Comm;
	int bDraw;


	ivec4 ivWindowCur0;
	float fsh;


	// get start index
	//uStartIdx = uScatchSpace [ 0 ];
	uStartIdx = guStartIndex;

	// get end index
	//uEndIdx = uScatchSpace [ 1 ];
	uEndIdx = guEndIndex;


#ifdef ENABLE_WRITE_BACK_DEVICE_DATA

	guSubgroupSize = gl_SubgroupSize;
	guNumSubgroups = gl_NumSubgroups;
	guWorkgroupSize = gl_WorkGroupSize.x;
	guNumWorkgroups = gl_NumWorkGroups.x;

#endif


	group_x = int( gl_WorkGroupID.x );
	group_y = int( gl_WorkGroupID.y );
	group_xcount = int( gl_NumWorkGroups.x );
	group_ycount = int( gl_NumWorkGroups.y );


	// shift for the x direction should be zero
	//group_xshift = findMSB( group_xcount );
	group_xshift = 0;

	// shift for the y direction depends on number of groups in x direction
	//group_yshift = findMSB( group_ycount );
	group_yshift = findMSB( group_xcount );




	workgroup_id = gl_WorkGroupID.x;
	subgroup_id = gl_SubgroupID;

#ifdef ENABLE_MULTIPLE_WORKGROUPS

	workgroup_count = gl_NumWorkGroups.x * gl_NumWorkGroups.y * gl_NumWorkGroups.z;
#else

	workgroup_count = 1;

	// kill all other workgroups
	if ( gl_WorkGroupID.x > 0 )
	{
		return;
	}
#endif

	// size of each subgroup
	subgroup_size = gl_SubgroupSize;

	// number of subgroups in shader
	subgroup_local_count = 1 << findMSB( gl_NumSubgroups );

	// number of subgroups being used total
	// note: this doesn't have to be a power of 2 for drawing, just for transfers (transfer-in,transfer-move,frame buffer clear)
	subgroup_global_count = 1 << findMSB( subgroup_local_count * workgroup_count );
	//subgroup_global_count = subgroup_local_count * workgroup_count;


 	// subgroup global vars
#ifdef ENABLE_MULTIPLE_WORKGROUPS

	subgroup_count = subgroup_global_count;
	subgroup_shift = findMSB( subgroup_count );

#else

	subgroup_count = subgroup_local_count;
	subgroup_shift = findMSB( subgroup_count );
#endif


	subgroup_mask = ( 1 << subgroup_shift ) - 1;




#ifdef ENABLE_MULTIPLE_WORKGROUPS
	if ( xxid == 0 )
	{
		// initialize next synchronization point if multiple workgroups
		NextBarrierSync = subgroup_global_count;
	}
#endif

	// get the increments
	//if ( xid + yid == 0 )
	//{

		xxinc = int( gl_WorkGroupSize.x ) * int( gl_WorkGroupSize.y );

		// global count of shader invocations
		gxxinc = int( xxinc * workgroup_count );
	//}

	// global invocation index
	gxxid = int( gl_LocalInvocationIndex + ( gl_WorkGroupID.x * xxinc ) );


	xxmask = xxinc - 1;

	xinc = int( gl_WorkGroupSize.x );
	yinc = int( gl_WorkGroupSize.y );

	group_xinc = ( xinc << group_xshift );
	group_yinc = ( yinc << group_yshift );

#ifdef USE_NEW_SCANLINE_DRAW_VARS

	//group_vxinc = 4;
	//group_vyinc = xxinc;
	group_vxinc = group_xinc << 2;
	group_vyinc = group_yinc;
#else


	// for vector operations -> vector will be going in x-direction
	// 4 components per vector
	group_vxinc = group_xinc << 2;
	group_vyinc = group_yinc;
#endif

	group_xmask = group_xinc - 1;
	group_ymask = group_yinc - 1;

	group_vxmask = group_vxinc - 1;


	// get ids for the invocation (for drawing, like if inlining)
	lxid = gl_SubgroupInvocationID;
	lxinc = subgroup_size;
	subgroup_local_id = gl_SubgroupID;
	subgroup_global_id = subgroup_local_id + ( gl_WorkGroupID.x * subgroup_local_count );


	// get rid of any workgroups that won't be used
	//if ( subgroupAll( workgroup_id >= workgroup_count ) )
	//{
	//	return;
	//}

	// get rid of any subgroups that won't be used
	//if ( subgroupAll( subgroup_id >= subgroup_local_count ) )
	//{
	//	return;
	//}


#ifdef USE_LOCAL_DITHER
	for ( uIdx = xxid; uIdx < 16; uIdx += xxinc )
	{
		iDitherValues16 [ uIdx ] = c_iDitherValues16 [ uIdx ];
	}
#endif



#ifdef ENABLE_PRECOMPUTE_DATA

	// all global subgroups can run this now
	precompute_data ();

#endif




#ifdef USE_MEMORY_BARRIER_BUFFER

	memoryBarrierBuffer ();
	memoryBarrierShared ();
	groupMemoryBarrier ();
	memoryBarrier ();

#endif

#ifdef ENABLE_MULTIPLE_WORKGROUPS

	// need to do subgroupElect because all subgroups need to synchronize globally before they synchronize locally
	if ( subgroupElect() )
	{

		// count global subgroups that have completed the work
		CurBarrierSync = atomicAdd( auCounter, 1 );
		//atomicAdd( auCounter, 1 );

		// only need the first shader of the entire workgroup to spin wait though
		if ( xxid == 0 )
		{
			// returned the previous value above before the +1
			CurBarrierSync++;

			// would probably need to be a less than comparison due to possible race conditions
			//while ( atomicAdd( auCounter, 0 ) < NextBarrierSync )
			while ( CurBarrierSync < NextBarrierSync )
			{
				//CurBarrierSync = atomicAdd( auCounter, 0 );
				CurBarrierSync = atomicCompSwap( auCounter, 0, 0 );
			}
		
			// at the next sync point, need all subgroups
			NextBarrierSync += subgroup_global_count;

		}	// end if ( xxid == 0 )

	}	// end if ( subgroupElect() )

#endif	// end ENABLE_MULTIPLE_WORKGROUPS

	// an extra barrier
	// this should execute after precompute_data
	barrier ();


#ifdef ENABLE_RANGE_DRAW
	// calculate draw ranges //

	// get pixels between window y start and end
	// adding +1 to be inclusive of window y end
	ivWindowCur0 = ivec4( inputdata32_4 [ uStartIdx << 2 ] );
	ivWindowCur0 = ( ivWindowCur0 >> 10 ) & 0x3ff;
	h = ivWindowCur0[2] - ivWindowCur0[1] + 1;

	// divide by count of global subgroups
	if ( h > 0 )
	{
		fsh = ( float( h ) / float( subgroup_global_count ) );
		//sh = ( ( h ) / int( subgroup_global_count ) ) + 1;
	}

	// fsh should be at least one pixel
	fsh = max( fsh, 1.0f );
	//sh = max( sh, 1 );

	// determine range based on global subgroup# (start=windowx + (subgroup# * roundup(result))) (end=windowx + ((subgroup#+1) * roundup(result)))
	ivDrawRange [ subgroup_local_id ] = ivec2( ivWindowCur0[1] + int(ceil(float(subgroup_global_id) * fsh)), min( ivWindowCur0[1] + int(ceil(float(subgroup_global_id+1) * fsh)), ivWindowCur0[2] + 1 ) );
	//ivDrawRange [ subgroup_local_id ] = ivec2( ivWindowCur0[1] + ( int(subgroup_global_id) * sh ), min( ivWindowCur0[1] + ( int(subgroup_global_id+1) * sh ), ivWindowCur0[2] + 1 ) );
#endif


	//for ( uIndex = 0; uIndex < ( 1 << 16 ); uIndex++ )
	for ( uIndex = uStartIdx; uIndex < uEndIdx; uIndex++ )
	{

		//if ( subgroupElect() )
		{
		// get the next command
		uCommand = inputdata [ ( uIndex << 4 ) + 7 ] >> 24;
		}


		//uCommand = subgroupBroadcastFirst( uCommand );

#ifdef USE_NEW_SYNC_BEFORE_RUN

#ifndef ENABLE_GLOBAL_SYNC_ALL
		// synchronize if needed
		if ( subgroupAll( data [ ( uIndex << 6 ) + 31 ] != 0 ) )
#endif
		{

#ifdef USE_MEMORY_BARRIER_BUFFER

	memoryBarrierBuffer ();
	memoryBarrierShared ();
	groupMemoryBarrier ();
	memoryBarrier ();

#endif

#ifdef ENABLE_MULTIPLE_WORKGROUPS

			if ( subgroupElect() )
			{

				CurBarrierSync = atomicAdd( auCounter, 1 );
				//atomicAdd( auCounter, 1 );

				if ( xxid == 0 )
				{
					CurBarrierSync++;

					// would probably need to be a less than comparison due to possible race conditions
					//while ( atomicAdd( auCounter, 0 ) < NextBarrierSync )
					while ( CurBarrierSync < NextBarrierSync )
					{
						//CurBarrierSync = atomicAdd( auCounter, 0 );
						CurBarrierSync = atomicCompSwap( auCounter, 0, 0 );
					}

					// at the next sync point, need all subgroups
					NextBarrierSync += subgroup_global_count;

				}	// end if ( xxid == 0 )

			}	// end if ( subgroupElect() )

#endif	// end #ifdef ENABLE_MULTIPLE_WORKGROUPS

			// synchronize the workgroup subgroups locally
			barrier ();

#ifdef ENABLE_RANGE_DRAW
			// calculate draw ranges //

			// get pixels between window y start and end
			// adding +1 to be inclusive of window y end
			ivWindowCur0 = ivec4( inputdata32_4 [ uIndex << 2 ] );
			ivWindowCur0 = ( ivWindowCur0 >> 10 ) & 0x3ff;
			h = ivWindowCur0[2] - ivWindowCur0[1] + 1;

			// divide by count of global subgroups
			if ( h > 0 )
			{
				fsh = ( float( h ) / float( subgroup_global_count ) );
				//sh = ( ( h ) / int( subgroup_global_count ) ) + 1;
			}

			// fsh should be at least one pixel
			fsh = max( fsh, 1.0f );
			//sh = max( sh, 1 );

			// determine range based on global subgroup# (start=windowx + (subgroup# * roundup(result))) (end=windowx + ((subgroup#+1) * roundup(result)))
			ivDrawRange [ subgroup_local_id ] = ivec2( ivWindowCur0[1] + int(ceil(float(subgroup_global_id) * fsh)), min( ivWindowCur0[1] + int(ceil(float(subgroup_global_id+1) * fsh)), ivWindowCur0[2] + 1 ) );
			//ivDrawRange [ subgroup_local_id ] = ivec2( ivWindowCur0[1] + ( int(subgroup_global_id) * sh ), min( ivWindowCur0[1] + ( int(subgroup_global_id+1) * sh ), ivWindowCur0[2] + 1 ) );
#endif

		}	// end if ( subgroupAll( data [ ( uIndex << 6 ) + 31 ] != 0 ) )

#endif	// end #ifdef USE_NEW_SYNC_BEFORE_RUN


#ifdef ENABLE_LOCAL_SYNC_ALL

	barrier ();

#endif


		if ( subgroupAll( uCommand == 0x02 ) )
		{

			vDraw_FrameBufferRectangle_02 ( uIndex );

		}
		else if ( subgroupAll( uCommand < 0x40 ) )
		{
			// triangle //

#ifdef ENABLE_RANGE_DRAW_SKIPS
			StartY = data [ ( uIndex << 6 ) + 39 ];
			EndY = data [ ( uIndex << 6 ) + 59 ];

			if ( subgroupAll( ( EndY > ivDrawRange [ subgroup_local_id ].x ) && ( StartY < ivDrawRange [ subgroup_local_id ].y ) ) )
#endif
			{

			if ( subgroupAll( ( uCommand & 0x10 ) == 0 ) )
			{
				// mono //
				if ( subgroupAll( ( uCommand & 0x04 ) == 0 ) )
				{
					// color //

#ifdef ENABLE_DRAW_TRIANGLE_MONO_COLOR

					vDrawTriangle_Mono ( uIndex );
					//uIndex = vDrawTriangle_Mono ( uIndex );

#endif
				}
				else
				{
					// texture //

#ifdef ENABLE_DRAW_TRIANGLE_MONO_TEXTURE

					//vDrawTriangle_Texture ( uIndex );
					vDrawTriangle_TextureGradient ( uIndex );
					//uIndex = vDrawTriangle_Texture ( uIndex );

#endif
				}

			}
			else
			{
				// gradient //


				if ( subgroupAll( ( uCommand & 0x04 ) == 0 ) )
				{
					// color //

#ifdef ENABLE_DRAW_TRIANGLE_GRADIENT_COLOR

					vDrawTriangle_Gradient ( uIndex );
					//uIndex = vDrawTriangle_Gradient ( uIndex );

#endif
				}
				else
				{
					// texture //

#ifdef ENABLE_DRAW_TRIANGLE_GRADIENT_TEXTURE
			
					vDrawTriangle_TextureGradient ( uIndex );
					//uIndex = vDrawTriangle_TextureGradient ( uIndex );

#endif
				}
			}

			}	// end if ( subgroupAll( ( EndY > ivDrawRange [ subgroup_local_id ].x ) && ( StartY < ivDrawRange [ subgroup_local_id ].y ) ) )
		}
		else if ( subgroupAll( uCommand < 0x60 ) )
		{
			// line //
			if ( ( uCommand & 0x10 ) == 0 )
			{
				// mono //

#ifdef ENABLE_DRAW_LINE

				vDraw_Line ( uIndex );

#endif	// end #ifdef ENABLE_DRAW_LINE
			}
			else
			{
				// gradient //

#ifdef ENABLE_DRAW_LINE

				vDraw_Line_Gradient ( uIndex );

#endif	// end #ifdef ENABLE_DRAW_LINE
			}
		}
		else if ( subgroupAll( uCommand < 0x80 ) )
		{
			// rectangle/sprite //

#ifdef ENABLE_RANGE_DRAW_SKIPS
			StartY = data [ ( uIndex << 6 ) + 39 ];
			EndY = data [ ( uIndex << 6 ) + 59 ];

			if ( subgroupAll( ( EndY > ivDrawRange [ subgroup_local_id ].x ) && ( StartY < ivDrawRange [ subgroup_local_id ].y ) ) )
#endif
			{

			if ( subgroupAll( ( uCommand & 0x04 ) == 0 ) )
			{
				// rectangle //

#ifdef ENABLE_DRAW_RECTANGLE

				vDraw_Rectangle_60 ( uIndex );

#endif	// end #ifdef ENABLE_DRAW_RECTANGLE
			}
			else
			{
				// sprite //

#ifdef ENABLE_DRAW_SPRITE

				vDraw_Sprite_64 ( uIndex );

#endif	// end #ifdef ENABLE_DRAW_SPRITE

			}

			}	// end if ( subgroupAll( ( EndY > ivDrawRange [ subgroup_local_id ].x ) && ( StartY < ivDrawRange [ subgroup_local_id ].y ) ) )

		}
		else if ( subgroupAll( uCommand < 0xa0 ) )
		{
			// move //

			Transfer_MoveImage_80 ( uIndex );
		}
		else if ( subgroupAll( uCommand < 0xf0 ) )
		{
			// import //
			TransferPixelPacketIn ( uIndex );

		}
		

	}	// end for ( uIndex = uStartIdx; uIndex < uEndIdx; uIndex++ )





#ifdef ENABLE_DRAW_SCREEN

	if ( subgroupAll( uCommand == 0xfe ) )
	{

#ifdef USE_MEMORY_BARRIER_BUFFER

	memoryBarrierBuffer ();
	memoryBarrierShared ();
	groupMemoryBarrier ();
	memoryBarrier ();

#endif

#ifdef ENABLE_MULTIPLE_WORKGROUPS

	if ( subgroupElect() )
	{

		CurBarrierSync = atomicAdd( auCounter, 1 );
		//atomicAdd( auCounter, 1 );

		if ( xxid == 0 )
		{
			CurBarrierSync++;

			// would probably need to be a less than comparison due to possible race conditions
			//while ( atomicAdd( auCounter, 0 ) < NextBarrierSync )
			while ( CurBarrierSync < NextBarrierSync )
			{
				//CurBarrierSync = atomicAdd( auCounter, 0 );
				CurBarrierSync = atomicCompSwap( auCounter, 0, 0 );
			}

			// at the next sync point, need all subgroups
			NextBarrierSync += subgroup_global_count;

		}	// end if ( xxid == 0 )

	}	// end if ( subgroupElect() )

#endif	// end ENABLE_MULTIPLE_THREADS

	// an extra barrier
	barrier ();

		// command 0xfe
		draw_screen ( uIndex - 1 );

	}

#endif





	/*
	if ( subgroupElect() )
	{
		sVRAM [ gl_SubgroupID ] = gl_SubgroupID;
		sVRAM [ 8 ] = gl_NumSubgroups;
		sVRAM [ 9 ] = gl_SubgroupSize;
		sVRAM [ 10 ] = uIndex;
		sVRAM [ 11 ] = uCommand;

		sVRAM [ 12 ] = 
		sVRAM [ 13 ] = uiLoopCount;
		sVRAM [ 14 ] = gl_NumWorkGroups.x;
	
	}
	*/



	return;

}

